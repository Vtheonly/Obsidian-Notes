 Alors dans le chapitre précédent, on a découvert notre premier oeuvre, le userState, qui permet de créer un petit état local au niveau de un composant définie sous fond de fonction. Maintenant on peut se dire, ok, si c'est la nouvelle manière de définir des composants, comment je vais faire pour mes cycles de vie ? Par exemple, le component de ditement ou le component will andment. Comment on va pouvoir gérer ça ? Donc là, on va découvrir un nouveau oeuvre qui nous permet justement de remédier à ce problème-là, c'est le oeuvre use effect. Donc, ce oeuvre va permettre de créer un code qui va avoir un effet de bord par rapport à votre composant. Alors ce qu'on va faire, c'est qu'on va s'imaginer qu'on va garder le premier compteur que l'on avait créé et on garde ce système d'incrémentation. Ce que j'aimerais bien faire, c'est faire un sorte que lorsque j'incrémente, le titre de la page change. Typiquement, c'est quelque chose qui est en dehors du contexte du composant. Et, basiquement, il faudrait lui dire, mais j'aimerais bien détecter quand coute chang, et dès que coute change, il faudrait que je change le titre de ma page. Donc pour faire ça, on va utiliser le use effect. Donc comme pour UseState, vous pouvez l'utiliser depuis React en faisant React.useEffect où vous pouvez l'importer en haut en faisant ici un Use effect. Maintenant, je peux faire au niveau de mon système de compteur un Use effect et je devrais lui donner un premier paramètre une fonction à appeler. Donc nous, cette fonction, ce qu'elle fera, c'est qu'elle changera le titre de la page en faisant un document point title, égal compteur, suivi de la valeur de mon compteur. Coute. Si je sauve garde et que j'racalise ma page, on voit que le titre de la page devient compteur 0. Si je clique sur Incrementé, la valeur change. Donc, basiquement, on peut se dire pourquoi tu ne m'es pas simplement le code comme ça et on obtiendrait finalement le même résultat. La différence, c'est que le code que l'on doit exécuter ici, ne doit être exécuté que si le compteur change. On pourrait s'imaginer que notre compteur a peut-être donc d'autres fonctionnalités et on ne veut pas nécessairement relancer le code qui change le titre systématiquement. Donc UseEffect va prendre un second paramètre qui sera un tableau des valeurs à observer des dépendances. Donc nous, ici, on va lui dire, c'est coute. Donc, le ballement, ce tableau de dépendance est très important parce qu'il va permettre de détecter quand il y a des changements. Donc, si une des valeurs de ce tableau a changé automatiquement l'effet, le code qui se trouve dans le UseEffect va être réexécuté. Donc, si je s'affigue, et que maintenant je clique sur Incrementé, je ne vais pas forcément voir de changements. C'est tout à fait normal, parce que finalement, c'est le seul état qui change dans notre composant. Mais si je ne mets rien au niveau des dépendances et que j'essaye maintenant de réincrémenter, qu'est-ce qu'on remarque ? On remarque que finalement le titre ne change jamais. C'est-à-dire que le code à l'intérieur de cette fonction ne change jamais. Et ça ne change jamais parce qu'on a aucune dépendance. Donc lui dit, ok, la première fois que je monte ton composant, j'utilise le UseEffect. Par contre, je n'ai rien à observer. Donc, ça veut dire qu'au niveau des rendus suivants, je ne vais pas réexécuter le code parce que la valeur du tableau n'avaient changer. Donc, si vous mettez un UseEffect comme ça, en lui passant en seconde paramètre un table au vide, ça c'est l'équivalent de ce qu'on avait vu avec les classes du Components. Dide, monte. Ça permet de détecter, en fait, quand le composant a été monté, ce code de là ne sera exécuté que quand le composant a été monté. Un autre exemple d'utilisation, c'est pour par exemple créer un timer. En aimerait bien que quand le composant est monté, la valeur s'incrémente toute seule. Et que toutes les secondes on est la valeur qui s'incrémente. Donc, là, ce que je vais faire, c'est que je vais lui dire, mais lorsque le composant est monté grâce aux UseEffect avec un paramètre vide, je vais faire un Windows. Cet Interval et je vais lui demander de lancer une fonction. Et cette fonction ce qu'elle fera, c'est qu'elle fera un appel à un increment pour incrementer la valeur. Et je vais faire cet appel toutes les secondes. Si je sauve garde maintenant, on voit que toutes les secondes y a bien une incrementation. Alors, je vais mettre ici un petit console point log et remettre l'eau. Donc, toutes les secondes, je vais voir l'eau. On s'imagine maintenant que, à un rendu consecuatif, le compteur disparait. On va pas s'embêter, on va simplement écrire un petit peu de code ici. Et on va lui dire de faire un set Timeout. D'atteindre par exemple 2 ou 3 secondes et au bout de 2 ou 3 secondes, on va lui demander de refaire un rendu sans le compteur secoucit. Comme ceci. On va juste rendre une dive qui dira bonjour. Et on fait ce code-là au bout de 2 secondes. Donc, je sauve garde, ça réactuifie l'appage. Au bout de 2 secondes, de mon composant disparaît. Et on voit maintenant qu'on a notre élo qui continue à s'afficher avec des erreurs au niveau de réacte. Ce qui se passe, c'est que là, lorsqu'on a monté notre composant, on a démarré un timer. C'est bien ce que l'on veut faire. Le problème, c'est que notre composant est plus tard démonté. Et ce timer va rester en mémoire et va continuer de s'exécuter. Et qu'un réacte voit son increment, il dit, oui, maintenant, je ne peux pas appeler. Le composant n'existe plus, donc tu essayes de changer l'état d'un composant qui n'existe plus. Donc là, c'est le signe d'un gros problème de logique. Alors on peut se dire qu'elle est l'équivalent du coup du component Wheel End Mente. Comment on fait pour détecter quand le composant est démonté ? Le use-effet, lorsqu'il est appelé, vous pouvez lui dire de retourner une fonction. Cette fonction, elle sera utilisée à chaque fois que le use-effet, ce sera appelé. Donc, à chaque fois que la valeur qui en est pendant ce change, ou dans le cas d'un composant qui n'a aucune dépendance, à chaque fois que le composant est démonté. Donc nous, ici, ce qu'on va faire, c'est qu'on va sauvegarder la variable Timer, qui sera donc le Timer qu'on a démarré. Et on lui dira, mais pour ce système-là, je veux que tu retourne une fonction. Et cette fonction, elle fera un clear interval et elle supprimera le Timer. Donc maintenant, à chaque fois qu'il y a un démontage, il va supprimer le Timer. Si je sauvegardes et que j'attends un petit peu, envoie-ci qu'on n'a plus d'appel à ELO et ça fonctionne convainablement. Donc si jamais votre effet de bord doit être désinitialisé, ce qui va être le cas très souvent lorsqu'on va travailler avec les Timer, maintenant ce cas-là, il ne faudra pas hésiter à utiliser une fonction de retour pour expliquer ce que l'on fait. Donc c'est très très important lorsqu'on utilise le use-effet, penser et réfléchissez à ce que vous avez besoin d'un effet de nettoyage. C'est-à-dire, est-ce que vous avez besoin d'effacer des éventuels traitements qui aurait pu être fait à l'intérieur de votre use-effet dans l'appel précédent ? Enfin, d'un des petits détails, il ne faudra pas hésiter à utiliser plusieurs fois le use-effet. Là, on peut imaginer qu'on est content, on a bien notre système qui va permettre d'incrémenter la valeur, mais on veut garder le système que l'on a véhicrit initialement qui permet de changer les titres. Dans ce cas-là, ce que l'on peut faire, c'est rajouter un nouveau use-effet. Et lui dire, bon, ben ça, ça sera un use-effet qui changera que lorsque la valeur de coute change. Alors vu que c'est le seul état du composant, on pourrait lui dire finalement que tu peux le rendre au tout le temps, mais c'est pas grave. Et à l'intérieur ici, on va lui dire, ben je veux que tu change, je le titres en faisant un document de pointe title, et gale, on avait dit compteur suivi de la valeur, donc c'était coute. Comme ça, et comme ça, on a nos deux oucs qui sont déclenchés en concordance, là, avec l'autre. Il ne faut vraiment pas hésiter à utiliser plusieurs oucs si la logique est différente. On pourrait être tenté de mettre directement le changement de compteur à son niveau-là, mais c'est pas pertinent. Non, non, non, on peut vraiment avoir cette notion de ce ouc-là et réserver pour la création et la gestion du timer. Et ce ouc-là va être responsable de l'effet de bord concernant le titre. Donc pareil, si je regarde la partie composant ici au niveau de ma console, grâce à mon petit système d'inspecteur React DevTool, je vois bien que j'ai mon premier ouc qui s'appelle Increment, qui est mon ouc personnalisé qu'on avait créé dans le chapitre précédent. Et ensuite, j'ai mes deux oucs d'effets qui permettent de changer respectivement le timer et aussi le titre. Et voilà, pour cette petite découverte. Alors ce qu'il faut retenir, c'est que NewsEffect est utilisé pour créer des effets qui sont associés à vos changements d'Etat. En premier paramètre, on lui donne une fonction qui va permettre de faire un traitement. Par exemple, nous, on l'a utilisé pour des timers, on l'a utilisé pour changer le titre, mais on peut s'imaginer l'utiliser aussi pour se connecter à une pays de websoquette pour récupérer des messages. On peut s'imaginer gréffer des événements. On peut avoir pas mal de défais possible. On peut aussi l'utiliser par exemple avec des références pour gréffer des plugins de JavaScript qui ne seraient pas avec React. Tout ce que l'on pourrait faire avant dans le component d'idmante, le component Will & Man tout le component d'idm. Ensuite, dans ce qu'on paramètre, on va lui passer les dépendances. C'est-à-dire les valeurs a observées pour savoir si on doit réexécuter le look d'effet. Enfin, vous pouvez, à la fin de l'use effect, retourner une fonction, qui sera une fonction de nettoyage, qui permettra de supprimer les éléments qui auraient pu être créés par la précédent appel à use effect. Donc, pensez à l'utiliser, si vous abonner, par exemple, au websoquette, il faudra penser à se déconnecter lorsqu'il y a un changement d'état. Et pareil, là, dans le cadre de nos timers, on fait un clear interval pour être sûr de bien supprimer l'interval. Donc voilà, pour ce petit principe de look. Alors, ce que je vous propose dans le chapitre suivant, c'est de pratiquer un petit peu ces look, rien qu'avec use effect et use state. Vous allez voir qu'on peut faire pas mal de choses et on va découvrir et revenir sur l'utilisation et la création de look personnalisée. Donc, je vous donne rendez-vous dans le prochain chapitre.