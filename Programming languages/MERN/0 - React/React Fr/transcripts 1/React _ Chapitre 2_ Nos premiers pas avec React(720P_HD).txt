 Bienvenue dans ce premier chapitre, je vous propose de faire nos premiers pas avec React et de créer notre premier élément et de le brancher au dom. Avant de commencer, je tiens le préciser, il est important de noter que la documentation est disponible en français, donc si vous arrivez sur le site en anglais par défaut, vous pouvez cliquer sur le Rengueil Gis et ensuite aller sur Français. Vous pouvez ensuite aller sur la documentation, impliquant sur le bien démarré et vous allez avoir tout un tas d'informations sur le fonctionnement de React. Cette documentation est extrêmement bien faite, je vous invite à la lire même si vous suivez cette formation à appréhée pendant les vidéos pour avoir un peu plus de détails. Si certaines points ne vous semblent pas clair à l'issue d'une vidéo, n'hésitez pas à regarder cette documentation, elle est extrêmement bien faite et contient beaucoup d'informations. L'idée de cette formation, c'est de synthétiser un petit peu les choses. D'ailleurs, en parlant de cette documentation, on va ici se rendre sur l'Iens et Dn et on va prendre ces liens là pour pouvoir commencer à travailler avec React. Alors, ce n'est pas forcément la manière standard de travailler avec React, mais c'est la manière la plus simple qui va nous permettre de commencer rapidement. Je ne veux pas forcément vous embêter avec l'utilisation d'outils comme Node.js ou autre pour juste découvrir cette livrairie, ça sera amplement suffisant. On peut tout être remarqué aussi que l'on a deux JavaScript. Pourquoi ça ? Pourquoi on n'importe pas simplement React ? Pourquoi on a besoin de cet autre JavaScript ? React, Thierry, d'homme. Donc il faut bien comprendre que React, c'est une livrairie très simple qui permet simplement de créer des éléments. Ensuite, ces éléments, il va falloir les brancher à quelque chose, soit au dom, soit une application native, soit autre chose. Donc, React, Thome va nous permettre de brancher les éléments React à notre page web. Donc, lorsqu'on parle de faire du React.js pour du web, on parle du combo React plus React, Thome. Donc c'est pour ça qu'on a ces deux parties là. Si quelqu'un fait du développement pour, par exemple, créer des applications native, il utilisera React et React, Thome. Et il n'utilisera pas du tout React, Thome. Donc je vais copier ces deux lious là et on va les créer un nouveau dossier pour commencer. Donc dans mon système, je vais aller créer un nouveau dossier que je vais appeler, tuto React. Ce dossier, je vais ensuite ne glisser sur mon éditeur. Donc ici, j'utilise Visual Studio Code, que l'on avait déjà vu dans l'information HTML et CSS, mais vous pouvez utiliser n'importe quel éditeur. Je vais aller créer un nouveau fichier que je vais appeler index.html et à l'intérieur, je vais y mettre la structure HTML standard en utilisant la préviation offerte par Visual Studio Code. Dans la partie en tête ici, je vais charger mes deux JavaScript. Je vais juste rajouter un attribut défeur pour dire de charger ces JavaScript à la fin du parsing de notre donne. Je vais en profiter pour charger un troisième JavaScript qui sera celui-ci correspondra à notre démo. Donc je vais charger un nouveau script, je vais mettre et serrer app.gss et on utilisera défeur pour le charger à la fin. Maintenant je vais pouvoir créer ce fichier là. Donc je m'orain à la racine de mon projet et je vais créer app.gss. Et on a fini pour cette partie là. Maintenant je vais ouvrir cette page HTML au niveau de mon navigateur et je vais utiliser directement le Live Server. Donc c'est une extension de Visual Studio Code que l'on avait installé précédemment. Et cette extension va nous permettre de réactuer les choses automatiquement. Donc je fais Control Shift P et je fais Live et je sélectionne l'option Open with Live Server. Automaticement il m'a dit qu'il a bien démarré sur le port 5500. Il a ouvert une page sur mon navigateur, alors c'est pas le bon. Donc nous ici on va regarder pour ouvrir un nouvel anglais, on va taper le loc à l'oste.1500. Et on arrive sur cette page blanche. Ce que l'on va faire aussi c'est qu'on va sortir notre inspecteur pour pouvoir voir si on a des erreurs en console par exemple. Donc on est prêt à commencer. Donc notre objectif c'est de créer un titre dans notre bodhi qui dirait bonjour tout le monde. Donc au niveau de mon app.gs je vais créer un premier élément un utilien réacte. Donc je vais faire React, Forinc create Element et je vais lui passer un premier paramètre le nom du tag. Nous ici on s'y boule le dom, donc on va mettre le nom du tag HTML. Ensuite en second paramètre on va pouvoir lui passer des options. Alors ces options dans notre cas seront des options qui seront associées aux attributs HTML. Pour l'instant on ne met rien et en troisième paramètre on met les enfants. Donc les enfants ça peut être de d'autres éléments réactes ou ça peut simplement être du texte si on veut un eau de type texte en sortie. Donc moi ici je vais mettre bonjour tout le monde. Maintenant je vais sauvegarder cet élément dans une variable que je vais appeler title. Et tout de suite je vais le débuguer pour regarder de coin à retour. Un faisant un console point log de title. Si je sauvegarder et que je regarde un petit peu dans ma console, je vais voir que ce que me renvoie React c'est un simple objet javascript qui va contenir certaines propriétés. On appropse qui contient les propriétés que l'on aurait mis ici plus une propriété supplémentaire qui s'appelle Chindrun qui contient les enfants. Nous ici le nom Bonjour tout le monde. Si on avait un autre nom, par exemple si je mets bonjour tout le monde, suivi d'une nom d'une personne, Jean, et que je sauvegarder, dans la partie Chindrun je vais avoir un tabou. Voilà donc c'est juste une conversion qui est faite par cette fonction CREATE élément. On a aussi le type qui correspond à ce qu'on a mis en premier paramètre. Donc en soi cette fonction CREATE élément elle ne fait que ça, elle crée juste un élément qui pourrait être utilisé ensuite par d'autres outils. Donc le second point qui nous faut mettre en place, c'est brancher cet élément là au niveau de notre dome. Donc c'est là que ReactDom intervient, on fera ReactDom. PointRender, on lui passe en premier paramètre un élément react, nous ici ce sera notre titul et en seconde paramètre l'élément dans lequel on souhaite brancher notre élément react. Nous on va prendre simplement le bodi de notre document. Si maintenant je sauvegard, je vois bien ici bonjour tout le monde. On a aussi une petite erreur où on nous explique que c'est déconseillé de faire ça. Donc pour éviter ce problème là, on va simplement créer une dive qui aura comme IDApp et on branchera plutôt notre élément react dans cet élément là. Donc on fera ici un document de point QuerySelector et on sélectionne notre élément qui a IDApp. Et automatiquement ça fonctionne bien. Alors on peut se dire finalement pourquoi on avait besoin vraiment de React. Est-ce que j'aurais pas eu plus vite fait de faire un document pour une QuerySelector ? Je sélectionne les élément qui a IDApp et rajoutez simplement mon in-ear HTML en mettant le contenu que je souhaite. Et dans cette situation vous avez entièrement raison, il n'y a pas de bénéfice mais vous allez le voir c'est beaucoup plus intéressant que ça. React va nous permettre d'aller un petit peu plus loin. Je vais garder ça de côté, ça va être intéressant. Donc maintenant imaginons que on a envie d'avoir un petit timer qui s'affiche après et qui s'incrémate. Et on a envie d'aller le mettre dans une spanne. Donc vous avez la possibilité dans les paramètres de créer des élèmettes de mettre comme je l'ai dit du texte, mais vous pouvez aussi créer d'autres éléments. Par exemple je peux lui dire juste après, j'aimerais bien avoir un nouvel élément React qui sera une spanne. Donc là je mets span, je ne l'umère rien en propriété et ensuite je mets notre texte. Par exemple ici 0 et plus tard on l'incrémentera. Si je sauve garde maintenant, je vois bien que j'ai à ce niveau-là une spanne. Mais j'ai envie que ça s'incrémente toutes les secondes. Donc pour incrementer les choses, je vais lui demander de sauve garder un numéro et de l'incrémonter ce numéro et de réappeler cette fonction-là. Donc cette partie-là je vais la sauve garder dans une fonction. Je vais appeler Render. Cette fonction je l'appelle dès le chargement de la page, comme ceci. Et maintenant je me dis je vais appeler un interval toutes les secondes et cette intervals, ce qui va faire ce qui va leur relancer Render. Et juste avant il l'incrémentera peut-être un petit numéro. Donc je l'ai créé une variable que je vais appeler n, qui aura comme valeur initiale 0. Je lui demande à chaque fois qu'il incremente de faire un n plus plus et de refaire un Render. Et pour que je vois ce chiffre au niveau de mon interface, je vais remplacer le 0 par le n ici. Si je sauve garde et que je réactue l'ise, on voit que ça s'incrémente. On va peut-être mettre un petit lélée pour ce ne le fasse que tout les secondes. Alors encore une fois on peut se dire qu'elle est l'intérêt parce que est-ce que je ne répète pas plus faire la même chose avec ce inorage TML. Si vous inspectez votre code, vous allez voir une grosse grosse différence. On voit que ce qui apparaît ici en joie, c'est-à-dire ce qui est modifié tout les secondes, ce n'est pas tout notre HM mais c'est simplement la spam. En fait ce que va faire réacte c'est qu'il va être capable de détecter que à chaque fois que l'on fait un Render, la seule chose qui change entre nos différents Render, c'est le contenu de notre spam. Donc la seule chose que lui il va changer, c'est le contenu de notre spam. Pour vous donner un exemple concret, on va appeler cette fonction Render2 et on va imaginer le fonction Render basé sur le inorage TML et vous allez pouvoir comparer clairement ce qui se passe. Donc on va faire un Render ici et plutôt que de faire notre code compliquée avec réacte, on fait simplement notre inorage TML et on met dedans une spam qui recevra le numéro N ici. Voilà, donc c'est la même chose mais plus naïf on va dire. Là on le voit à chaque fois qu'il y a une mutation, c'est tout le H1 qui se trouve modifié. Ce qui est un terme de structure est beaucoup plus complexe. Vous pouvez imaginer que si vous avez un site qui a beaucoup beaucoup d'HTML, vous pouvez pas vous permettre toutes les secondes de modifier la totalité de la structure de la page. Il faut un moyen de faire le moance de modification possible. Donc voilà pourquoi l'utilisation de réacte va être intéressant par rapport à un simple inorage TML par exemple. En internes ce qui se passe c'est que réacte ici à cet objet-là que l'on avait analysé tout à l'heure, qui permet de représenter notre élément. Lorsqu'il fait un Render, il dit ok. Pour l'élément qui a l'ID app, j'ai branché cet élément là. Maintenant, un nouveau rendu est demandé. Donc lui dit ok, sur cet élément qui a l'ID app, tu as envie de brancher ce nouvel élément. Donc je vais comparer un élément que j'avais actuellement à la méthode précédente et je vais voir les différents notifications qu'il y a. Ah, je vois que le span a changé de contenu. Donc la seule modification que moi je dois faire pour pouvoir reflétter tes changements c'est changer le contenu de l'aspagne. Donc je ne change que le contenu de l'aspagne. Et c'est comme ça que réacte va optimiser les changements. Alors voilà pour cette petite présentation et cette petite découverte de réacte. Alors évidemment ce qu'on a écrit ici, c'est pas forcément du code que l'on va écrire de manière générale. Vous allez voir qu'il est plus évident de se structurer. L'autre problème que l'on a, c'est que ces appels-là, ils ne sont pas très, très pratiques. Donc si vous revenez sur la documentation ici, donc on va revenir sur la page d'accueil et que vous descendez un petit peu, vous allez voir que, eux dans le code qui ils écrivent, ils n'écrifent pas le create element. Ils utilisent simplement de la syntax qui ne paraît pas être du GS valid. Si on regarde ça, c'est bizarre. On ne peut pas normalement mettre des dives directement dans le JavaScript. Ils utilisent tout simplement une syntax alternative, qui s'appelle le GF-X, je vous en avais parlé en introduction. Et cette syntaxe elle va permettre de créer des éléments réactes beaucoup plus simplement, avec une apparence qui sera proche beaucoup plus de ce que l'on connaît, avec l'HTML par exemple. Donc vous voyez que dans tous les exemples, ils utilisent cette syntaxe-là. Mais derrière ce qui se passe, si vous décochez cette case-là, c'est qu'il fait simplement des réactes point-cruites éléments. C'est simplement des raccourses-ci qui nous permettent d'aller plus vite. Donc c'est pour ça que pour moi, il était important de vous montrer comment on écrivait du réacte de manière basique. Vous vous faire comprendre dans ce qui se passe derrière. Du coup, dans le prochain chapitre, je vous propose d'analyser cette syntaxe-là et de réécrire ce que l'on a commencé à écrire ici, en utilisant cette fameuse syntaxe GSX.