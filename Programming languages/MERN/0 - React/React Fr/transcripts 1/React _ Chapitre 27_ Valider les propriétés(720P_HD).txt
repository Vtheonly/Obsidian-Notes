 Bienvenue dans ce nouveau chapitre, nous allons parler de prop types qui permet de valider les propriétés qui sont reçus par un composant. Donc finalement, si on réfléchit bien, un composant ne n'est ni plus ni moins que une fonction qui reçoit des paramètres à travers des attributs. Le problème, c'est que ces paramètres parfois peuvent ne pas avoir la valeur qui est attendue. Pour vous illustrer l'exemple de manière très simple, j'ai ici créé une petite composante qui s'appelle double et qui affiche le double d'une valeur. Il prend par mettre un nombre et il fait un n plus n. J'ai pas fait foi de volontairement. Ce qui se passe, c'est que moi dans ma tête, je me dis que n sera un nombre et, bien dans mon carré elle ici, je lui envoie une chaîne de caractère. Ce qui fait que lorsqu'il fait la vision, j'obtient 11 plutôt que d'obtenir 2. Donc là, il me faudrait un moyen de vérifier que n soit bien un entier. Pour renvoyer une erreur, lorsque j'écris ici que n est une chaîne de caractère. Donc c'est là que le système de prop types intervient. Donc prop types, c'est une libre-érit qui vous pouvez récupérer sur npm. Nous pourrons faire npm prop types et qui va permettre de mettre en place une validation des différentes propriétés qui sont reçues par les composants réactes. Donc la première étape va être d'installer 7 dépendances. Donc je vais ouvrir un nouveau terminal et je vais faire un yarn, add, prop, tiré types. Ensuite, je vais pouvoir importer prop types au niveau de mon... J'avance gripte donc tout en haut je vais faire un importe prop types, from, prop, tiré types. Maintenant que c'est importé, je vais pouvoir forcer les types des propriétés au niveau de mes composants. Donc on va le faire ici pour notre composant double. Pour se faire, on fait double.prope types et gale à nouvelles objets. Dans cet objet, on va préciser un clé le nom des propriétés, moi c'est par exemple la propriété n et ensuite on précisera son type en faisant prop types. Point et on voit qu'on a différentes propriétés que l'on peut utiliser qui vont permettre de définir la structure de notre objet. Donc moi dans notre cas ici, je vais mettre number. Si ce nombre est nécessaire, je peux aussi rajouter required. Donc là, automatiquement, je lui dis qu'on a besoin d'une propriété qui va s'appeler n, qui doit être un nombre et qui est requis. Si maintenant je reviens au niveau de mon application et que je réactualise ma page, mon rendu va quand même se faire, donc c'est important ce ne va pas bloquer votre rendu, mais par contre je vais avoir un petit terrain en console qui va me dire que la propriété n est de type chaîne de caractère, alors que moi, je m'attendais à voir un nombre. Donc pour remédier à ce problème là, ce qu'il faudrait que je fasse ici, c'est lui préciser que n sera un nombre. Dans ce cas là, lorsque la page est réactualisée, je n'ai plus de problèmes. Donc ça vous permet comme ça de valider les différentes propriétés qui sont reçus par aux différents composants. Par exemple, j'ai une méthode en clause. Donc je peux lui dire, au niveau de modèle, je vais avoir des prop types et au niveau de ces prop types, j'aurai un clause et au no clause, ça sera un prop types point, func pour dire que c'est une fonction et je peux préciser qu'elle est requise ou non. Donc là, je vais mettre ces requis et dans ce cas là, ça validera les choses. Si par exemple au niveau de mon application, je lui envoie nulle, c'est à dire que ce n'est pas une fonction. Dans ce cas là, lorsque je vais cliquer sur go, ce moire, on va bien avoir une erreur ou il va me dire, on clause doit être requis et ben là, ça ne fonctionne pas. Donc ça peut être très intéressant pour valider les propriétés et détecter les bugs un petit peu plus sans amont. Et vous permettra d'avoir des erreurs qui vont être un petit peu plus évoquatrice, plutôt que de laisser cette propriété rentrée dans votre composant et générer des erreurs à l'intérieur. Donc vous avez comme ça tout un tas de méthodes qui permettent de valider les choses. Donc vous les avez listé à cet endroit là. Donc basiquement, vous pouvez valider les différents types qui correspondent en JavaScript. Vous pouvez valider que c'est une instance d'un objet particulier. Vous pouvez aussi faire des validations qui sont des combinaisons. Par exemple ici, vous pouvez les dire, ça est quelque chose qui est soit une chaîne de caractère, soit un nombre, soit une instance de quelque chose. Vous pouvez les dire, c'est un tableau 2 ou c'est un objet qui contient telle ou telle chose. C'est un objet qui doit contenir telle ou telle propriété. Donc on peut avoir une validation qui est plus ou moins poussée suivant la situation. Donc là encore une fois, ça va dépendre des différentes propriétés que vous voulez avoir. Enfin, d'un petit point, c'est sur les enfants. On s'imagine ici que j'ai une boîte modale et plutôt que d'avoir le body à ce niveau-là, je veux avoir un children comme ceci. Et à ce niveau-là, je vais lui préciser donc que j'aurai un enfant. Je vais descendre un petit peu dans mon structure. Et pour l'instant, je ne vais rien mettre au niveau de cette boîte modale. Je vais juste lui dire ici, j'aimerais bien utiliser la fonction aïde modale qu'il y avait avant. Donc je vais revenir sur mon petit application et je vais valider donc cette propriété de children. Donc à ce niveau-là, je vais rajouter une propriété de children et je vais utiliser prop types. Et là, on a deux choses, on a éléments et on a notes. Alors un élément, c'est un élément. Par exemple, c'est ça, cette dit-là, c'est un élément. Alors que ne ça peut être de différentes types, une chaîne de caractère, un tableau, tout ce que l'on pourrait mettre en enfants. Donc dans notre situation ici, si on souhaite que un enfant puisse avoir plusieurs élément achetés mèles, mieux voudraient utiliser comme validation note. Est-ce que c'est nécessaire ou non ? Moi, j'estime que effectivement pour une boîte modale, il faut un enfant. Donc je vais écrire les choses de cette manière-là. Et lorsque je clique sur go-samware, on voit effectivement qu'il y a un problème. Donc dans cette situation ici, il faut que je mette un petit peu de texte. Bonjour, par exemple. Donc je vais réactualiser, je clique sur go-samware et cette fois-ci on a plus de problèmes. Si je mettais une validation de type élément, là, il va me dire, je m'attendais à avoir un élément réacte et j'obtienne une chaîne de caractère. Donc ça ne correspond pas. La seule chose qui serait acceptée, c'est qu'on est quelque chose qui ressemble à ça. Dans ce cas-là, on a effectivement un élément et ça ne pose pas de problème. Donc c'est vrai que cette distinction n'est pas forcément évidente, mais penser à un élément, c'est un élément réacte et un seul élément. Alors qu'un note, un eau, c'est tout ce que peut accepter un enfant, un élément réacte. Donc si jamais vous avez Chindrun, vous allez le valider tout le temps de cette manière-là, en précisant que vous attendez un eau. Aussi, ce que vous pouvez faire avec ce système de propriété, c'est définir une valeur par défaut. Cependant, je trouve que avec la nouvelle syntaxe qui permet de destructurer, ce n'est plus forcément quelque chose qui est utile, mais je souhaite quand même vous le montrer. Donc là, on va laisser ce système-là, on va retirer ce Chindrun et on va préciser qu'on a une valeur par défaut. Donc au niveau de notre modèle, on va mettre un ici, un modal point default props. Et on va préciser que la valeur de Chindrun, ça sera bonjour. Si je sauvegarde maintenant, lorsque je clique sur Go, Summware, on voit qu'on n'a pas de problème même si la valeur est nécessaire et il aura mis cette valeur par défaut. Comme je le disais, ce n'est pas forcément très pertinente, parce que aujourd'hui avec la nouvelle syntaxe, vous pouvez écrire les choses de la manière suivante, comme ceci. Et dans ce cas-là, vous allez obtenir le même résultat. La différence, c'est que si vous faites les choses de cette manière-là, les propstips vont valider les données avant le default props. Alors que si vous écrivez les choses de cette manière-là, je reviens sur mon bonjour, on va mettre bonsoir. Et que je sauvegarde, là, ça ne crée pas une erreur de validation, parce que en fait, il applique les valeurs par défaut avant de valider les propriétés. Donc il y a quand même une légère différence. Si vous choisissez d'utiliser le système de propstips et que vous voulez mettre une valeur initiale, ça peut être utile de faire les choses de cette manière-là. Une autre solution dans notre situation, c'est tout simplement de lui dire que ce champ-là chindre n'est pas nécessaire, donc on enlève ce isre required et on met la valeur à ce niveau-là par défaut. Donc là, à vous de voir ce que vous jugez le plus clair évidemment. Mais faites attention, le ordre de validation est important. C'est d'abord, il met les défauts props après ils valient les propstips et ensuite il exécutent ce code-là. Enfin, un dernier petit détail est sûr la validation des types, donc ça c'est une validation qui est intéressante parce qu'elle se fait à l'exécution. Mais vous avez aussi la possibilité de faire des validations statiques. Une validation statique, c'est tout simplement une validation qui se fait un lisant votre code. Alors ça sort un petit peu du cadre de stuturiel, mais je veux juste vous présenter ces deux stratégies, pour utiliser deux langages qui sont flow et typescripts. Donc typescript, vous en avez peut-être déjà entendu parler, c'est globalement quelque chose qui vous permet d'écrire du JavaScript qui est typé. Donc lorsque vous allez créer une variable, vous allez pouvoir dire, ah, cette propriété-là, elle est de ce type-là. L'avantage, c'est que vu que React fonctionne avec de simple fonction, si vous typez les paramètres de la fonction, ça revient à valider les types des propriétés. L'inconvénient de cette validation-là, c'est qu'elle ne se fait que de manière statique, c'est-à-dire que lorsque votre code lui va être exécuté, il ne validera rien, mais ça vous permet de capturer les erreurs en amont. Donc de la même manière, vous avez aussi flow, qui est un petit peu le même principe, mais ça a été créé par Facebook et qui permet en fait de valider les types, mais avec une syntaxe qui est légèrement différente. Donc aujourd'hui, on trouvera la plupart du temps du TypeScript pour des validations statiques, mais voilà, de temps en temps, vous pouvez tomber sur du code que tu utilises flow. Si vous voulez rester absolument en JavaScript, le système de propstips peut être une bonne solution pour valider les propriétés qui sont reçus par vos composants. Pensez en revanche, choque ça rajoute aussi un petit peu un coup en performance vu que les propriétés sont validés à chaque fois que votre composant est appelé. Donc j'espère que cette vidéo vous aura permis d'y voir un petit peu plus clair sur comment on valider vos propriétés et je vous donne rendez-vous un chapitre suivant.