 Salut bienvenue dans ce nouveau chapitre où je propose de découvrir ensemble comment tester vos composants react. Pour tester une application react, on a deux solutions. Soit on peut tester nos composants de manière isolée, dans ce qu'elle a en bas les montés et vérifier que la structure et les événements fonctionnent convenablement. Soit on va les tester de manière complète, c'est-à-dire qu'on va monter notre application et tester ça sur un navigateur réel. Les méthodes de test en react ne vont pas être bien différentes des méthodes de test en javascript classique. J'ai déjà fait une formation sur les tests en javascript et beaucoup des concepts qu'on a vu dans cette formation seront valables ici. Je vous invite d'ailleurs à regarder plus spécifiquement le chapitre concernant les tests fonctionnels avec Cypress, qui vous permet de simuler un navigateur et de faire des comportements. Et ensuite la partie Gest parce que c'est le frein mort que l'on va utiliser dans cette vidéo là. Donc si vous utilisez le template create react app que l'on avait vu au début de cette formation, automatiquement vous aurez déjà tout l'environnement de test qui va être configuré. On l'avait vu, il y a même un fichier pour le composant app par exemple qui s'appelait app.test.gest, qui contient déjà un petit test pour tester notre application. Moi ici j'ai choisi de vous montrer sans rien parce que je parle du principe que vous pourriez être amené à utiliser react pour une application qui ne serait pas forcément un template react. Donc j'ai créé une boîte modèle et cette boîte modèle j'ai fait une petite erreur. Je n'ai pas appelé on clause lorsqu'on clique sur le bouton fermé. Donc notre objectif ça a été de créer des tests qui vont permettre de détecter ce problème là. Comme je vous le disais, les tests vont être écrits avec Gest et on peut les organiser de différentes manières. Soit on peut créer un dossier test qui va contérienble de nos tests, soit on peut mettre les fichiers au même niveau que nos composants mais en utilisant le suffix test directement. Donc là c'est une question de préférence personnelle, les avoir au même niveau ça vous permet de faire des alliés retour un petit peu plus rapidement mais c'est vrai que ça peut complexifier la structure. Donc à l'intérieur de ce fichier là, mais on va pouvoir récrire nos tests, donc les tests s'écrivent comme ceci, on met tests, le nendot d'un autre test, on va mettre ce scénario d'exemple. Et ensuite on va mettre une fonction qui va permettre de lancer le test. Dans cette fonction, on va utiliser une insertion qui permet de vérifier que une valeur est bien celle-atendue. Donc par exemple ici je lui dis je m'attends à ce que un soit égal à un. Pour utiliser ces tests là et les lancer, il va nous falloir utiliser Gest. Donc je vais ouvrir mon terminal et je vais initialiser d'abord NPM parce que je n'ai pas du tout initialisé les choses ici. Ensuite je vais installer Gest, donc vous pouvez l'installer en faisant un NPM install ou un Yarn. Ad, tirerD parce que c'est une dépendance de développement Gest. Une fois que c'est installé, vous pouvez lancer Gest en faisant NPM Gest. Et automatiquement ça va lancer les tests, trouver les fichiers qui terminent par test.gx et on voit bien que ça fonctionne. Alors nous ce que l'on voudrait faire, c'est tester vraiment notre composant reactant. On va faire un test simple pour l'instant, on aimerait bien voir que le titre se met bien par exemple au niveau du modèle hédeur. Donc si vous regardez la documentation de react, on vous parle un peu dans la documentation de la partie test. Et on vous dit si vous souhaitez faire des tests, dans la partie recette de test, il faut monter le composant avant notre test et ensuite le démontrer. Donc pour tester notre code react, finalement on va tester comme on nous ferait pour tester du domme classique. On va montrer notre élément, vérifier qu'il est bien au bon endroit et ensuite le démontrer pour ne pas polluer les tests suivants. Alors il faut savoir que vous n'êtes pas obligé de faire appel à un navigateur pour pouvoir tester le domme, vous pouvez faire appel à Gest.gx.gx, qui est une libre-erie qui permet de simuler les appels Gs directement sur notre Gs. Ça à l'entage d'être plus performant et plus rapide pour notre test. De la même manière, vous n'êtes pas obligé de faire tout ce traitement-là, il faut savoir que vous avez des libres-eries qui sont un petit peu plus... qui vous permet de simplifier les choses. Donc la libre-erie qui est notamment utilisé sur le template create react app par défaut, c'est cette libre-erie qui s'appelle testing library. Elle contient tout un ensemble d'aide qui permet de travailler avec le domme mais aussi avec react. Si vous regardez la partie exemple avec react, vous allez voir que vous avez une fonction rèndeur qui permet par exemple de rendre un élément directement. Vous avez farravent qui permet de lancer un événement. Donc tous ces helpers-là vont nous permettre de gagner du temps. Pour les utiliser, il faut commencer par installer testing library et on va prendre la partie react. Je vais copier ce nom-là et au niveau de mon terminal, je vais rajouter le nouvel dépendance en dépendance de développement et ça sera testing library slash react. Maintenant, au niveau de mon modal point S.gs, je vais lui dire j'aimerais bien que tu rendes en utilisant la fonction rèndeur et je veux que tu crées modal. Le modal, je vais l'importer au-dessus. Au niveau de cette boîte modal, je vais mettre un titre et au niveau de ce titre, je vais mettre bonjour les gens. Ensuite, je vais fermer ma boîte modal et mettre un contenu. Là, on mettra un contenu. Où ce que je peux faire pour tester que l'élément est bien reporté, c'est créer une dive qui va avoir comme ID, des mots. Après, une fois que le sereineur a été fait, je peux vérifier est-ce que j'ai bien entre les mains. Je vais créer une constante que je vais appeler des mots et je vais faire un document. Point Query, sélecteur et je vais sélectionner l'élément qui a la dit démo. Maintenant, je vais lui dire je m'attends à ce que des mots ne soient pas nulles. Si vous voulez avoir un petit peu d'auto-compression, ça peut être intéressant. Vous pouvez installer une autre dépendance qui est Aruba's Types Slash Gest. Ça va installer les effichés de déclarations de type de gestes, ce qui fait que maintenant, lorsque vous allez taper quelque chose, il va vous offrir l'auto-compression. Ça c'est super pratique, ça vous évite d'avoir tout le temps à chercher dans la documentation. Maintenant, pour que ça fonctionne, il va falloir importer Render. Là, je peux lui dire, je veux importer Render et je vais l'importer en faisant un Require. Je vais prendre Aruba's Testing Liberties Slash React. Je sauve Garde et je relance mes tests. Je vais faire un coup de NPX Gest. J'ai une petite erreur et si je regarde pourquoi j'ai cette erreur, en me dis que le support pour la syntax GSX n'est pas là. Effectivement, lorsqu'il lance les tests, il utilise notre GS et notre GS. Lui n'est pas capable de comprendre sa syntax GSX. Cet import là ne fonctionne pas du tout. Pour remédier ce problème là, il faut installer Babel qui va permettre de convertir le code en un code qui peut fonctionner sur notre GS. On va faire un Yard, Ad, Thierry D, et on va installer Babel Thierry Gest. C'est ce qui permet de faire fonctionner Babel avec Gest. On va aussi installer deux choses. C'est Babel Slash Presets Thierry N, qui va permettre de convertir le code pour un environnement de définies. Et Babel Slash Presets Thierry React, qui va permettre de rajouter le support du GSX. Je vais aller à la racine de mon projet, à l'écrer à nouveau fichier que je vais appeler Babel.config.gss. À l'intérieur, je vais préciser que je vais avoir une configuration pour Babel et je vais rajouter les deux presets que j'ai demandé d'installer. C'était Arbaz Babel Slash Presets Thierry N, et le second, c'était Babel Slash Presets Thierry React. Voilà. Comme ça, notre code va être converti et on n'aura pas de problème. Je vais relancer un coup de Npx Gest. Le code fonctionne et il me dit juste qu'il ne trouve pas React. Parce qu'effectivement ici, j'étais partie de rien, et donc je n'ai pas installé React. Ce qui est un petit peu embêtant. Et il me manque aussi React Thierry N. Comme je vous l'ai dit, on a commencé vraiment sur un projet entièrement vide. Donc il faut forcément installer les dépendances qui sont nécessaires à notre application. Si maintenant je relance Gest, on va être presque bon si ce n'est qu'il va me dire qu'il ne connaît pas React. Parce que le code de notre test va être converti avec la syntax React. Et du coup, il faut rappel à des React.co et télémetre. Donc comme on le fait de manière traditionnelle, il va falloir importer React à ce niveau-là. Donc vous pouvez utiliser cette syntaxe là où maintenant que l'on utilise Babel, on peut utiliser la syntaxe nouvelle avec le import from, voilà, que je trouve quand même beaucoup plus agréable personnellement. Donc on va juste convertir ça pour être cohérent avec le reste de notre projet avant tout. Et enfin, on importe React depuis React. Et maintenant, enfin, si je lance mon test cette fois-ci, tout va passer ouvert. J'ai ce pendant une erreur, mais c'est tout à fait normal. C'est une erreur qui a été capturée par mon système. Là, on avait le ON clause qui était nécessaire et je n'ai pas précisé de ON clause. Vu que mon test ici n'a pas pour vocation à tester cette fonction-là, je peux lui dire dans le ON clause, je vais te passer un callback qui ne fait rien. Alors maintenant, moi ce que j'aimerais bien vérifier, c'est que le titre contient de bonjour les gens, ou basiquement que bonjour les gens soit bien affichés. Alors vous avez dans la partie testing library une autre partie qui vous permet de faire des tests concernant le dom. Par exemple, vous pouvez lui dire, j'aimerais bien trouver l'élément qui y a le texte. Parce que, bas, basiquement, je m'en fiche de savoir la structure HTML de mon élément. Moi, tout ce qui m'intéresse, c'est de savoir est-ce que le texte est bien affiché. Vous avez des méthodes comme get by, find by et autre, qui ensuite vous permet de sélectionner par la belle ou par texte ou partie-tr, et ainsi de suite, ainsi de suite. Donc ça, c'est plutôt pratique pour écrire des tests qui sont plus logiques que des sélecteurs. Moi ici, je vais juste mettre bonjour et je vais utiliser ces assertions. Donc à ce niveau-là, je vais lui dire je vais créer une variable que je vais appeler Titel. Et là, j'ai envie de faire un get by texte. Pour pouvoir utiliser cette méthode get by texte, il va falloir importer screen. Donc je vais copier ça, je vais pas m'embêter ici. Je vais l'importer tout en haut et je peux maintenant lui dire sur l'écran, ça a équivoie un peu aux documents si vous voulez, j'aimerais bien trouver l'élément par texte. Et le texte que je cherche, c'est bonjour les gens. Maintenant, dans l'assertion que je teste, je m'attends à ce que le titre soit dans le document. Par exemple, vous avez des assertions que vous pouvez utiliser, qui vont être importées par testing library, et il y en a une qui est pratique, c'est to be in the document. Alors malheureusement, si je lance ce code-là, il va me dire que déjà on n'a pas importé testing library slash-dome. Donc on va commencer par installer ça. Yarn, Ad, Thierry, D, testing library slash-dome. Malgré cette installation, si je relance le test, on va me dire ici que le to be in the document n'est pas une assertion valid. Parce que si vous voulez utiliser cette assertion, il va falloir importer une dernière chose qui est à robuste testing library, slash just, Thierry-dome, et vous pouvez lui dire d'extend expect, ce qui va permettre de prendre l'objet expect et de rajouter les différentes méthodes qui sont associées. C'est ce que vous retrouvez dans la documentation de testing library ici. Donc tout ça encore une fois, c'est déjà fait et déjà importé dans le template Create React App. Donc je vais installer cette livrairie supplémentaire, donc on va faire un Yarn Ad Thierry-D, et on devrait être bon. Si je relance mon test maintenant, ça fonctionne convenablement. Il n'est plus d'erreur au niveau de GeoNCLOS. Une autre solution, si vous ne voulez pas importer ça systématiquement et peut être déclarer ses alpeurs globalement, c'est que vous pouvez créer une configuration pour geste, en faisant un geste.config.js. Dans cette configuration, vous allez faire un module.export et exportez un objet, et vous allez mettre un setup, files, after, and, donc ça permet après que l'environnement soit chargé et vous rajoutez votre setup test. Ou là, vous pouvez importer Badel-Pur pour vos assertions. Je vais aller créer ce fichier là, qui normalement est créé dans le template par des fours, et à l'intérieur de ce fichier, je vais simplement copier cet élément-là, comme ça, je n'ai plus besoin de le faire pour chaque test. Automatiquement, ces assertions vont être rajoutées. Si je relance un coup de geste, mes tests continuent à fonctionner. Alors maintenant, un second scénario. On aimerait bien vérifier que quand je vais cliquer sur le bouton de fermeture, automatiquement, la boîte modèle soit fermée. Vu que je teste mon composant de manière isolée ici, ce que je veux tester, c'est que la méthode que je passe au run-close soit bien appelée. Donc pour le coup, on va utiliser le système de moque de geste. Donc ici, je vais mettre coq, clause on-x, clique, et je vais lui dire que ça sera une fonction. À l'intérieur de cette fonction, je vais clérer mon moque pour la fonction clause. Donc on va l'appeler moque clause, et ça sera une fonction de geste. L'avantage de ce tout-il-là, c'est qu'on peut faire un moque clause, point moque, point calls, et regarder le nombre d'appels qui a été fait. Pour vérifier, est-ce qu'il y a bien eu un appel, suite à la clique sur le bouton de fermeture ? Je vais reprendre le render que j'écris plus haut. Donc le titre on s'en fiche complètement, et par contre dans le run-close, je vais lui passer ma fonction. Ici, moque clause. Une fois que cette élément a été rendue, il va me falloir obtenir le bouton de fermeture. Donc d'où ici, dans un premier temps, on va lui dire pour trouver le bouton de fermeture, on va faire un document, point body, point queer et sélecteur, et on va trouver l'élément qui a comme la belle. Donc ça sera aria tirer la belle fermée. Maintenant, j'ai besoin de cliquer sur cet élément-là. Donc on l'avait vu au niveau de notre import ici, en même temps que Render, on a aussi Fire Event, qui permet de lancer un événement. Moi ce que je vais faire ici, c'est que je vais lui dire, je vais lancer un événement, et vous pouvez lui dire sur quel élément vous lancez l'événement et quel type d'événement vous lancez. Vous avez une petite aide, et vous pouvez utiliser directement, clique ici. Là, vous lui dites, je veux que tu cliques sur le bouton close, tout simplement. Vous voyez, c'est très simple de décrire des comportements. Maintenant, qu'est-ce que je m'attends à obtenir comme résultat, je m'attends à ce que la taille du nombre d'appels à mon close soit égal à un. Donc il faut que ça soit appelé au moins une fois. Et là, j'ai oublié de fermer le crochet. Si je relance mon test, on va voir qu'il va me dire ici, je m'attendais à obtenir quelque chose et ça n'a pas été le cas. Donc ça veut dire que au niveau de ma boîte modale, il y a effectivement une erreur et je n'ai pas appelé le on close lorsque l'on cliquait sur ce bouton-là. Donc là, je vais corriger le code de mon composant et je veux dire lorsque tu cliques sur ce bouton-là, je veux que tu appelles la méthode on close. Je relance mes tests et automatiquement, ça va fonctionner. Vous avez aussi la possibilité de rajouter au niveau de votre commande de geste, un tir et tirer watch. Automaticement, ça va mettre en observation les différents fichiers et ça va vous permettre de relancer vos tests. Si vous n'utilisez pas guide comme c'est le cas ici, il va vous dire attention, vous ne pouvez pas utiliser ça et faudra faire plutôt un watch hole à la place. Et là, il a relancé les tests et si je change une valeur, par exemple ici, hop, et que je s'affigue, il va relancer les tests systématiquement. Donc ça, c'est pratique pendant la phase de développement. Maintenant, je me dis, j'aimerais bien rajouter une fonctionnité supplémentaire que je n'avais pas forcément prévu dans cette formation. C'est le fait que quand j'appuie sur réchab, automatiquement la boîte modèle se fait. Donc là, ce qu'on va faire, c'est qu'on va créer un nouveau test. On, on va mettre close on escape key. Basiquement, on reprend la même logique et on va lui dire ici, je vais lancer un événement et ce sera un événement de type keydown. Et je lui préciserai sur quel élément je vais émettre cet événement. Donc moi, ça sera carrément sur le document. Et je vais lui préciser la clé que je souhaite appuyer. Donc c'est escape. Maintenant, je m'attends à ce que close soit appelé une fois. Et pour l'instant, ce n'est pas le cas. Donc au niveau de mon modèle point GX, je vais aller créer un use effect pour détecter quand est-ce que notre composant est monté et quand notre composant est monté, je vais écouter. Donc je vais faire un document point add event listener. Je vais écouter le keydown et lorsqu'on appuie sur une clé, je vais fermer. Lorsque cet effet est défaite, il faut que tu supprime l'événement. Donc là, on va retourner une fonction et cette fonction, elle fera un document point remove event listener. Elle supprimera l'événement keydown et le callback c'est un close. Il faut que ce use effect soit relancé à chaque fois que un close est changé. Donc je s'affigue, je regarde au niveau de mes tests et ça fonctionne bien. Par contre, les plus attentifs d'entre vous, ils auront, oui, mais il y a quand même un petit souci. C'est que là, t'as pas vérifié qu'on a bien appuyer sur échappe. Donc on crée un nouveau test pour bien capturer ce problème là et on met doses no-fing on-keydown. Note-bing escape. J'avoue, c'est pas très anglais ou on fait, c'est pas très français. Mais c'est juste pour tester les choses. Donc là, on va s'imaginer qu'on appuie sur la touche entrez par exemple. Et je m'attends à avoir un nombre d'appels qui est égal à 0. Si je réexécute mes tests, on va avoir 3 tests qui vont réussir, mais le dernier test qui va échouer. Donc au niveau de mon model point G6, j'ai besoin de créer un callback pour vérifier est-ce que la touche qui a été appuyée, c'est bien la touche escape. Donc on va rajouter un conste handle qui, down, ça va être une fonction qui va prendre en parmètre l'événement. Là, je vais préciser si E.Ki, c'est bien escape. Dans ce cas là, je veux que tu appelles on-key. Dans le cas contraire, je veux que tu ne fasses absolument rien. Cette fonction, on va la mémoiser parce qu'on ne veut pas la redéfinir à chaque fois et on va lui dire qu'elle dépend de on-key. Maintenant, au niveau de mon use effect, je vais utiliser plutôt ce handle qui down et c'est ce handle qui down qui s'avira de dépendance au niveau de mon use effect. Je sauf garde, je relance mes tests et là tout fonctionne convenablement. Donc vous voyez, finalement, pour tester du code react, ça va être relativement simple. On va surtout se reposer sur cette libérerie de test qui va nous permettre de simplifier un petit peu les choses. Mais on pourrait tout à fait s'en sortir sans. Il faudrait dans ce cas là, avant chaque test, monter notre élément dans le dom. Et ensuite, bien directement, faire appel à des cohéries sélecteurs ou autres pour faire nos tests. Testing librairie va nous offrir un petit peu plus de confort et un petit peu plus de simplicité dans nos tests. Alors après, si vous voulez tester d'autres choses, comme par exemple en Radio-Serve, là c'est simplement des fonctions genre ascripts classiques. Là où ça va poser un petit peu plus de problèmes, c'est lorsqu'on va vouloir tester des oucs, parce qu'il ne peut pas être appelé n'importe comment. Et on va illustrer le problème, on va s'imaginer créer un nouveau fichier, où on va créer nos différents oucs. Et on va l'appeler oeuvx.js. À l'intérieur de ce fichier, je vais aller créer mon oeuvx personnalisé et on va créer un oeuvx qui va s'appeler UseToggle. Donc je fais un export, je vais exporter la fonction qui va s'appeler UseToggle. Elle prend en paramètre la valeur initiale et un intérieur, chovêtisez un UseState et crée un état dérivé. Donc on va avoir un state, on va avoir une fonction setState et on fera un UseState et on prendra un paramètre la valeur initiale. Ensuite, ce que je retourne, ça sera l'état et une fonction qui permettra de changer la valeur. Donc vu que c'est un toggle, si c'est trou, ça passera à fold, si c'est fold, ça passera à trou. Mais, temporairement, je vais m'imaginer que j'ai créé quelque chose qui était ronnaie. C'est-à-dire que je fais un setState à trou systématiquement. Cette fonction pour qu'elle marche, il va falloir que j'importe tout un haut, notre OOK qui s'appelle donc UseState depuis réacte. Maintenant que c'est fait, j'ai envie de créer le test qui correspond. Donc je vais aller créer un nouveau fichier que je vais mettre au même niveau. Donc on va créer un nouveau fichier que l'on va appeler OOKS.test.js et un intérieur de ce fichier, je vais lui dire testToggle OOK. Pour le coup, ça va être plutôt simple, ça va être une fonction qui va faire appel à notre OOKS. Donc pour l'instant, on s'imagine simplement récupérer la valeur de Toggle et faire ensuite un OOKS. Donc plutôt, on va la playState et on va récupérer Toggle qui sera la fonction et on utilisera notre OOKS personnalisé. Et on lui donnera comme valeur initiale FOSS. Je vais juste changer la syntax en haut pour avoir la syntaxe plus récente. Parce que je préfère ça, je trouve ça plus sympa. Si j'essaye de relancer mes tests, vous allez voir que l'on va obtenir une petite erreur ou il va me dire déjà que dieuState n'est pas défini. Il est mal que j'ai oublié la majuCule, donc on ne va pas aller loin. Mais on va surtout me dire que tu n'as pas la possibilité d'appeler des OOKS en dehors du body d'un composant sous forme de fonction. Effectivement, là, je suis en train d'appeler un OOKS dans une fonction de mes tests, mais en vrai, ça n'est pas possible parce qu'il faudrait appeler ça dans un composant. Donc on pourrait créer un faux composant qui nous servirait un petit peu à structurer nos tests ou on peut se baser sur une librarie qui est aussi dans le package de testing library qui va nous permettre de créer des tests concernant les OOKS. Donc cette librarie, vous pouvez la trouver en faisant le testing library parce que l'on a déjà vu et vous cherchez React OOKS. Vous allez tomber sur ce dépôt-là, qui vous permet de lancer vos tests. Vous avez d'ailleurs un petit exemple en bas, on vous montre ici. On va créer un OOK en utilisant la fonction Render OOKS de cette outil de test. Et ensuite, quand on fait des changements, on entoure d'un acte ce qui nous permet de tester les choses et de ne pas avoir le problème que l'on vient de voir. Donc pour l'installer, il faut installer ça en tant que dépendance de développement et il vous faudra React et ReactTestelpeur. Donc pour l'instant, on va faire hop, yarn. Alors, on va déjà couper l'outil de test, on va faire un yarn à de tirerD et à robuste testing library, slash React OOKS. Donc je ne sais pas si il y a eu le message, mais globalement, normalement, ça doit pas fonctionner parce qu'on n'a pas installé cette outil d'épandance qui était ReactTestenderer. On va l'importer aussi. On va faire un yarn à de tirerD. Il vous dise dans la documentation que si vous avez React, ça suffit par expérience, moi, ça n'a pas un suffit, la fallue que j'installe ReactTestenderer. Donc là, je le fais de suite. Maintenant, tout en haut de mon test, dans mon Oux.test, je vais pouvoir importer et on va importer les deux choses depuis a robuste testing library React OOKS. On va importer Render OOK et on va importer Acte. Lorsque je utilise mon use toggle, je vais lui utiliser dans un Render OOKS. Ça sera une fonction qui retournera le résultat du OOKS. Au niveau de ce que je récupère ici, ce n'est pas simplement le retour du OOKS, c'est un objet qui va contenir plein de choses dont notamment résulte. Si vous voulez prendre un petit peu plus, vous pouvez regarder la définition de Render OOKS et voyez que ce que ça retourne c'est un Render OOKS résultat qui vous permet de faire ces différentes choses. Nous ce qui nous intéresse, c'est seulement le résultat. Donc, le résultat, c'est ce que l'on va obtiendrait normalement si on appelait l'OOKS. Donc, moi, ça contient un tableau de taille 2 avec la valeur en première clé et la fonction de ta gueule en seconde. Maintenant, je peux lui dire que je m'attends à ce que la valeur soit false. Donc là, je mettrai expect, je m'attends à ce que dans résulte.encourante 0, donc la première valeur, on est une valeur qui soit false. J'ai essayé maintenant de relancer mes tests. Je vais même laisser le watch all secouci et là, on a plus d'erreur, ça fonctionne bien. Maintenant, je vais lui dire de faire un toggle. Donc, attention, il ne faut pas directement faire un résultat 0, 1, 1 et appelé la méthode parce que ça ne fonctionnerait pas. Il vous allait dans tout cas avoir une alerte. Il faut l'utiliser dans un acte, où je lui dis, agit à ce niveau-là et fait appel à résulte 0,1. Donc, ça, ça permettra de faire notre toggle. Maintenant que notre toggle est fait, je vais regarder si la valeur que j'ai au niveau de mon système est bien passé à trou. Donc, là, on mettra expect, to be trophy. Je savent garde, hop, le test se relance et ça fonctionne bien. Je relance un toggle et je m'attends à réobtenir une valeur false. Et c'est là où effectivement la logique va échouer et qu'on détecte bien qu'il y a un problème. Donc, au niveau de mon x.js, je vais lui dire ici, il faut que tu retourne un callback qui changera la valeur de l'Etat. Et dans ce cas-là, automatiquement mon oeuvre va repasser au verre. Donc, si jamais vous avez des oucs qui sont répandus dans plusieurs composants, ça peut être intéressant de les tester de manière isolée pour éviter que le problème remonte en pleine droit. Là au moins, vous avez un problème directement au niveau des tests qui concerne ce eau-là et vous assurez qu'il fonctionne convenablement avant même de l'utiliser dans vos composants. Et là, on a fait le tour de comment tester avec React. Donc, vous le voyez au final, grâce notamment à testing library, c'est plutôt simple. Si vous utilisez le template Create React App, ces différents éléments sont déjà importés. Par contre, il ne me semble pas que la partie ou qui est importée et il vous faudra le faire dans tous les cas. Mais voilà, pour cette partie-là. Donc, n'hésitez pas maintenant à tester le code lorsque vous écrivez des composants React. Ça vous permettra de détecter les erreurs un à moi.