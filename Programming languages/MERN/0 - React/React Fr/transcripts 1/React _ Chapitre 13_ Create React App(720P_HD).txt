 A bienvenue dans ce nouveau chapitre où je propose de continuer notre exploration des outils liés à réactes, on va découvrir aujourd'hui Cui-Aitre React App. Pour travailler avec réactes, ce que l'on a fait jusqu'à maintenant, c'est que tout simplement dans notre HTML, on a chargé réactes en mode développement, on a chargé réacte d'hommes, et ensuite on a chargé Bavel pour pouvoir travailler avec le GSX. Donc ça c'est très sympa pour voir tester réactes et expérimenter un petit peu avec, mais ce n'est pas du tout ce que l'on utilisera en production. En production, ce que l'on va faire, c'est qu'on va utiliser des bonnes lurs qui vont permettre de morceler notre javasquerie tant de plusieurs fichiers et qui nous permettront ensuite, lorsque l'on passera en production, de ne générer qu'un seul fichier. Donc le problème, c'est que la configuration de ces bonnes lurs peut être un petit peu compliqué, encore plus avec réactes et Bavel. Pour simplifier les choses, Facebook propose un template que l'on va pouvoir utiliser pour commencer rapidement. Alors ce template pourrait être utilisé, il a besoin de notre GS. Donc je ne reviendrai pas forcément dessus dans cette formation, mais si vous n'avez jamais utilisé notre GS, je vous invite à regarder les premiers chapitres de cette formation au moins découvrir ce que notre GS est comment l'installer sur votre système. Donc moi ici, si je tape la commande de node tirer tirer version, j'ai la version 12, mais ça fonctionne avec n'importe quelle version qui est plus récente. Donc vous l'installer si ce n'est pas déjà fait. Donc pour travailler avec ce template-là, il suffit de taper la commande npx, create react app, suivi du nom de votre application. Attention, le nom de votre application doit être en minuscule, c'est par rapport à des tirer, pas de majuscule ou de camel case par exemple. Donc moi au niveau de mon terminage, j'ai fait un coup de npx, create react app, et je vais lui dire que je vais créer une application qui va s'appeler tuto tirer react. Automaticement, il va télécharger les différentes dépendances et installer quatre choses. React, ReactDom, donc ça c'est les choses que l'on a déjà vu. ReactScript qui sont des scripts qui vont permettre de démarrer un savoir de développement ou de construire votre projet, et ses scripts utilisent cérat template qui est le template, create react app. Au-delà de ça, il va installer tout un tas d'autres dépendances que vous allez voir défiler, qui permettent de compiler, de tester le code, de l'inté, de vérifier que vous n'avez pas fait des heures, plein plein plein de choses. Donc une fois que c'est fait, on va vous donner quelques instructions. Donc on vous dit que globalement, vous avez quatre commandes, YarnStart qui permet de démarrer un serveur de développement, YarnBuild pour construire vos fichiers que vous avez ensuite pouvoir envoyer en ligne, YarnTest pour lancer les tests, sans m'en parler à beaucoup plus tard dans cette formation, et YarnEject qui va retirer, créer ReactApp et vous donner directement la configuration. Donc nous on va se rendre dans le dossier qui est écrit, donc c'est le dossier tuto tirer react et je vais démarrer ça avec Visual Studio Code pour qu'on puisse voir de quoi il en retour. Donc par défaut, la structure est relativement simple. On a un dossier public qui va contenir l'effichier static, donc ce sont des fichiers qui ne vont pas être génirés par le serveur. Ensuite, on a SRC qui sont menées au source, donc on rentrera par le fichier index.js et après, à la racine, on a le fichier package.son, qui contient les différents scripts que l'on a évoqué précédemment. Donc vous le voyez, si vous regardez ce fichier package.son, il est très très simple parce que une grande partie de la complexité est cachée derrière ReactScri. Si maintenant on regarde la partie SRC, on va voir que le fonctionnement est différent sur les clônes à vue jusqu'à maintenant. Dans ce qu'il travaille avec React, ils importent React depuis le dossier node module, en faisant un ligne porte React, frambriate. Donc ça, c'est quelque chose qui est possible de faire grâce à l'utilisation de Wattback derrière. Par ailleurs, ils utilisent ReactDom. On a aussi la possibilité d'emporter du CSS et aussi d'importer d'autres fichiers qui sont au même niveau. Ensuite, il fait un ReactDom.randeur, donc c'est la même chose que ce que l'on avait vu dans les autres chapitres et à l'intérieur, on a un petit peu JSX avec le strict mode. Ça, on n'en a pas parlé, mais c'est simplement un composant qui va automatiquement vous afficher des alertes aussi, vous utilisez des fonctions qui sont dépressiées ou si vous avez des problèmes à des effets de bord. Donc c'est une sorte de mode debug qui vous donne un peu plus d'infos. Et à l'intérieur, on a un autre app qui est donc un autre composant. Donc plutôt que d'avoir tous les composants dans le sol et même fichiers, ce que va nous permettre de faire ce template-là, c'est de pouvoir morceler un plusieurs fichiers. Et ça, c'est très intéressant pour avoir une meilleure organisation. Au niveau du fichier app.js, pas grand chose de particulier à dire, on voit que c'est du JSX et c'est simplement une fonction. Donc là, il utilise un composant sauf forme de fonction qu'il exporte et qu'il peut donc ensuite être importé et utilisé ailleurs. Si je veux voir à quoi ça ressemble, il me suffit d'ouvrir interminale et je vais faire un coup de garde-start. Automatiquement, cette commande va démarrer un serveur de développement sur le port 3000. Si je fais localiste de 0,3 000, tard des fois ça devrait ouvrir automatiquement, on voit bien notre petit logo et ça démarrera. Ce qui est intéressant avec ce système-là, c'est que si vous modifiez un nouveau composant, automatiquement, il va réactuiser la page sans que vous ayez besoin d'un rien faire. Et ça, c'est plutôt intéressant. Alors maintenant, imaginons que à la place de ce petit logo, dans notre app, on est en vie de créer leur loge. Donc je vais aller créer un nouveau fichier pour séparer les choses. Donc je vais créer un nouveau fichier que je vais appeler clock.gs. Vous pouvez utiliser l'extension Gs, mais si vous mettez l'extension Gs, ça permettra à votre éditeur de tout de suite comprendre que vous travaillez avec réacte. Et ça permet aussi à des bundleurs de comprendre que dedans, vous avez du Gs.x et du coup, il faudra faire des conversions. Nous ce que l'on faisait, c'est qu'on crée une classe que l'on appelait clock et qui extends de réacte.component. Alors maintenant que vous vous utilisez un webpack, vous pouvez importer les éléments dont vous avez besoin. Donc vous pouvez faire un importe et je veux importer la partie componnente depuis réacte comme ceci. Et ça vous permet ensuite d'avoir un petit peu plus de clarté et de mieux morceller votre code. D' dedans, on va avoir une fonction Render qui retournera une simple dive qui contiendra l'intérieur la date. Pour avoir la date, dans le constructeur, on va prendre les propriétés et tout de suite, enfin, super de props. Je vais définir au niveau de mon state que j'ai la date et par défaut, c'est une nouvelle date. Ensuite ici, je peux afficher ma date que je vais formater en faisant un vis.state.dat, point2 local string. Voilà, c'est juste pour l'exemple. Donc ce composant, si on souhaite l'utiliser ailleurs, il faudra tout simplement exporter les choses. Donc soit vous pouvez mettre un export, si vous voulez un composant nommé, soit export des fold. Moi, je vous rétendons ça vous conseillait d'utiliser export par défaut parce que si demain vous avez peut-être besoin d'exporter d'autres composants depuis ce fichilla, ça peut être utile. Donc moi, j'ai tendance aujourd'hui à utiliser de moins à moins le export des fold. Et ça permet aussi d'avoir du trick checking, donc c'est intéressant. Donc à ce niveau-là, je vais pouvoir importer clock et je vais l'importer depuis le fichier clock.gs. Vous pouvez omettre l'extension, une cherche automatiquement des fichiers qui finissent par gs ou gs. Un intérieur de mon composant app, je vais simplement mettre ici mon composant clock et je vais plutôt fermer. Si je sauve garde, je vais avoir une petite erreur en console. En me dis, fail to combine et c'est erreur à l'appareil aussi au niveau de notre page. Ça, c'est intéressant. On nous dit React must be in scope.using gs.x. Donc cet erreur allait tout simplement dû au fait que ici, la belle va convertir comme on a vu par des appels à React.c.e.t.e. Or dans ce fichier, on a aucune... Aucurance de React du coup, bah y a un erreur et c'est ce que nous dit cet erreur en console. Donc dès que vous utilisez du gs.x, il faudra importer React en haut, même si vous ne l'utilisez pas de manière évidente parce que ça sera utilisé dans la version compilée. Et je vois bien alors que j'ai ma date qui s'affiche convenablement. J'ai en revanche une petite erreur en console. Je l'ai aussi dans la console de mon navigateur. Qui me dit attention, tu utilises le logo à ce niveau-là, tu le définies, mais tu ne l'utilise jamais. Donc ça, c'est le s-line, c'est fondé automatiquement par ce template-là. Il vérifie que votre code est valid et vérifique. On n'est pas fait de petites erreurs au niveau de votre formatage mais aussi au niveau de l'utilisation. Et là, basiquement, il nous dit qu'on a déclaré une variable qu'on n'utilise jamais, donc c'est un peu bête et mieux voudrait ne pas la définir du tout. Et si je corrige pas le problème-là, je vois que ça marche bien. Donc voilà globalement, comment fonctionne ce template-là ? Je vais juste rajouter un component d'idement pour lancer notre timer et faire un sorte que notre relog avance. Et vous voyez que dès que j'ai tapé component d'idement, il y a une sorte d'auto-completion. Vu qu'on utilise le système d'import et que ici on importe Riat, notre éditeur est capable d'analyser le code et c'est que dans les composants de type component, on a ces méthodes-là. Il n'aura pas de réunion pour nous dire que c'est une méthode qui n'est pas obligé de la définir. Si j'ai créé Render, on voit que Render n'a pas de coin d'interrogation parce que cette méthode est nécessaire au bon fonctionnement d'un composant. Voilà pourquoi vous voyez ces coin d'interrogation. Donc on va lui dire lorsque le composant est monté, je vais démarrer un timer en faisant vice point-timer, égal Windows.setInterval et on va lui dire que toutes les secondes on va lancer une fonction et cette fonction fera un vice point-set state et changeera la date. Donc je mettrai date de point U. Puis que je fais ici appel à vice, il faut plutôt que je utilise une fonction fléchée ou que je fasse un bind-vice. Je vais utiliser la fonction fléchée, c'est plus rapide. Lorsque je démonte mon composant, je vais être component Will and Mont. Mais je vais lui dire de faire un Windows pour un clear interval et je vais supprimer l'interval vice point-timer. Cette intervalle, je vais le définir dès le début pour pas avoir de problème en disant que vice point-timer est égal. Un piqueable. Donc je réactualise, enfin je sauvegarde et automatiquement je vois que ça recharge les choses. Il me souligne ça en jaune parce que j'avais activé dans la partie profiler la mise en surveillance des éléments qui sont mis à jour. Je vais le coucher ça, c'est plutôt ici, au général. Voilà. Hop. Je trouve ça un petit peu déstabilisant. Le gros avantage de ce template là, c'est que en plus vous avez la possibilité de faire du CSS dynamiquement. Donc vous pouvez lui dire là, j'aimerais bien porter un Fichy CSS qui sera spécifique à ce composant-là. Et ensuite vous créez à nouveau Fichy et que vous appelez clock.sss et vous pouvez mettre votre style. Vous trajus de penser à rajouter une classe particulière. Là je vais rajouter la classe et on voit encore une fois qu'on avait l'auto-completion. Je la pennerai clock et je lui dirais maintenant que dans ce CSS j'aimerais bien avoir un background color red et peut-être une couleur blanche. Ce qui est super intéressant avec ce système-là, c'est que vous avez du hot-reelode au niveau du CSS. Par exemple, si vous avez fait des modifications, alors je n'ai pas les faire au niveau de mon composant vu qu'il est re-rendu tout le temps, mais ici. Si jamais je change le CSS, on voit que la totalité de la page n'est pas rechargée. Donc vous pouvez faire des échangesment à chaud de votre CSS et voir les choses sans forcément devoir réactuiser tout. Et ça c'est plutôt cool. Alors maintenant on a bien travaillé avec ce j'avais scrépté, et on se dit, j'aimerais bien exporter les choses. Vous avez une autre commande qui est la commande YarnBuild. Donc cette commande, ce qu'elle va faire, ce qu'elle va générer, l'efficier statique. Vous allez avoir un dossier build qui va contenir les différents fichiers qui étaient dans le public avec quelques fichiers supplémentaires, et vous avez la partie statique qui va contenir votre CSS et votre JavaScript. Si je regarde l'index.html, c'est un index.html qui a été minifié avec aucun espace et il a mis le chemin vers le notre GS et tout est fait. Donc il nous reste plus qu'à déployer ça sur un serveur et ça fonctionnerait. Ensuite, vous avez une autre commande qui est la commande de test. Donc on fait un Yarn test et ça va permettre de lancer les tests. Comme je vous l'ai dit, on reparlera de cet aspect-là plus tard dans cette formation. Ça permet de tester les composants de manière isolée et de faire du test unitère. Donc je vais quitter ça en faisant un contrôle C. On va parler de la dernière commande. La commande Eject. Donc la commande Eject permet de supprimer en fait ce template que l'on utilise et d'exporter directement la configuration. En effet, si on regarde au niveau de notre package.son, notre différents scripts start build test et Eject, qui sont basés sur React Script, ce qui fait que finalement on a assez peu de dépendance. Mais si votre projet grandit et si vous avez des besoins bien particuliers, vous pourriez être gêné et vous pourriez avoir besoin de manipuler un petit peu plus en profondeur la configuration. Donc dans ce cas-là, il va falloir Ejecter les choses. Alors par contre, si vous faites un Yarn Eject, on vous affichera une petite alerte. Il vous vous dit oui, oui, je suis sûre de jamais vouloir revenir en arrière et on vous dirait attention. Il faut d'abord commis tout échangement. On va le faire tant que tu n'as pas comite. Donc là, on va faire un petit commis de juste pour... Par qui nous embête, voilà. Oui, je vais toujours mettre tout en mémoire et maintenant je refais une éjection. Je choisis de mettre oui et on voit qu'il va faire beaucoup beaucoup de choses. On voit que la structure de notre projet change. On voit d'ailleurs qu'il y a plein de qui sont nouveaux qui ont été mis un place et qui sont maintenant versionnables. Et si je revienne dans mon architecture, on voit qu'on a maintenant son dossier config qui va contenir le ensemble de notre configuration. On a notre dossier script qui va contenir les scripts qui correspondaient aux différents scripts que l'on avait vu. Build pour construire notre projet, start pour démarrer le serveur de défopement et test pour lancer les tests. Comme vous le voyez, la configuration est plutôt épaisse. Et c'est pour ça que ça peut être intéressant de ne pas éjecter tout de suite. Par contre, effectivement, si vous avez des besoins spécifiques, vous pouvez éjecter et ensuite ça vous permet de mettre les mains dans le code et de pouvoir changer la configuration, en fonction de vos besoins. En modifiant, par exemple, la configuration de WorldPack, la configuration des différents l'odeurs, tout ça, tout ça. Mais c'est vrai que par défaut, ce qui est intéressant avec create react app, c'est qu'on n'a pas forcément besoin de se soucier de cette configuration. On peut travailler sur notre petite application react sans se poser de question. Et plus tard, si on le souhaite, on éjecte comme ça. On n'est pas bloqué et lié à create react app et on peut continuer une autre configuration, soit même. Mais très important, une fois que vous avez éjecté votre application, il n'est pas possible de revenir à l'arrière. Maintenant, notre configuration est éclatée comme ça et on ne peut plus utiliser create react app sans devoir faire pas mal de modifications. Donc voilà, pour la petite découverte de cette outil. Donc si vous ne vous sentez pas à l'aise encore avec zet outil, ce n'est pas grave. Vous pouvez continuer malgré tout à suivre les nouvelles prochains chapitres avec l'ancienne méthode. Voilà, sachez que de manière générale, on aura tendance à utiliser wadpack ou un bon de l'heure lorsqu'on se veut travailler avec réacte.