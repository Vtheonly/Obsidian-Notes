 A bienvenue dans ce nouveau chapitre, je vous propose de découvrir de nouveaux ouquins ensemble le OUK, Yus, Mémo et Yuskolbach. C'est de ouf, vous permettrez d'optimiser et d'améliorer les performances de votre application en mémoïsant les valeurs de retour de certaines fonctions et en invitant de refaire un traitement systématique au niveau de chaque rendu. Pour vous illustrer le problème, j'ai créé ici un petit composant qui contient deux champs, un champ qui permettrait de rentrer son nom et un champ qui permet de rentrer un nom. Le problème, c'est que j'aimerais bien afficher sur ce même composant une valeur qui est une sorte d'encodage de nom. Par défaut, on pourrait se dire, il me suffit simplement de faire un conste, je crée une nouvelle variable encodée et je vais encoder mon nombre. C'est ce que j'ai au niveau de mon état. Ensuite, je peux la fichier au niveau de mon composant, en mettant ici encodéde et je mettrai la valeur qui a été encodée. Le problème, c'est que malheureusement, ma fonction d'encodage elle est relativement lente et elle met environ une seconde à générer les choses. Donc si je change le chiffre, on voit que lorsque je vais taper, il va y avoir une seconde de délais avant que le chiffre s'affiche. Ce qui est un petit peu dommage, c'est que si je me mets à changer le prénom, j'ai ce délais aussi. Alors qu'on pourrait se dire, bah ces dommages de refaire systématiquement ce calcul d'encodage est endonné que finalement le nombre n'a pas changé. Et c'est pour ce genre de situation que le haut que l'uuse mémo va être intéressant. Il s'utilise de la manière suivante. Vous faites un uuse mémo et vous l'importez en haut depuis réacte où vous utilisez réacte point uuse mémo si vous avez réacte de disponible au niveau global. L'uuse mémo va prendre en premier paramètre une fonction qui va permettre de retourner la valeur. Donc nous, dans notre cas, on mettra ici une fonction qui renverait la valeur encodée comme ceci. En ce qu'on paramètre, ça va prendre un tableau de dépendance. C'est un petit peu le même principe que le uuse effecte l'on a vu précédemment. Donc moi ici, ma fonction est à la besoin du nombre. Donc je lui dirais dès que le nombre change, il va falloir que tu réexecute la fonction pour avoir la nouvelle valeur. Uuse mémo va ensuite nous retourner le résultat de cette fonction. Donc nous ici, on s'abgarderait encodide qui serait le retour du uuse mémo. En fait, ce qui va se passer, c'est que la première fois que mon composant va être rendu, il va exécuter tout ce code-là. Il va arriver dans le uuse mémo et dire, ah ben je n'ai pas encore mémorisé le retour de cette fonction. Donc je l'exécute et je sauvegarde la valeur. Au rendu suivant, il dirait à, est-ce que le nombre a changé ? Si le nombre n'a pas changé, il va dire que j'ai déjà mémorisé la valeur qui correspond à ce traitement-là et je n'ai pas besoin de réexécuter le code, ce qui permettra d'avoir des rendus successifs, qui vont être beaucoup plus rapides. Si je réactualise la page maintenant, si je change mon prénom, on voit qu'il n'y a pas de délais. Le délais n'a lieu que si je change le nombre parce qu'il y a effectivement un changement et qu'il doit réexécuter ce code-là. Donc ça, c'est le premier cas d'utilisation du uuse mémo, mais ça peut aussi être utilisé dans le cadre des composants de pur. Alors, ce que je vous propose, c'est de refaire un exemple de zéro comme ça vous pourrez le suivre avec moi. Et on va s'imaginer à avoir un nouveau composant de pur qui est un simple bouton. Donc je vais créer une constante que je suis appelée «Button », et pour créer un composant pur sous forme de fonction, fin réacte point mémo. Vous voyez au passage que mémo, c'est un mot qui répétit, ici mémo fait référence à un composant pur, mais c'est le même principe que le uuse mémo. En fait, on va mémoiser une valeur pour ne pas avoir à faire le traitement systématiquement. Donc cette fonction va prendre en parmi des propriétés, et ensuite, on va retourner notre bouton. Donc je retourne ici un bouton avec marqué mon bouton. Je n'aurai pas d'enfants, je m'en fiche, c'est juste pour l'exemple. Et je vais mettre un console point logo ici pour pouvoir compter le nombre de rendus. Ensuite, au niveau des props, moi il y a qu'une seule propriété qui m'intéresse, donc je vais utiliser la destructuration et je vais utiliser la propriété « OnClick ». Et je vais passer ce « OnClick » au niveau de ce bouton. Maintenant, au niveau de mon application, je vais m'imaginer utiliser ce bouton. Donc je vais simplement créer un petit peu de virtual d'homme, on va mettre une dive et un intérieur notre bouton. Lorsque l'on clique sur ce bouton, on va vouloir faire un traitement particulier. Donc je vais simplement à ce niveau-là faire une fonction endalclique, et quand cette fonction sera appelée, elle fera un petit alerte. Rien de bien compliqué à ce niveau. A l'airte, bonjour. Histoire de déclencher des rendus consecuses. Je vais simplement créer un petit état que je vais appeler « COUNTS » et « 7 COUNTS » et je ferai un « Use a State » et je vais donner comme valeur 0. Après notre bouton ici, je vais créer un bouton qui va pas mettre d'incrémenter la valeur. Donc l'idée, c'est simplement de déclencher des rendus consecuses. Et on va lui dire, lorsque tu clique, je veux que tu lance une fonction. Et cette fonction, elle fera un « 7 COUNTS » et elle prendra la valeur précédente et elle fera un « C plus » – l'incrémenteur. Comme ça, j'ai un bouton qui permet de redéclencher des rendus. Au niveau de ce bouton-là, je lui dirais, lorsque tu clique, j'aimerais bien que tu fasse mon alerte bonjour. Donc tu appelles la méthode endalclique. Je vais redémarrer complètement mon navigateur et on voit qu'effectivement, on a un premier rendu. Maintenant, si je vous demande, est-ce que selon vous, il va y avoir des rendus consecuses et que l'on va cliquer sur « Incrementer » ? La réponse devrait être « Non » parce qu'on pourrait se dire « Effectivement ce composant de bouton » – là, qui est pure. Lui, on lui envoie toujours la même fonction, celle qui fait un alerte bonjour. Donc il n'y a pas de raison qu'il refaite des rendus systématiquement. Pourtant, si je clique sur « Incrementer », on voit que à chaque fois que j'incrémente, c'est-à-dire que le composant « App est rendu », mon composant « bouton » est rendu, ce qui peut sembler un petit peu contre productif. Alors ça, ça a lieu parce que, en fait, à chaque fois que « App est rendu », il va créer cette constante à nouveau. Et cette constante sera une nouvelle fonction, certes la logique de la fonction est la même, mais la fonction n'a pas changé. Du coup, lorsque le bouton ici reçoit le nouveau « Endleur » et dit « Bah non, c'est pas la même fonction ». Certes, c'est le même contenu, mais pour lui, ce n'est pas le même objet, ce n'est pas la même fonction. Et du coup, il dit « Ah, bah dans ce cas-là, je dois faire un rendu ». Donc, l'inconvignant de définir les callbacks de cette manière-là ou même de cette manière-là, en recoursi, c'est que finalement si en dessous vous avez un composant pur qui réagit, il va être rendu, parce que pour lui, une des propriétés a changé, et ça, c'est pas idéal. Donc, « Use Mémo » va permettre de remédier aussi à ce problème-là. Donc plutôt que de déclarer ma fonction simplement comme ça, je peux lui dire ici « Je fais un « Use Mémo ». Je ne te passe pas en paramètre une fonction qui va donc expliquer le retour, et le retour, ça va être la fonction qui va être le « Endleur ». Maintenant, en seconde paramètre, je ne te passe les dépendances, donc cette fonction n'a besoin d'aucune dépendance, vu qu'elle a l'air de bonjour et elle ne dépend de rien depuis l'extérieur, donc je lui passe un tableau vide, et comme ça, j'écrère ma valeur « Mémoïsée ». Si je réactueis ma page, je vois que j'ai un rendu initialement, et lorsque j'incremente la valeur, rien ne change parce qu'il va détecter que à ce niveau-là, lors des précédents rendus, il a déjà créé ce callback là, et du coup, il récupère la même instance, et notre composante bouton, n'a jamais besoin d'être au revoir rendu. Et si vous voulez vous assurer que votre compteur fonctionne bien, vous pourriez mettre ici votre compteur. Mais vraiment, c'est ça qu'il est important de bien comprendre. « Use Mémo » vous permet de mémoire une valeur pour éviter de faire des traitements particuliers, ou aussi pour éviter de regenerer un nouvel objet à chaque rendu consecutif. Je vous ai parlé du « Use Mémo » mais quand je vous ai présenté le début de cette vidéo, je vous ai parlé d'un autre « OUK » qui s'appelle « The Use Callback ». « The Use Callback » est tout simplement un raccourci vers ce type de « Cala ». En fait, c'est un petit peu dommage de dire « J'ai une fonction qui retourne une fonction ». Quand on relise, c'est un petit peu compliqué. Vous avez un autre « OUK » qui s'appelle « Use Callback ». Vous allez lui passer un premier paramètre le « Callback », donc vous pouvez directement faire ça. Et ensuite, vous allez lui passer un second paramètre les valeurs de dépendance. C'est la même chose que ce que j'ai écrit précédemment, si ce n'est que la syntaxe est un petit peu plus courte parce que vous n'avez pas de fonction de fonction. « Fidre actualisme à page », « Incrementer fonction de toujours bien », on voit toujours qu'il n'y a qu'un seul rendu et mon bouton fonctionne avec la lerte. Donc lorsque vous allez avoir besoin d'utiliser des callback pour faire remonter de l'information, par exemple, il est conseillé d'utiliser le « Use Callback » afin d'éviter justement les rendus conseqtifs au niveau des enfants qui pourraient interpréter le changement de callback comme une nouvelle propriété. Alors que ce n'est pas le cas. Si votre callback dépend de quelque chose, par exemple ici, je pourrais me dire, « Bah tiens, j'aimerais bien après afficher le nombre ». « Contre comme ça », dans ce cas-là, il faudra penser à mettre la valeur comme une dépendance. Pour lui dire, effectivement, si la valeur de compte a changé, il faut que tu redéfinistes cette fonction. Si vous ne faites pas ça, ce qui va se passer, c'est qu'il va garder la première version de la fonction qui alerte « Bonjour 0 ». Lorsque j'incremente le nombre, lorsque je reclique sur mon bouton, il me redira toujours « Bonjour 0 ». Parce que la valeur qui la garde à un mémoire, c'est la valeur du premier rendu. Et ça, ça pose un problème. Donc dans ce cadre-là, il faudra utiliser « COUNTE ». Et ça vous évitera comme ça ces problèmes-là. Donc le problème, effectivement, c'est que ça redécline des compteurs, vu que le honder change systématiquement, c'est logique. Mais si vous aviez d'autres champs ou d'autres éléments qui ferait re rendre le composant, ça a évitré d'avoir un honder qui change systématiquement. Donc voilà pour ces outils-là. Use Memeau permet de mémoriser une valeur et Use Callback permet de générer un callback qui va être mémoisé. C'est simplement un raccourci et derrière, c'est le même fonctionnement que Use Memeau.