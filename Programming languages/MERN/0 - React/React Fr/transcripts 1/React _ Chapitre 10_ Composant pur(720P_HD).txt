 A bien plus dans ce nouveau chapitre qui est selon moi un des chapitres les plus importants de cette formation, donc soyez vraiment vigilant et ne survolait pas ce chapitre là parce qu'il vous permettra de comprendre beaucoup de choses sur le fonctionnement de React. Dans ce chapitre, on va parler de limitabilité, des composants pur et de comment réacte fonctionnent au niveau des rendeurs. Petit rappel, même si on l'a déjà évoqué, à chaque fois que l'on fait un set state, ce que fait réacte, c'est qu'il redéclange un rendu. Donc il va réappeler les fonctions dans le cadre de composants sous forme de fonction ou dans le cadre de composants sous forme de classe, il va réappeler la fonction au rendeur. Cette fonction au rendeur va créer un arbre avec la fonction qui est élément de React et ensuite réacte d'homme pour acomparaire à la version précédente pour savoir quel changement il doit effectuer. Donc de manière générale, ces opérations se font très rapidement et ça fonctionne de manière plutôt transparente pour le titateur. Le problème c'est que parfois dans la partie rendeur, vous allez avoir un brain logique qui peut coûter un peu en termes de performance et ça peut donner un retour très mauvais au niveau de l'utilisateur. Alors pour illustrer le problème, on va reprendre le exercice qu'on a fait précédemment, donc le listing de produits et on va introduire un petit délai au niveau du rendu. Donc j'ai créé au niveau de mon index.html cette petite fonction qui permet de bloquer et d'attendre pendant un petit moment. Je n'ai pas agisé de timbre volontairement, l'idée c'est de bloquer le script pendant une petite durée. Donc au niveau de mon app.js, dans la partie producte.ru, ce qu'on s'imagine, c'est que peut-être pour récupérer un extrait du contenu de la fiche produit ou je ne sais quoi d'autre, ça met un petit moment. Par exemple, on convertit de markdown dans un HTML et le parceur est pas très efficace. Pour simuler les choses ici, on va mettre un weight de 500 ms. Donc si je sauvegard, on voit que la première fois, ça met un petit temps à être rendu, mais c'est tout à fait normal. Parce que, il y a aussi produit et du coup, c'est 600 fois 5, ça fait 3 secondes. Maintenant dès que je tape des choses, vous allez voir que même si je suis pas entrain de taper sur mon clavier, les choses continuent à apparaître avec du délai. Donc il y a, globalement, une à 3 secondes entre chaque affichage de lettre. Et ça donne un ressenti qui est pas forcément terrible à l'utilisateur. Pourquoi en a ce délai là ? Tout simplement parce que à chaque fois que l'on tape quelque chose, search bar va appeler la méthode onfiltertextchange sur le par an et le par an va faire un vis set state. On vu que j'ai un set state ici, la fonction render va être réappelée et pour render, il a besoin de rendre search bar, ça se fait quasiment instantalément, et il a besoin de rendre au producte table. Pour rendre au producte table, il va devoir rendre chaque sous composant et ses sous composants font mettre chacun 500 ms. Et c'est pour ça que ça bloque un petit peu le système. On peut se dire, c'est un petit peu dommage parce que finalement entre le moment où j'ai tapé quelque chose ou le moment où j'ai coché cette case-là, par exemple la ligne football ou baseball, elle ne change pas nécessairement. Donc c'est un petit peu dommage de faire autant de render. Et on peut s'assurer de ce nombre de render en mettant ici un console point log, render. On va le voir. Au premier affichage, on a 6 fois render qui est appelé. Si je coche cette case-là, on va avoir quatre fois render qui est appelé en plus, nous disons aux totales, parce qu'on a quatre composants. Si je redécache, on va avoir 16 render. Et comme on peut le penser, c'est un petit peu dommage parce que les lignes, elle ne change pas en fait à trop chaque chose, entre chaque filtre. Même si on a changé le filtre, finalement, l'ignure produit ne dépend que du produit. Donc dans ce cas-là, on peut utiliser ce qu'on appelle des pures componnettes. Un composant de pur, c'est un composant qui ne sera rendu que si son état ou ses propriétés changent. Si un des deux éléments changent, vous même les deux, maintenant ce cas-là, il appelle la render. Si les éléments ne changent pas, dans ce cas-là, il ne rappelle pas les choses. Alors, vous pouvez utiliser des pures componnettes de deux manières. Si vous avez un composant, ce forme de classe, il suffit ici de rajouter un extend de réacte.puure componnette. Et si votre composant est sous forme de fonction, vous pouvez le redéfinir en utilisant la fonction réacte.mémo. Donc je peux ici créer une constante qui va s'appeler ProductO. Ça va rentrer un collision, donc on s'en va le renommer Componnette. Et je vais lui dire de faire un réacte.mémo et je vais lui passer un paramètre, ma fonction product. Rho Componnette. Voilà, ce sont les deux manières de créer un composant pur. Je vais laisser dans mon composant ici le console point-log de render pour que vous puissiez voir la différence. Si je réactualise, j'ai bien 6 rendues à l'état initial et lorsque je coche cette case-là, on voit qu'il n'y a pas de rendue supplémentaire. Tout simplement, il a détecté que c'est lignolat, on les avait déjà rendu à l'état peu précédente, donc ce n'est pas utile de re rendre les choses, vu que le paramètre qu'il reçoive product n'a pas changé. Si je décoche, on va voir deux rendues supplémentaires parce qu'il y a deux nouveaux éléments qui ont été rajoutés, donc là il a besoin de les rendre. Mais on voit déjà qu'on optimise bien les performances à ce niveau-là, parce qu'à chaque fois qu'on va avoir un élément, il ne va pas être obligé de rappeler le render. Alors on peut se dire finalement, est-ce que je ne devrait pas rendre tous mes composants sous forme de pur Componnette, ça me permettrait d'optimiser les performances de manière générale ? Alors pas forcément, premièrement il faut savoir que lorsque vous utilisez un pur Componnette, vous allez demander à réacte sous certaines conditions de ne pas rendre les choses. Et parfois, vous pourriez avoir des bugs avec des rendus que vous attendriez, qui ne se font pas. Et on va voir quelques exemples de problèmes juste après. L'autre chose, c'est que maintenant, à chaque fois qu'il doit rendre ce composant, il doit faire une comparaison. Donc si vous avez beaucoup de propriétés et beaucoup d'état, cette comparaison peut avoir un coup. Et si on prend l'exemple d'un petit bouton par exemple, c'est pas forcément utile d'aller faire des comparaisons en permanence. On rentre le bouton et ce n'est pas grave. Donc on réservera l'utilisation de composants de pur, vraiment pour des éléments qui sont importants, qui ont peut-être une logique complexe et pour lequel on sait les conditions de render. Alors ça nous amène justement à la seconde problématique, qui est la notion de dimutabilité. Donc lorsque l'on va travailler avec des composants de pur, il faudra bien faire attention à ce que les propriétés changent. Alors je vais vous faire un exemple concret et ça vous parlera plus. Donc on va s'imaginer que notre filter product table en notre transforme en pur component. Donc ici, on lui dit tu es un pur component. Vu qu'il fonctionnait sa forme de classe, le rendre pure est très simple. Donc ce filter de filterable product table, il ne sera rendu que si son état change ou si la liste des produits change. Donc on va s'imaginer du coup au niveau de notre réacte point render, atteindre une seconde et refaire un rendu avec une liste de produits différentes. Alors, je remonte, on va reprendre cette constante là, on va la mettre juste en de sous et on va rajouter un nouveau produit. Donc on va s'imaginer, ajouter ici le Nexus 8 et il est au même prix que le Nexus 7. Cette constante, je vais la peler product 2. Maintenant, je vais demander à mon script d'atteindre une seconde et au bout d'une seconde, je vais re-rendre tout cet élément là. On va attendre un petit peu plus, donc on va faire un set tynant, on lancera une fonction qui va relancer à nouveau rendu, mais cette fois-ci avec la seconde liste de produits. Et on va attendre 200 en fait 2000 millisecondes. Donc on voit qu'au bout de 2000 millisecondes, le Nexus 8 arrive. Je vais au niveau de mon render ici mettre un console point log de Render. Si je réactualise, on voit qu'au bout de 2 secondes, on a bien un second render qui est appelé parce que la liste des produits change et du coup le composant change. Donc là, c'est en concordant ça avec ce qu'on attend. Maintenant, imaginez, on n'est pas forcément si malin que ça et on se dit, je vais simplement pousser dans mon tableau produit le nouvel élément. Donc on va tout simplement lui dire que au niveau de produits, 2, ça sera égal à produits. Et ensuite, je fais un produit de 1 pouche et je pousse mon nouvel élément. Je s'av garde, j'attente de seconde et au bout de 2 seconde, je remarque qu'il ne se passe rien. Pourtant, on pourrait se dire, oui, mais j'ai changé le listing produit et je réappel la render donc tant le même il devrait re rendre les choses. Et c'est justement là qu'il y a un problème. En effet, là, vous of course que vous faites ici, c'est une mutation, c'est-à-dire que vous mutez l'objet product et vous rajoutez une nouvelle valeur. Donc lui, lorsque vous avez défini que ce composant a été un composant de pure, il fait juste une vérification de surface, c'est-à-dire qu'il ne va pas vérifier que, à l'intérieur de votre objet product, vous n'y ait pas les mêmes produits que l'objet précédent. Oui, il compare juste le nouvel objet à l'ancien. Vu que vous avez fait une mutation, lorsqu'il fait une comparaison, il dit non, c'est toujours le même objet, certes, tu l'as changé, mais moi, j'ai aucun moyen de le savoir. Je compare l'ancien objet au nouveau et c'est le même objet, la même référence et ça pose un problème. Donc pour remédier à ce problème-là, lorsque on fait un set state et lorsque l'on change l'état, il faudra éviter d'altérer l'état précédent. Donc la bonne solution pour faire ce qu'on veut faire ici serait tout simplement de dire que pour faire un jeu de produit, ça va être la liste de nos produits, donc, product 1, auquel je rajoute une nouvelle entrée comme ceci. Et dans ce cas-là, lorsque je s'av garde, on va voir qu'au bout de 2 secondes, on va effectivement avoir un second rendu et notre necci suit. Donc lorsque vous souhaitez modifier un tableau, il faudra utiliser ce spread operator pour rajouter une clé avant ou après. En faisant ça, si vous voulez rajouter une clé à la fin, si vous voulez rajouter une clé au début, vous ferait une new item et ensuite vous rajoutez les items. Si vous voulez rajouter une clé homineuse, c'est un petit peu plus compliqué. Ensuite, si vous voulez modifier des objets, il faudra faire un peu la même chose. On s'imagine que vous passez un objet et ensuite vous rajoutez la clé que vous avez besoin de rajouter comme ceci. Donc à chaque fois que vous faites une mutation à une set state, il ne faut pas muter l'état précédent, mais il faut tout simplement envoyer un nouvel objet représentant notre nouvel état. Donc c'est très important, surtout si vous travaillez à des composants de pur, parce que, sinon, vous allez avoir ce problème-là. Alors aussi, ça va nous amener à un second problème, alors on va retirer cette petite logique là et on va déferner notre pur component. Ici. On va reendre notre producteuraux comme un composant pur. Donc à ce niveau-là, j'ai juste à lui dire, je le fais à une constante, producteuraux est à la réacte point de mémo et je fais ça. Donc encore une fois, ce sont deux manières différentes de définir des composants qui sont des composants pur. Réacte point de mémo dans le cas d'une fonction et réacte point de pur component dans le cas d'une classe. D'ailleurs, pour ceux qui sont intéressés par la terminologie ici, mémo c'est le diminutif de mémoisations. C'est tout simplement une technique qui consiste à mémoiser les valeurs retournées par une fonction pour éviter de la réappeler. Voilà pourquoi on appelle ça mémoisation. Et pure component, ça vient des fonctions pur. C'est-à-dire que c'est une fonction qui change de retour seulement si ces valeurs a d'entrer en changer. Et sinon, qui rend toujours la même chose. Donc c'est pour ça qu'on a ces deux termes qui sont utilisées. Donc je réacte ma page et je vais mettre ici un console point log encore une fois de Render Product. Donc là, on a bien l'optimisation qui est faite. Si je coche cette case-là, je n'ai pas de Render Product nouveau qui est appelé. Maintenant, imaginons que lorsque je fais un Render Product, je me dis, je vais te passer un petit callback. Donc lorsque je fais un Product gros ici, je lui dis OnClick. Même si d'ailleurs ce n'est pas interprété, et là, je lui passe une fonction. Et on s'imagine que je vais le fonction qui s'appelle OnClick et je ferai un vice point OnClick et je pourrais faire un bindVise par exemple. Ou je pourrais lui passer une fonction en écrivant de cette manière-là. Et là, je sais pas ce qu'on pourrait mettre. Juste comme ça. Si je sauve garde, on va voir quelque chose d'étranges. Si je décoche cette case-là, et si je redécache cette case-là, on voit que contrairement à tout à l'heure, on a plein de randus qui sont réappelés. Pourquoi ? Tout simplement parce que en définissant les callbacks de cette manière-là, à chaque fois que vous vous réappeliez cette fonction-là, cette fonction est différente. Elle n'est pas mémoirisé quelque part, et du coup, à chaque fois que vous avez cette randu qui est demandé, malgré la mémoisation, il dit oui, mais le callback est différent du callback précédent. Du coup, vu que le callback n'est pas le même objet, je dois redéclencher un randu. Et le fait d'envoyer et de décrire les callbacks directement comme ça, même si ça peut pas être pratique au premier abord, a un effet contre-productive. Ça veut dire qu'à chaque fois qu'il y a un randu, le callback est différent, et si vous avez derrière des composants qui sont pures ou des composants qui sont mémoisés, ils ne prendront pas le compte à la mémoisation parce que le callback change à chaque fois qu'il y a nouveau randu par le composant par an. Donc c'est pour ça que c'est très important lorsque on utilise des callbacks comme on le fait depuis le début de cette formation, d'utiliser cette approche-là, du bind-vis dès le constructeur. Comme ça, ce callback est défini une bonne fois pour tout dans cette classe-là et il ne changera jamais. Si vous utilisez un bind-vis directement à ce niveau-là, à chaque fois que vous appelez un bind-vis, il redéfinit une nouvelle version de la fonction. Donc à chaque fois, vous vous retrouverez rien avec une nouvelle fonction et les composants de pures qui sont en dessous déclencheraient des randus parce qu'ils pensent, parce qu'ils pensent se rendre que ce qu'ils reçoivent par un maître à changer. Donc ça, c'est très très très important de bien la similécent. Donc si il faut retenir de cette vidéo, c'est que, basiquement, si vous avez des composants qui sont particuliers, qui ne doivent pas être randus systématiquement, même si leurs parents est randus et qui ne doivent être randus que si une des propriétés ou leur étage change n'inquiète ce qu'à-la, ça peut être intéressant d'utiliser des pures componnettes. Donc si on prend le cas de Facebook, par exemple, on a au milieu un newsfeed qui est liste l'ensemble des news. On peut s'imaginer que quand je tape une recherche en haut, on a pas envie de re-rendre systématiquement ce newsfeed. Donc on peut lui dire, mais lui ne dépend que du paramètre en entrée qui serait la liste de news et à que quand la liste de news change, qu'il doit être randus. Donc ça peut être pertinent de créer un pur composant à ce niveau-là. Par contre, si vous avez juste besoin d'avoir un bouton, ça n'a rien de le mémoiser, ça va demander un coup supplémentaire pour économiser un rendu qui est vraiment minime. Donc ça ne vaut pas le coup, par contre, voilà, gardez cette idée en tête que si vous avez des composants ou vous savez que la logique de rendu peut être un petit peu complexe dans ce cas, nous giserons les pures componnettes. Ensuite, lorsque l'on fait des sets states, on fera attention à ne jamais muter les valeurs. C'est-à-dire que si on change une valeur, on va créer une nouvelle version. Donc si on travaille avec les objets, on va créer un nouvel objet, soit en utilisant le scrédopérateur, soit en utilisant la fonction objecte qu'on a signe. Et si on travaille avec les tableaux, on évitera à tout prix d'utiliser un pouche. On créera un nouveau tableau et on rajoutera une valeur, soit en utilisant le scrédopérateur, soit en utilisant slice. Donc là, à vous de voir, mais l'intérêt vraiment, c'est de créer une nouvelle version du tableau. Les éléments à l'intérieur du tableau peuvent ne pas changer, ça s'appareil logique, mais par contre, le tableau doit être une nouvelle version. Sinon, lorsqu'il va faire des comparaisons, il va détecter qu'une n'y a pas de rendu à faire et ça peut poser des problèmes. En fait, les derniers points, lorsque l'on utilisera des callbacks et pour faire remonter de l'information par exemple, on fera attention à envoyer toujours la même version de la fonction et ne pas définir les fonctions à la voler, parce que sinon, ça veut dire que l'enfant aura toujours l'impression de recevoir une nouvelle version du callback et même si votre composant est pur, ça redécline le cheuré des rendus. Enfin, une dernière chose, alors, je l'ai volontairement essayé de l'éclipse C, pendant ce chapitre là, mais vous avez une fonction qui est possible d'utiliser au niveau de vos composants, qui est la fonction choule-component-addate. Donc c'est quelque chose qui va être appelé et qui permet de savoir si le composant devait être mis à jour. Donc cette fonction s'appelle Choule-component-addate. Elle va prendre deux paramètres. Le premier, c'est les Next-Props, c'est-à-dire les nouvelles props qui veulent recevoir et le second, c'est Next-State. Cette fonction, elle doit renvoyer True ou False pour dire est-ce qu'elle doit faire un update, c'est-à-dire est-ce que la fonction Render doit être rappelée. Donc là, on va s'imaginer qu'on aurait un Return False tout le temps. Et au niveau de cette fonction Render, je vais faire un console point-log Render. Si maintenant je clique sur une checkbox ou que j'essaye de taper nos recherches, on voit qu'il ne se passe absolument plus rien. Parce que lorsque le React, je vois qu'il y a un changement d'état, il va utiliser cette fonction là pour savoir s'il y a en un Render et cette fonction ne renvoyait. Et du coup, on a aucun nouveau rendu. Donc on va juste débuguer Next-Props et Next-State. Lorsque vous faites un extend de React point-pure-component, c'est en fait une classe qui fonctionne comme un composant classique, sauf que vous avez déjà un chout de Component Update qui a été créé et qui compare simplement que les Next-Props et les Next-State ne doivent pas être identiques. Donc c'est vraiment assez rare qu'on est besoin de définir nous-mêmes cette fonction là. Ça peut être utile en certain cas, donc c'est pour ça que je vous montre, mais de manière générale, on va plutôt utiliser les pures componentes et on ne va pas forcément définir cette logique là. Le problème quand vous commencez à changer cette structure-là et cette logique là, c'est que vous pouvez avoir des... Vous pouvez derrière avoir des problèmes avec des rendus qui devraient se faire, qui ne se font plus et ça pose toujours un petit lot de problème. Donc là, si j'essaye de cliquer ici, on voit que je reçois en premier paramètre les nouvelles propriétés, donc elle ne change pas. Et par contre, je vois que la partie IN-Stock en lien a changé. Donc ici, si on voulait faire quelque chose, on pourrait vérifier que on retournerait que Next-Props. Point-Products doit être différent de vis.props. Point-Products ou va y... il faudrait que Next-State.filterText doit être différent de vis.state.filterText ou encore une fois que Next-State.in-Stock en lien doit être différent et vous avez compris le principe. Donc ça, c'est quelque chose qui est fait de manière automatique lorsque vous utilisez des pures componentes. Mais c'est ce qui se cache sous le capot. Si maintenant, j'essaie de cocher cette case-là où de faire des recherches, ça fonctionne convenablement et le rendu est appelé. Donc voilà, pour ce principe-là. Retenez bien le concept d'immutabilité et l'utilisation des callbacks en aura définissant pas les choses à chaque fois. C'est vraiment les deux suces éléments de clés qu'il faut comprendre dans ce chapitre-là. Donc j'espère que ça vous aura permis d'y voir un petit peu plus clair et je vous donne d'en rentrer vous dans le prochain chapitre où nous allons parler des références.