 Salut et bienvenue dans ce nouveau chapitre que je vous propose de découvrir ensemble le principe des contextes. Alors les contextes ce n'est pas forcément quelque chose qui va être spécifique aux composants de fonction ou composants de classe, c'est un concept général de réacte. Donc le principe c'est d'être capable de faire communiquer des parents avec des enfants sans forcément utiliser des propriétés. Donc le problème que l'on a actuellement c'est que si on a besoin de passer des informations, on est obligé de faire descendre l'information à travers des propriétés de parents et enfants. Donc imaginons par exemple je crée une sorte de constante qui me permet de se regarder le thème qui sera utilisée. Donc on va créer une constante thème et dedans on aura deux thèmes, un premier qui sera le thème d'arc qui permettra d'avoir une couleur de fond qui sera noir par exemple. Donc on va mettre du 0,00 et une couleur de texte qui sera blanche. Ensuite on a la même chose mais pour un thème qui sera éleint. Donc là on mettrai un bas grande qui seraient du dollar FFF et l'inverse pour la couleur. Donc là on se crée une sorte de constante que l'on va pouvoir utiliser et qui est indépendante du fonctionnement de réacte. Donc on s'imagine que au niveau de notre application on va retourner une dive et peut-être on aura une toolbar. Tout bar qui va contenir un bouton. Donc le problème c'est que ce bouton il va avoir besoin d'être influencé par le type de thème qui sera utilisée. Si le thème est d'arc, le bouton sera noir avec une couleur blanche et inversement dans le cadre du light. Donc si on veut faire passer les informations jusqu'à notre bouton, on va être obligé au niveau de notre toolbar de dire je te passe le thème et le thème ça sera thème point d'arc. Ensuite je vais créer ce composant de tout bar. Je vais pour l'instant le créer sous forme de fonction parce que je n'ai pas forcément besoin de m'embêter. Il recevra le thème en paramètre et à l'intérieur je pourrais retourner une dive et peut-être on aura différents éléments de navigation. Et à la fin de ces éléments de navigation on aura notre bouton et là on lui passera simplement comme style le thème. Comme ceci, on mettra maîtrise. Donc si je s'affigue en le bouton et bien noir avec le fond blanc et le problème que l'on peut avoir c'est que si on a un autre composant qui est par exemple un système de recherche, on peut s'imaginer qu'on a ici un search form qui serait un autre composant. Si ce composant contient un bouton, on aurait aussi besoin de lui passer le thème. Donc on se retrouve à devoir passer à tout un tas de composants le thème pour pouvoir travailler. Donc on pourrait lui dire pour l'input, c'est pareil, on lui donnerait un style qui correspond à notre thème. Et pour que cela s'affoncione, il faudrait que notre search forme passe le thème. Et vous pouvez apercevoir ici la problématique que l'on rencontre. C'est que à chaque fois on est obligé de transvaser la valeur et si on a un arbre d'éléments assez complexes, on se retrouve à devoir passer les choses d'enfants en enfant, même si cela n'a pas forcément trop de sens. Donc le système de contexte va permettre justement de faire passer des informations beaucoup plus simplement aux éléments enfants. Donc cela fonctionne de la manière suivante. Vous allez devoir commencer par définir un contexte. Ce contexte est définie en utilisant un méthode React.qu'UiT contexte. Et vous allez du passé en paramètre une valeur initiale par défaut. Cette valeur pouvait être écrasée par nos composants, mais nous on lui ira que par défaut c'est le thème d'arc qui sera utilisé. Donc à l'intérieur de ce contexte on va avoir une propriété background et color. Ce contexte je vais le sauvegarder dans une variable que je vais appeler thème contexte. Maintenant il va falloir que notre élément application définisse un provider. C'est à dire qu'il va dire je suis responsable moins de passer le contexte à mes enfants. Donc tous les composants qui vont avoir besoin de ce contexte vont devoir être entourés, donne l'élément qui s'appelle contexte provider. Donc ici je peux créer un nouveau composant qui va englober tous mes autres composants et je vais utiliser thème contexte. Donc ce que j'ai définit tout en haut, point provider. Maintenant, imaginez-nous en envie que les boutons soient stylisés. Donc on se dit que je n'avais pas envie de passer ce thème systématiquement. Je veux qu'automatiquement mes boutons soient capables de récupérer le thème. Donc je vais retirer cette propriété qui est passé d'élément en élément. Comme ceci. Voilà. Là je supprime toutes les références à thème que l'on a faite. Et je vais créer une nouvelle fonction qui va s'appeler tème button. Donc ça va être un bouton qui va être influencé par le thème. Ce thème de button il recevra un paramètre des enfants, shield run. Ce qui me permettra de changer le mot menscrit récit et pour le cas de la recherche on mettra recherché. Donc vu que cette fonction est définie je vais l'utiliser à la place de mes différents boutons. Comme ceci. Maintenant ce thème de button j'aimerais bien lui dire il faudrait que tu sois capable de récupérer le contexte et savoir sur quel thème on est. Donc pour cela il suffit simplement de créer notre bouton et de l'entourer donne thème contexte point consumer. Donc ça ça veut dire que à l'intérieur on va consommer ce contexte et on va récupérer la valeur. Donc plus le taux peut de mettre directement l'élément en forme comme ceci. On va lui passer une fonction qui prend un paramètre la valeur. Donc c'est la valeur qui est dans le contexte et ensuite ça retournera des éléments du dos. Donc là je peux faire un return of battle et je peux lui dire je aimerai bien dans le style que tu mettes la valeur. Ce qui correspondra à l'objet, bas grande et color. Et ensuite dans mon bouton je mettrai les différentes enfants shield run comme ceci. Donc ce thème de button ne fonctionnera que si dans son parent il y a un thème contexte de provider. Si il n'y en a pas ça ne pourra pas fonctionner. Donc maintenant je vais sauvegarder et mes boutons ne vont pas avoir de style. Si je venais à retirer ce provider et que je sauve garde, automatiquement ils ont le style noir. C'est à dire qu'il s'il prenne le thème obscure par défaut parce que quand il regarde dans leur parent il n'a pas de provider. Maintenant le rôle du provider est de fournir une valeur. Donc par exemple ici je peux lui dire la valeur que je vais te fournir ça sera thème point light. Et automatiquement ça sera le thème light qui sera utilisé. Je vais juste rajouter pour les deux cas que je veux que la bordure soit la couleur de bas grande. Donc ici ça sera 0, 0, 0, 1, 1, 1 et FFF en bas. Quoi que c'est pas très pertinent on va dire que la couleur de bordure ça va être la même couleur que le texte. Donc on va être un solid, 1 pixel et on mettra du blanc dans le cas du thème dark et on mettra du noir dans le cas du thème light. Si je sauve garde voilà ce que ça donne. Donc là vous le voyez le parent grâce aux thèmes contextes de provider peut préciser des valeurs qui seront automatiquement utilisées par les enfants même s'il y a un composant intermédiaire, même s'il n'y a pas de lien direct. Alors il faut faire attention par contre parce que ce thème de button est maintenant dépendant du fait qu'il y ait un provider. Donc ça rend le composant moins réutilisable parce que vous ne pouvez pas prendre ce composant et le mettre dans un autre projet s'il n'y a pas ce principe de contexte. Mais par contre ça peut être intéressant d'utiliser ça pour entourer un composant qui lui serait générique et créer une version de ce composant qui dépendrait du contexte. Donc voilà pour le principe de base des contextes. Alors vous allez voir il y a un petit peu plus de chose. Premièrement petit de mise en garde sur ce que vous mettez dans le value. Faites attention à mettre une référence toujours même objet. On pourrait être tenté de mettre ici un objet que l'on générait par exemple à la volée, avec bas grande et en mettant des valeurs. Si vous faites ça le problème c'est que à chaque fois que ce composant app sera au rendu, cet objet sera différent. Et vu que cet objet sera différent, le contexte va avoir l'impression qu'il a changé et ça va déclencher le rendu de tous les composants enfants. Ce qui est un petit peu dommage. Donc si vous précisez une valeur qui est un objet, pensez à utiliser la même référence ou à utiliser use mémo ou use rêve si c'est une référence à notre objet. Donc nous dans notre cas, Temp.light ne va pas changer donc il n'y a aucun problème. Ensuite, autre détail, il est possible de consommer un objet de différentes manières. Là pour l'instant on a utilisé un système avec une composant qui s'appelle Temp.consumer, mais il existe d'autres solutions qui permettent d'avoir une syntaxe qui est un petit peu plus agréable. Dans le cadre d'un composant, définissez sous forme de fonction, vous pouvez écrire la chose de la manière suivante. Vous pouvez faire une conste, vous allez se regarder la valeur et vous allez utiliser UseContext. C'est un hook et vous allez lui passer un paramètre le contexte, moi c'est Temp.constext. Automatiquement, vu que vous avez la valeur, vous pouvez maintenant au niveau de votre retour, vous compter de faire ça. Et dans ce cas-là, vous obtiendrez le même résultat. C'est beaucoup plus simple à utiliser et ça permet d'avoir un code qui est beaucoup plus clair. Vous pouvez aussi utiliser les composants sous forme de classe. On va s'imaginer, créer une classe que l'on va appeler Temp.class. Et ça va étendre de React.component. Ça faisait un petit moment qu'on n'avait pas utilisé cette syntaxe-là. À l'intérieur, on va simplement créer un Render et on va rendre, parce que l'on écrivait tout à l'heure. Donc on va utiliser la syntaxe avec le consumer. Donc on va faire un Render, Temp.consumer. Et à l'intérieur, je vais donc avoir une fonction qui va prendre parmettre la valeur et qui fera un Render, faire un Ritter, plutôt, de notre bouton avec la valeur. Comme ceci. Donc ça, ça serait la syntaxe classique. Je vais utiliser ce Temp.class pour la partie recherche par exemple. Ça en aura à la fois le Temp.class pour la partie toolbar et le Temp.class pour la partie recherche. Ça nous fera un petit peu les deux exemples. En me sort juste une petite erreur ici, parce que je n'ai pas récupéré les Childrun depuis le propriété. Donc là, je vais lui dire, je vais créer une constante qui va s'appeler Childrun et j'en récupère ça depuis viz.m.class. Et là, ça fonctionne bien. Donc on voit bien ici que dans le cadre d'un composant définis sous forme de classe, on a bien consommé le contexte. Vous avez une autre manière d'écrir les choses qui est aussi un petit peu plus simple. C'est que vous pouvez lui dire que cette classe-là, c'est la classe Temp.class. Elle va avoir un contexte type et elle va dépendre du Temp.class. Si vous écrivez ça, vous avez maintenant une nouvelle propriété dans votre classe qui s'appelle Context. Donc ce que je peux faire, c'est faire un conste value, égalvis.context. Dans ce cadre-là, je n'ai plus besoin de faire un conste humeur à ce niveau-là et je peux simplement retourner un bouton. Comme ceci. Si je s'av garde, j'obtien toujours le même résultat. Et si le Temp passant Light, automatiquement, mais deux boutons passant Light. Donc ce sont de manière d'apprendre les choses différemment. Si vous définissez un composant qui va être un composant qui dépend directement d'un contexte, vous pouvez utiliser ce UseContext et si vous utilisez un composant définis au fond de classe, vous pouvez utiliser le contexte type. Le problème de cet API dans le cadre des classes, c'est que vous ne pouvez consommer qu'une seule classe à la fois, vu que vous avez qu'une seule propriété contexte type. Avec la API UseContext, la vantage, c'est que vous pouvez dépendre de plusieurs contextes et écrire plusieurs lignes comme ça. Parce que effectivement, dans ce cadre de contexte, vous pouvez avoir un autre système. Par exemple, on pourrait avoir un UseContext qui définirait un utilisateur de manière générale. Et on aurait une valeur qui serait différente. Proviens-leur de jeûne Césu, mais on aurait une valeur différente. Dans ce cas-là, certains composants pourraient s'abonner aux UseContext, d'autres items contextes et d'autres deux. Avec la API class, malheureusement, vous pouvez vous abonner qu'un seul contexte. Dans si vous voulez vous abonner à deux contextes différents, il faudra utiliser deux consumers l'un sur l'autre. C'est d'ailleurs ce qui vous est montré dans la documentation. Donc on va se rendre directement sur la documentation concernant les consumers. Et vous voyez que vous avez cette syntaxe un petit peu en bas. Parce que je la retrouve. Alors, c'est dans la partie contexte et on va dans la partie contexte type. Donc on vous met un garde justement sur le fait de consommer plusieurs contextes. Et voilà à quoi ça ressemble dans le cadre d'une consommation multiple. Je pense que vous serez d'accord avec moi pour dire que ce n'est pas forcément le truc le plus visible du monde. Alors maintenant, un dernier point, qu'est-ce qui se passe si je veux pouvoir permettre à l'utilisateur de changer de thème? J'aimerais bien que l'utilisateur ait la possibilité de définir un nouveau thème. Dans ce cadre-là, le seul composant qui peut être amené à changer la valeur du contexte, c'est le composant qui contient le provide. Dans notre cas ici, c'est app. Donc ce que l'on va faire, c'est qu'on va créer une nouvelle constante en faisant un NewsState. Donc on récupérera la valeur du thème et on aura un 7 thèmes. Comme ceci, au plan, et on aura un NewsState. Et on va lui dire que par défaut, le thème qui sera utilisé, c'est le thème like. Maintenant, je vais créer un Togler qui permet de changer le thème. Donc on va créer une constante, qu'on va appeler Toggle Thème. Et ensuite, on lui dirait que ça sera donc une fonction. Et cette fonction, on va peut-être l'entourer d'un NewsColeback pour éviter les problèmes, la NewsColeback. Donc cette fonction, ce qu'elle fera, c'est qu'elle fera un 7 thèmes. Elle prend en paramètre le thème actuel, qu'on va simplement appeler T. Et on va lui dire que si le thème c'est like, dans ce cas-là, on mettra Dark. Et dans le cas contraire, on remetra Light. Donc ça, ça va permettre de faire alterer la valeur. Ce callback, il n'a pas besoin d'autres éléments, il ne changera jamais. Maintenant, je vais créer une constante qui va s'appeler Courant Thème. Et je vais lui dire que si le thème, donc ces thèmes, est égal à Light. Dans ce cas-là, ça sera Thème.light. Et dans le cas contraire, ça sera Thème.Dark. Je peux ensuite utiliser ce Courant Thème au niveau de la partie Value, à ce niveau-là. Ça me permet d'avoir quelque chose qui va dépendre de l'Etat. Le petit problème ici, c'est que j'ai utilisé Thème alors, c'est déjà utilisé à haut. Donc là, on va s'imaginer qu'on va mettre plutôt ça, dans une variable qui sera tout en majuchcul pour bien comprendre que c'est une constante. Donc, nos thèmes, on va les mettre comme ça en majuchcul. Donc, basiquement, si c'est Light, ben dans ce cas-là, on exporte l'obg Light. Et sinon, on exporte l'obg Dark. Et je peux utiliser Courant Thème à ce niveau-là. Et dernier petit point, il faut que lorsque je crée le contexte, le thème que je vis passe par défaut, ça soit le thème Dark. Maintenant, je vois bien qu'au niveau de mon rendu, j'ai les boutons qui sont blancs. Donc, j'aimerais bien avoir un petit bouton qui me permettra de changer les choses. Donc, ce bouton, je vais le mettre directement ici et je lui dis à lorsque tu cliques, je veux tout simplement que tu fasses appel à la fonction Toggle Thème pour changer le thème. Et ensuite, on mettra, changer le thème. Si je sauf Gard et que je clique sur changer le thème, automatiquement les différents boutons, même si ils sont dans des composants enfants, vont être changés. Mais on aimerait bien pousser les choses encore plus loin. On aimerait bien peut-être avoir un nouveau composant qui doit du coup être dans le thème contexte Provider, qui s'appelle Thème Switcher. Comme ceci. Ce composant-là, on ne lui passe absolument rien. On aimerait bien qu'il utilise le Provider pour changer les valeurs. Je vais aller créer cette fonction-là, que je vais appeler Thème Switcher. Et ça va être une fonction qui ne prendra aucune propriété et qui retournera notre bouton. Le problème, c'est que, ben là, on n'est pas à capables de communiquer avec le composant-parant. On peut s'imaginer que ce bouton Thème Switcher est beaucoup plus en profondeur dans notre arbre, et on aimerait bien du coup directement interagir avec notre contexte. Donc ce que l'on peut faire dans cette situation-là, plutôt que d'envoyer simplement un objet qui continuera les propriétés CSS, on pourrait se dire que au niveau de notre contexte, on a un vrai plus d'informations. On en verrait le Thème, qui serait égal à Thème's point d'arc par défaut, et on lui en verrait aussi une fonction qui permettrait de changer le Thème, que l'on appellerait ThogalThème. Cette fonction, on l'a définie comme un simple callback qui ne fait rien. L'avantage, c'est que, dans notre composant qui est responsable du Provider, on peut lui baser comme valeur ici, un nouvel objet qui contiendra à la fois le ThogalThème, mais aussi le Thème. Donc c'est ce qu'on a ici. Histoire d'éviter de re-générer les choses systématiquement, on va utiliser ici un use Mémo. Donc on va créer une constante que l'on va appeler Value, et on fera un use Mémo, qui sera une fonction, et cette fonction elle retournera à une objet qui continuera le Thème à utiliser. Donc là, on pourra utiliser cette chose-là. Et ensuite, en ce qu'on paramètre, on lui passera ThogalThème. Ce Mémo, il doit changer de valeur lorsque le Thème change ou lorsque ThogalThème change. Bon normalement, ThogalThème n'est pas sang, sans s'échanger vu que c'est un callback, mais on le mettra quand même en dépendance pour être sûr. Maintenant que l'on a cette valeur, on peut la passer au niveau de notre Provider. Il faudra faire attention, maintenant lorsque les enfants récupèrent le contexte, il récupèrent un objet qui continuera à la fois le Thème et la fonction ThogalThème. Donc si il n'en besoin que de consommer le Thème, je peux utiliser la destructuration et lui dire, pour moi, je ne récupère ici que la propriété Thème, que je vais passer en valeur au niveau du style. Ici, dans le cadre d'un composant, on me définit sous forme de fonction, c'est le même principe, j'utilise la destructuration et j'ai importe le Thème. Si je sauve garde maintenant et que je réactue l'isme à page, on va me sortir une petite erreur parce que j'ai laissé le code dans le Thème Switch. Pour l'instant, je vais retirer ce bouton. Maintenant, l'avantage c'est que ce Thème Switcher peut consommer aussi mon contexte vu qu'il est à l'intérieur. Donc ici, je lui dirais, je vais créer une nouvelle constante. Je vais utiliser la destructuration et moi ce qui m'intéresse dans le contexte, c'est de récupérer la fonction ThogalThème. Function qui fait simplement référence à la fonction du Provider, celle-ci, qui permettra donc de changer le Thème. Maintenant, je fais un use contexte en utilisant le look et je lui passe le Thème contexte. Lorsque je clique sur ce bouton-là, en clique, je vais appeler la fonction ThogalThème qui existe maintenant. Si je réactue l'isme à page et que je clique sur changé le Thème, automatiquement, ça change la couleur. Alors, on va mettre en pause de tout ce que l'on a dit et on va essayer de revenir sur le principe. Donc, on a la possibilité de créer un contexte qui va être partagé par différents éléments. Si vous voulez, le contexte va permettre de transmettre des valeurs plus loin dans l'arbre sans forcément que on est besoin de passer les valeurs à chaque propriété. Il faut en revanche que tous les éléments qui interagissent avec ce contexte soient enfants d'un élément qui soit un Provider. Donc, nous dans le cadre de notre application, on a utilisé ici pour renturer tous nos éléments, un thème contexte, point-provider. Et on doit lui préciser une valeur initiale. En l'intérieur, tous les enfants peuvent aussi le souhait, mais ce n'est pas nécessaire, consommer ce contexte et récupérer la valeur, quel que soit leur profondeur dans l'arbre. Ils peuvent récupérer de simples valeurs ou récupérer des callbacks qui permettent d'interagir avec le contexte. Il faudra en revanche faire très attention à l'utilisation que vous faites des contextes au niveau de react, parce que si jamais vous utilisez un contexte et que beaucoup de valeurs viennent changer les choses, il faut savoir que react va devoir re rendre tout ce composant là et tous les composants enfants. Parce que si je change la couleur du thème, ça peut avoir un impact sur de nombreux éléments. Donc là, c'est très pertinent, parce qu'on ne va pas changer les thèmes toutes les deux secondes, mais si vous avez des valeurs qui sont amenées à changer très souvent, ça peut être problématique en termes de performance. L'autre problème, c'est que vos composants deviennent dépendant de ce contexte et ils ont besoin de ce contexte pour fonctionner. Alors certes, on peut mettre une valeur initiale, mais ça rend le code moins réutilisable. Donc, moi ce que je vous conseille de faire, c'est de tout simplement créer un composant qui est générique. Et si vous avez besoin de le décorer avec un contexte, vous crée une version qui est préfixée par le nom du contexte. Donc, typiquement, on pourrait ici avoir des composants de button qui permettent de créer des boutons de manière générique, et ensuite, on aura même composant de contextualiser qui serait thème de button ou user button, ou ce genre de chose, ou là, on sait que ce sont des composants qui ont besoin de ce contexte-là, et on les utilisera de différentes manières. Donc c'est une manière intéressante de faire descendre des informations dans votre arbre sans forcément avoir besoin de passer des propriétés. Donc c'est vrai que si on est réfléchi, ça peut être problématique de devoir se dire, ben là, dans tout le bar, je vais passer le thème. Finalement, le thème c'est quelque chose qui est vraiment globale à votre application, et on n'a pas forcément besoin de faire descendre ça aux enfants. À maintenant, ce que je vous propose pour voir si vous avez bien compris ce système de contexte, c'est de faire un petit exemple concret. Donc je vais tout effacer, et on va les créer notre fonction app. Comme ceci. Et je m'imagine créer un formulaire qui permettrait d'envoyer un contexte. Donc on m'auraient un return. Et je renverrai un formulaire. Donc ça serait un formulaire que j'appellerai, forme contexte. Et je pourrais lui passer les données. Donc je lui passerai value et ça serait un objet qui contiendrait par exemple le nom et en mettrait John. Et qui contiendrait le prenant First Name, qui serait do. Comme ceci. Donc ce forme contexte, ce n'est pas quelque chose qui existe dans React, ça va être à vous de le créer. Et à la limite, on va plutôt la peler des fold values. Ensuite, à l'intérieur, je veux des champs qui soient contextualisés. On aurait par exemple un form fil, pour dire que c'est un composant champ qui serait dans un formulaire. Et je lui donnerai comme nom, Name. Et c'est tout ce que j'aurais à faire. Peut-être, à l'intérieur, je mettrai le label avec Marké, non. Comme ceci. Et j'aurai ensuite un autre élément, form fil, qui permettrait de rentrer le prenant, donc on mettrai First Name. Et on mettrai le prenant. Ensuite, j'aurai un bouton qui permettrait de soumettre ce formulaire. Donc j'aurai un primari button et je mettrai envoyé. Lorsque ce formulaire est envoyé, j'aimerais bien voir les valeurs qui sont récupérées. Donc j'aurai ici un On Submit. J'aurai une fonction Endal Submit, qui serait une fonction très simple, qui recevrait les valeurs et qui se contenteraient de faire un console point log. Donc là, j'ai fait un const Endal Submit, égaluse callback. Et ça sera donc une fonction qui n'aura absolument rien comme dépendance et qui fera un console point log de value. Et value sera la fonction qui sera soumise. Enfin, sera les données qui seront soumis par le formulaire. Donc si par exemple, quelques unes tapes, j'anne d'eau, je devrais recevoir ici un objet avec Name qui contiendra j'anne et First Name qui contiendra d'eau. D'ailleurs, si c'est plutôt l'inverse, c'est l'habitude, c'est le nom qui s'appelle d'eau et ensuite c'est le prenant qui s'appelle John. Voilà, donc votre objectif c'est d'arriver à créer quelque chose qui est cette signature là. Donc la principale problématique sera de faire passer les données de ce formulaire là vers les différents champs. Donc je vous laisse essayer de le faire. Vous pouvez utiliser bootstrap si vous voulez avoir un petit peu plus de style, mais c'est vraiment pas dépendant du framework là. Vraiment ce qui me l'intéresse, c'est de voir si vous êtes capable d'utiliser le système de contexte. Pour vous donner quelques pistes, vous allez avoir besoin de créer un contexte qui permettra de sauvegarder les valeurs de formulaire. Ce contexte sera consommé par les différentes formes fields pour récupérer les valeurs et les formes fields vont aussi devoir interagir avec le contexte pour changer la valeur qui sera dans le contexte. Et lorsqu'on en soumettra, on récupéra tout simplement la valeur du contexte. Donc essayer de le faire et on corrige ensemble juste après. Alors j'espère que vous avez essayé de pratiquer et on va commencer par notre premier élément le form contexte. Pour l'instant on ne va pas trop s'occuper de toute la partie contexte. On va simplement créer la structure HTML. Donc on aura notre forme contexte qui sera du coup un formulaire. Là je vais retourner un formulaire et à l'intérieur j'aurai mes différents enfants, mes chindrules. Au niveau de ce form contexte je recevrai un défolte value, des folte value et un unsubmite. Ce unsubmite je vais le transférer au niveau de mon formulaire parce que finalement c'est un événement que je suis capable de gérer. Peut-être, d'ailleurs on mettra un unsubmite ou une autre fonction intermédiaire mais pour l'instant on fait ça. Le défolte value ne sait pas comment le gérer pour l'instant. Ensuite on va créer notre fonction qui va permettre de faire des champs, form fields. Cette fonction qu'est-ce qu'elle prend en paramètre, elle prend finalement qu'une seule chose, c'est le nae. À l'intérieur je vais retourner une dive qui aura la cum class form tiré groupe. Et à l'intérieur on aura notre label, donc au niveau du fort je vais réutiliser le nom, j'imagine que c'est un être unique et je vais mettre l'enfant à ce niveau-là. Si j'ai besoin de l'enfant comme pour l'éléments par an, il faut que je le passe en paramètre au niveau des propriétés. Si j'utilise des composants, définis-ce ou formes de fonction. En dessous de notre label on aura notre input, donc ce sera un input de type texte. On lui donnera comme nom, le nom qui est passé. On lui donnera comme a dit le nom, ce qu'on a mis dans le HTML4 finalement. Et pour l'instant on ne sait pas comment gérer la partie valeur, donc on crée un champ non contrôlé. Je vais simplement lui rajouter comme class, formes tiré control pour avoir un minimum de style. Enfin il nous reste le primari button, donc je vais créer une fonction qui va s'appeler primari button. Donc cette ce primari button aura simplement récupérait les enfants. Et à l'intérieur je retournerai un bouton qui aura comme class BTN et BTN tiré primari. Et je mettrai mes différents enfants. Si je s'affigue et que je réactuise ma page, j'ai bien mon formulaire. Je vais simplement au niveau de la structure générale ici, l'entour est d'une dive que la classe container. On sait juste pouvoir avoir un minimum de style, ça ne change rien à l'exercice. Maintenant le problème c'est de faire passer les enfants de ce form contexte vers ce form field. Donc il me faut forcément un contexte pour faire descendre les informations. Donc je vais aller créer une nouvelle constante qui va s'appeler Form contexte. Alors le problème c'est que j'ai déjà utilisé Form contexte pour ce composant-là. Donc on va l'appeler Form contexte. Je suis désolé, c'est pas optimal. On fera un React.qu'qu'qu'qu'qu'qu'qu'on texte ou on importe directement simplement Create contexte. Et je lui passe en paramètre la valeur initiale. Donc là j'ai juste besoin de se garder les données. Donc on lui dirait que si on n'a pas de contexte parent, l'objet qui est censé contenir les données sera simplement un objet vite. Maintenant au niveau de mon formulaire, c'est lui qui va être chargé de ce contexte-là. Je vais pouvoir lui dire, j'aimerais bien que tu sois un provider, donc un fournisseur de contexte, à partir de ce contexte-là. Donc là il me suffit simplement de dire tu es un provider. Comme ceci. Ensuite je vais à la ligne, je fais attention à bien fermer différentes balises et je ferme ensuite mon Form contexte-contexte provider. Désolé pour le nom, un vrai il aurait fallu que je choisis un meilleur nom pour mon composant. Et on fait attention à bien balancer nos différentes balises. Donc au niveau de ce provider, je vais avoir besoin de lui passer une valeur. Donc ça veut dire que ce Form contexte aura besoin de se garder dans son état les différentes valeurs. Donc on fera un conste. On aura un tableau, un premier on aura les valeurs, donc on va appeler ça data et cette data. On fera un use state et on lui passera comme valeur initiale, les valeurs par défaut. Une data sera donc un objet qui contiendra en clés les noms des différents champs et en valeur les valeurs qui correspondent. Maintenant que j'ai ce data ici, je peux tout simplement le passer au niveau de mon provider. Donc j'aurai les data qui seront passés. Et ça s'appelle data. Donc je sauve guard, je réactualise ma page pour réfacer les erreurs en console et on peut regarder aussi dans la partie composant, pour voir un petit peu où on en est jusqu'à maintenant. Donc j'ai bien mon Form contexte ici. On voit qu'on a différentes choses avec bien le default value et on a ici notre provider. On voit qu'à l'intérieur de notre provider, on a bien la valeur qui est FirstNameJone et NameDow. Donc il va falloir maintenant que nos Forms field puisse consommer ce provider là. Donc on a différentes approches, nous on va aller vers le OUX et la approche que je juge moi le plus simple. On fera une conste data et il galue UseContext et on récupéra le FormContextContext. Bon à la limite ça me gène vraiment de nommer ça. Donc on va changer ce composant là et on va le renommer FormWeaveContext. Donc là on a renommé ici et en bas et on va renommer notre contexte. Donc je vais faire un contrôle shiftP, renommer le symbol et on va l'appeler ici FormContext. Ça sera un petit peu plus naturel je pense comme nous manclatures. Donc l'avantage maintenant c'est que je peux lui dire au niveau de ce change là. Il faudrait que tu récupères la donnée qui correspond à ta propriété Name. Donc je peux lui dire ici récupère dans value data et je récupère la clé qui correspond. Si cette clé n'existe pas c'est à dire elle est undyFindOnule tu renvoies une simple chaîne de caractère à vide. Si je sauve garde maintenant je reviens dans ma partie console et je réactualise. Je vois bien que dans la partie non j'ai dos et dans la partie prénom j'ai de jaune. Donc là les données circulent bien et mes différents champs sont capables de récupérer la valeur. Je vais simplement inverser FirstName et LastName parce que je trouve ça plus naturel. Maintenant le problème c'est que ces champs sont complètement bloqués parce que comme je vous l'avais dit quand on a parlé des champs si on n'a pas de méthode OnChange qui permet de changer la valeur, on va être bloqués. Là il va falloir du coup que chaque composant est la capacité de communiquer avec le composant par an pour changer l'état. Ça veut dire que au niveau de notre contexte en plus d'avoir les différentes valeurs il nous faudrait avoir une valeur par exemple Change qui permettrait de changer quelque chose. Je peux créer cette fonction à ce niveau là. On va s'imaginer que cette fonction elle prendra en premier paramètre le nom du champ et ensuite en second paramètre la valeur associée. On va la poler AndalChange ou simplement en change. On fera un use callback et ce que fera cette fonction c'est qu'elle prendra en premier paramètre le nom du champ en modifier et la valeur. Elle pourra faire ensuite un set data en récupérant le state précédent. On pourra l'appeler des comme data et on crètera un nouvel objet. On passera les valeurs qui étaient déjà présents dans l'état et en plus on changera la valeur qui correspond au nom. Et on mettra au value comme ceci. Pour que ça fonctionne et si on veut l'écrire vraiment sur une seule ligne il ne faut pas oublier les parenthèses. Donc le problème c'est que maintenant on est obligé de passer ce change à mes enfants. Donc le meilleur moyen de passer ça c'est tout simplement de le mettre dans la valeur que l'on va passer au niveau de notre contexte. Donc je vais créer une nouvelle propriété que je vais appeler Value qui contiendra les différentes valeurs que j'ai dans data plus Change. Si je veux éviter que ce soit redéfinis systématiquement je pourrais utiliser un use Mémo ici. Donc je fais un use Mémo. Ça sera donc une fonction. Cette fonction elle retournera cette objet-là et elle dépendra donc de deux paramètres. Elle dépend de data et elle dépend de change. Change de toute façon est Mémoïsée et ne devrait pas changer. Mais un coin de fois mieux où vous faire trop de chose que pas assez. Et ensuite je peux passer ces valeurs à ce niveau-là. Donc ça ne change rien au niveau de mon comportement. Il faut juste que je fais attention à ne pas avoir fait d'erreur. J'ai un unexpected token à ce niveau-là ce qui m'étonne. Dans la console j'ai une erreur comme quoi cette syntaxe-là n'est pas reconnue. Je pense qu'il essaie de compiler pour des navigateurs qui ne comprendraient pas ça. Donc effectivement c'est peut-être une syntaxe qui est un peu nouvelle. Donc là on va faire un object.acit. Ce n'est pas grave. On va créer un nouvel objet. On va ensuite stocker les valeurs qui sont déjà dans des. Et ensuite on stockera un nouvel objet qui continuera cette valeur-là. Donc si je sauve garde, j'ai maintenant plus d'erreur à ce niveau-là mais j'inérorare à ce niveau-là. Donc là je vais utiliser plutôt la version object.acit. Ce légère moment pratique, mais ça va on a vu pire. On fait ça et là on passe change et ça sera change. Et si je réactualise ma page maintenant, ça fonctionne convenablement. La console continuera de râler parce que pour l'instant il détecte qu'au niveau de mes changements est effectivement précisé une valeur mais je n'ai pas précisé une manière de changer les choses. Donc l'avantage maintenant c'est qu'on a cette méthode de change que l'on va pouvoir appeler au niveau de notre contexte et qui va permettre de changer les valeurs. Donc à ce niveau-là je peux lui dire je vais avoir une fonction qui va s'appeler Indole Change. Indole Change. Ça sera un use callback. Ce callback sera une fonction qui prend en parmètre l'événement qui correspondra au on change. Et vu que ce callback ne changera jamais, je lui dirais ça sera quelque chose qui ne changera jamais. Et à la limite on pourrait lui dire tu dépend en fait de data point change. C'est à dire dans le contexte si la méthode de change change forcément ce en-leur va changer aussi. À l'intérieur il me suffit de lui dire je veux faire un data point change. Je lui passe un premier paramètre le nom du champ, ce sera E point target point name. Et je lui passe en seconde paramètre la valeur E point target point value. Maintenant au niveau de mon champ je vais lui dire lorsque tu change en change, j'ai envie que tu appelles tout simplement la méthode Indole Change. méthode qui fera appel au contexte qui se chargeera de changer la valeur. Pour tester que tout fonctionne convenablement juste après mon formulaire ici je vais faire un gson point stringify et je vais stringify plus tout la valeur. Donc je réactualise la page, je rentre une valeur au niveau du nom et on voit que ça change bien à ce niveau-là. Par contre ça ne change effectivement qu'à l'intérieur de ce contexte-là. Pour l'instant le composant par an n'est pas informé des choses. Donc je vais fermer ça et je vais lui dire lorsque tu soumets il faudrait que tu m'envoie la valeur. Donc là je vais créer une nouvelle constante qui va s'appeler Indole Submit. Ça va être une nouvelle fonction. Tout de suite je vais utiliser le use callback pour éviter la redéfinir systématiquement et cette fonction qu'est ce qu'elle fera, elle fera appel au onsubmit que l'on reçoit en propriété et on passera en paramètres les valeurs que l'on a à ce niveau-là ici. On pourrait retirer la méthode de change mais ce n'est pas nécessaire. Ensuite je lui dis qu'au niveau des dépendances, cette fonction va changer quand on submit, va changer ou quand on va nu, va changer. Donc ça c'est très facile pour définir les dépendances. Vous regardez qu'est ce qui est à l'intérieur de cette fonction et c'est tout ce qui est à l'intérieur de cette fonction et qui dépend de l'extérieur qu'au bout de votre métro dans l'air dépendance. Je peux maintenant utiliser le Andole Submit à ce niveau-là et lorsque je vais changer la valeur et cliquer sur envoyer, on va voir très brièvement que les données sont envoyées. On voit ça très brièvement parce que le formulaire est posté de manière traditionnelle. Donc là je peux lui dire tu recevres en paramètres l'événement et tu forras un E point prevent des fold. Histoire d'annuler le comportement par défaut qui est la submission traditionnelle du formulaire. Je réactualise ma page, je tape des valeurs, je clique sur envoyer et elles sont bien débugées. Donc là j'ai un formulaire qui va être capable de prendre des valeurs initiales au démarrage, qui va être capable de gérer et de générer un contexte. Et l'avantage c'est que je peux ensuite créer des chances sans forcément avoir besoin de leur passer manuellement les valeurs. En ayant besoin de faire un value légal et de passer en un change automatiquement vu que toutes les contextualisées et dépendent du contexte du formulaire, les chances ont capable de récupérer les valeurs et d'altérer les valeurs au niveau du contexte. Donc ça peut être un exemple concrète d'utilisation du système de contexte. Donc c'est intéressant dès que vous avez envie de faire passer des informations vers les enfants sans forcément avoir besoin de vous embêter à passer les choses. Donc comme vous vous lise dans la documentation, c'est quelque chose qui va falloir utiliser avec par Simone et éviter au maximum d'utiliser à tout bout de champ. Dans la plupart des cas il faut réfléchir, est-ce qu'on peut utiliser le système de composition en utilisant un autre système ? Comme on l'avait vu lorsqu'on avait créé des composants particuliers. Il est très souvent tendant d'utiliser le contexte pour résoudre ce genre de problématique, mais dans de nombreuses situations on peut contourner le problème d'autre manière. Donc là par exemple il vous montre que dans le cadre de la barre, dans le cadre d'une toule barre, plutôt que de dire, je vais besoin d'un contexte pour savoir la taille de la vataire et connaître l'utilisation courant, mieux que je lui passe tout simplement directement la vataire. Si ce qui vous montre à ce niveau-là, il crée un lien et dedans il passe la vataire. Donc ça permet de pouvoir passer des choses sans forcément avoir besoin de passer les informations sous forme de contexte. Mais après dans le cadre d'une thème par exemple ou dans le cadre d'un système de formulaires, ça reste une technique et une approche qui peut être intéressante dans certaines situations. Donc voilà pour ce principe de contexte. Globalement ce qu'il faut retenir, c'est que ça permet de faire passer des informations d'un composant par exemple, vers des composants en fond, sans forcément avoir besoin de passer des propriétés tout au long de l'art et ça peut être plutôt pratique dans cette situation. Donc j'espère que ça vous aura permis d'y voir un petit peu plus clair et je vous donneran des vous dans le prochain chapitre.