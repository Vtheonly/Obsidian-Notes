 Avant ce chapitre, nous allons parler des références. Donc un des problèmes que l'on rencontre avec React, c'est finalement que React est responsable des manipulations du dom et parfois, soit parce qu'on utilise des libres et spécifiques, soit parce qu'on a vu qu'utiliser par exemple des champs ou des champs vont contrôler, on a envie d'interagir nous-même avec le dom, et c'est là que les références interviennent. Alors ce que l'on va faire, c'est qu'on va repartir un petit peu de zéro pour y voir un petit peu plus clair. Donc on va utiliser simplement un petit composant qui va rendre un champ et on voudra manipuler ce champ non pas en utilisant React, mais directement en utilisant un du genre script classique. Alors on va créer une classe, on va l'appeler Home, et à l'intérieur on va étendre donc de React.com. Je ne sais pas pourquoi mon éditeur fait toujours cet autocomplétion un peu bizarre. À l'intérieur on va avoir un Render et on va retourner une Dive, et dans cette Dive on aura notre champ de type texte. Et ce champ est un champ qui ne sera pas contrôlé par React. Maintenant je crée aussi un petit bouton, et quand je clique sur le bouton, j'aimerais bien récupérer la valeur du champ. Donc on va lui dire OnClick, je veux que tu lance une fonction, et cette fonction ça bellera en deux-le-clique. Donc c'est une fonction qui prend un paramètre l'événement, même si ça ne devrait rien faire. Et cette fonction, elle fera un console point log pour l'instant de eux. Je vais avoir besoin du constructeur, comme on a vu précédemment, ça nous permet de définir le bon contexte au niveau du endalclique. Donc ici je fais Viz.endalclique, et GalViz.endalclique.mbindys. Donc la principale problématique que l'on a ici, c'est qu'on aimerait bien faire en sorte que lorsque je clique sur mon bouton, je récupère la valeur qui a été tapée dans le champ. Donc si j'ai besoin de faire ça, il me faudrait une référence à ce champ-là. Et c'est là justement que le principe de référence intervient. On va juste finir en faisant un réacte d'homme, point reine d'heures, et on va rendre notre composant homme sur l'élément qui a l'ID UP. Et ici, j'ai dérojet à ma règle, toujours à peu les super propses, si non, on va avoir un problème. Et on va mettre ici, tester. Impécable. Donc pour obtenir cette référence, vous pouvez faire simplement un rêve égal, et vous allez lui passer une fonction qui permettra de récupérer la référence. Donc nous, on va ici s'imaginer avant une propriété que l'on va appeler Input qui sera nulle. Et là, on prendra une callback qui aura un premier paramètre l'élément dans le dom. Et ensuite, qu'est-ce que l'on veut faire ? Nous, on fera simplement ici un vis point input, et gagne à rêve, comme ceci. Donc je vais sauvegarder, et dans ma partie console point log ici, je vais récupérer l'événement, mais je vais aussi récupérer l'Input comme ceci. Donc je réactualise ma page, je clique sur TST. J'ai bien mon objet qui est mon événement, je sais pas vraiment pourquoi je l'ai débugué, mais surtout, on voit bien qu'on a notre Input ici. Donc si quelqu'un tapait une valeur, je pourrais ici lui dire, je vais faire un vis point input point value, et on va enlever ce console point log. Et dans ce cas-là, ça me permettrait d'obtenir la valeur qui a été tapée au niveau du champ. Donc ça, c'est la première manière de définir une référence. C'est pas forcément la manière la plus simple. Vous voyez que ça va nous obliger à écrire un callback, mais vous avez une fonction que vous pouvez utiliser dans React qui est cuillé très f. Donc là, je vais faire vis point input, égal React, point Crate, Rès, et je ne lui passe rien en paramètre. Ensuite, c'est directement vis point input que je vais pouvoir passer en référence. Comme ceci. Et juste avant de faire mon render, on va faire un console point log de vis point input pour voir un petit peu le résultat de cette fonction, CrayetREF. Et on va, ça va garder. Donc tout de suite, on voit qu'on se retrouve avec un objet qui est une simple propriété qui s'appelle courante, et par défaut, la valeur est nulle. Lorsque on passe cette propriété, dans une partie RF, ce que va faire React, c'est qu'il va dire, que je viens de rendre mon input. Donc dans cette référence, pour la propriété courante, je vais mettre l'input. Donc si j'ai besoin de récupérer la valeur, il faudra toujours utiliser courante. Pourquoi ils utilisent courante? Pourquoi ils ne mettent pas directement dans vis point input le champ? Tout simplement parce que ça permet de muter un objet et de garder une référence au même objet, tout au long de l'exécution de notre script. Donc c'est pour ça que ça sera toujours point courante. Donc si maintenant, je réussis de taper des choses et que j'appuie sur Tested, on voit bien cette valeur là. Donc lorsque vous avez besoin de récupérer un élément dans le dom, c'est toujours la même chose. Vous créez une référence. Ensuite, vous passez cette référence à votre élément et quand vous en avez besoin, vous pouvez faire vice, vous pouvez utiliser votre référence point courante et récupérer la valeur. Alors attention par contre, ça va un petit peu à l'encontro de React parce que vous êtes maintenant en train de manipuler le dom. Donc si vous faites des manipulations, ça peut entraîner en collision avec les manipulations qui sont normalement faites par React. Alors pourquoi on va utiliser ça? Il y a deux situations et deux situations seulement qui justifient l'utilisation de référence. La première situation, c'est tout simplement si vous avez des champs non contrôlés et que vous voulez récupérer la valeur par exemple, ou l'alterer. Dans ce cas-là, ça ne pose aucun problème parce que ce champ-là n'a pas de value, donc n'est pas marqué comme contrôlé par React. Donc React, ça t'en a ce que vous le modifiez par un autre moyen. L'autre raison, c'est si jamais vous avez besoin de brancher des composants qui sont externes à React. Par exemple, vous avez une libre-éreja-vascript qui crée un date-piqueur pour un champ. Vous avez envie d'utiliser cette libre-éreja-vascript. Vous pouvez utiliser le component d'Idemont pour rajouter votre comportement et le component will and-mont pour retirer la libre-éreja-vascript. Donc ça peut être intéressant. Voilà pour faire communiquer des libres-érejas qui ne sont pas forcément pensés pour React dans React. Alors maintenant, on va parler d'un autre détail. C'est comment on fait descendre des informations et descendre la référence. Donc imaginez-on, on crée une fonction. Comment l'on a fait d'un foie, fil, qui va permettre de rendre un champ. On ne va pas s'embêter autant que l'un d'un foie, on va simplement prendre ça. Comme ça, on va lui donner la classe ici, forme tirée-groupe. Ce composant-là, il prendra aucun paramètre, qu'on s'en fiche complètement. Et on n'aura pas la partie bouton. On a simplement ici la classe forme tirée contre roll. Voilà, j'espère que vous avez sauté sur votre clavier. Quand j'ai écrit classe, c'est classe name. Voilà, comme ceci. Donc si je souhaite utiliser ce champ, je réussis à créer une dive. On va créer le bouton. Je ne sais pas pourquoi je les supprimais. C'est pas très mal à de ma part. Donc on va lui dire lorsque tu cliques, il faut que tu appelles la fonction VIS.LANDAL.CLIQUE. Et juste avant, je veux que tu crées le champ. Et finalement, c'est sur ce champ-là que je vais utiliser ma référence. Donc là, je vais y passer la référence ici. Et ce que j'ai fait au-dessus, j'ai fait un console.log de VIS.input. Donc je sauf garde. On voit bien qu'on a notre champ. Et ici, on nous sort une petite erreur. On nous dit que le composant, qu'un autre big even rêve. Il détecte que notre composant ici n'est pas un élément HTML. Et quand je lui passe une référence, il a un problème. Et il nous dit, est-ce que tu ne voudrais pas utiliser four word rêve. Donc réacte point four word rêve et quelque chose qui va permettre de transférer la référence et de l'amener un élément particulier. Donc l'idée c'est de dire lorsque je fais rêve ici sur ce champ-là, en fait, moi j'aimerais bien que la référence pointe vers l'input qui se situe au niveau de mon composant field. Pour cela, lorsque on a une fonction, on va utiliser la fonction réacte point four word rêve. Donc on va utiliser une fonction d'entre supérieure ici. Et le résultat de cette fonction, on va la peler tout simplement field. Comme ceci. Cela va changer les paramètres que prendreons cette fonction. Donc d'habitude, une fonction qui est un composant, cela prend simplement les propriétés. Maintenant, cela prendra un second paramètre qui sera la référence qu'il doit four worder. Donc la référence qu'il doit faire passer. Et l'avantage c'est que vu qu'on a cette référence-là, je peux maintenant l'affaire passer à cette input. Comme ceci. Et c'est tout ce que l'on a à faire. Maintenant, si j' regarde mon objet, au début, il vaut bien nul. Mais par contre quand je l'inspect, on voit bien que cela pointe maintenant vers l'input. Lorsque je tape une valeur et que j'appuie sur testée, on obtient bien cette valeur-là. Donc lorsque vous créez des composants et que vous savez que ce composant peut recevoir une référence, il faudra utiliser la métier de l'input. Et dans ce cas-là, on choisit que les le composants qui va recevoir la nouvelle référence. Alors là, on nous voit cela fonctionne très bien avec les éléments de type fonction. Comment cela se passe si on a quelque chose qui fonctionne sur un deux class ? L'âme, malheureusement, c'est un petit peu plus compliqué. Alors on va défert où ça. On va s'imaginer à avoir une classe que l'on va appeler FILD. Et cette classe, elle va étendre donc de réacte pointe-componente. À l'intérieur, on va avoir notre fonction RENDER et à l'intérieur, je retourne, ma dîle, comme ceci. Malheureusement, il n'y a pas de manière très propre de faire ça dans une cadre de une composant définie sous forme de classe. Il faudra utiliser ça comme un composant dans ton supérieur. Donc vous allez simplement faire une partie de la classe et vous allez faire une partie de la classe. Donc on va faire une partie de la classe. On va utiliser ça comme un composant dans ton supérieur. Donc vous allez simplement créer une constante. On va l'appeler FILD ou YVREF, par exemple. Et on lui dira que c'est un réacte pointe-forward-ref. Donc ça, ça attends une fonction qui prend en premier paramètre les propriétés en seconde paramètre les références. Et à l'intérieur, je ferai un RITERN DE FILD. Mon composant qui est un composant basique et je lui passerai une propriété que j'appelle RIFORWARD-REF par exemple et à l'intérieur, je lui passerai la référence. Donc c'est un petit peu dommage parce que vous n'avez pas forcément la même structure. Mais après derrière, ça veut dire que là, vous pouvez faire un VIS pour une PROPS, pour un FILD-WARD-REF. Et dans ce cas-là, ça fonctionnera bien. Si vous utilisez un BA, un FILD-WIVREF. Donc ça peut être utile parce que ça vous permet de décorer un composant qui est basique et de pouvoir lui passer une propriété supplémentaire pour les références. Moi, clairement, je préfère l'approche fonction parce que ça demande un petit peu moins de travail. On n'est pas obligé de créer de choses comme ces locais ici. Si je tape une valeur et que je clique sur testé, on voit toujours quand on obtient les bonnes choses. Donc ça fonctionne très très bien. Alors d'ailleurs, on peut se dire qu'est-ce qui se passe si je veux rajouter, par exemple, un libelé. Par exemple, j'ai envie ici de mettre en label et de mettre une valeur. Ça peut être un petit peu embêtant dans ce composant intermédiaire. D'aller lui dire à temps forer aussi que tu mettes la belle et que tu récupères propres points labels. Est-ce qu'il n'y a pas une méthode un petit peu plus simple ? Alors, vous avez un petit raccourci qui est basé sur le spray d'opérateur mais vous pouvez écrire ça. Donc ça, ça veut tout simplement dire toutes les propriétés que tu ressouvras là, tu les passera à ce composant-là. Ce qui fait que lui, il ressouvra le label sans aucun problème. Si j'écris le label ici, je peux lui dire j'aimerais bien récupérer dans les propriétés de la belle. Donc ça peut vous permettre de passer plus simplement les choses et de faire descendre les informations vers le bas plus rapidement. Si vous utilisez trois petits points props, automatiquement ça permet de créer un composant qui va prendre toutes les propriétés qu'il a là et qu'il les mettra comme sans-enfant. Voilà, c'est une petite astuce. C'est vrai que j'aurais peut-être pu vous montrer avant mais ça permet de gagner un petit peu de temps dans certaines situations. Donc voilà, à quoi serve le système de référence ? Donc si pour tenir, c'est vraiment ses deux fonctions. React.cruetetref permet de créer un objet qui a une clé courante qui va contenir la référence que l'on souhaite utiliser. Ensuite, si on souhaite stocker la référence vers un élément dans le dom, il suffit simplement de rajouter un attribué rêve et mettre la valeur qui est associée. Si jamais on veut faire descendre la référence dans un composant, il faudra utiliser la méthode forward rêve, qui est une fonction d'ordre supérieur, et qui prend en paramètre les propriétés et la référence. Et ça sera ensuite aux composants qui sera à l'intérieur de ce callback de définir à quel élément sera associé la référence. Ensuite, ça vous permet de manipuler directement les éléments ou vouloz souhaiter soit lors d'événements, soit lors du montage ou du démontage d'un élément. Faites attention par contre, vous n'avez aucune garantie que ce élément-là sera disponible. Par exemple, ce qui peut se passer, c'est que l'élément serait masqué ou ne serait pas affiché et dans ce cas-là courant 3 de vignes rénules. Donc si jamais vous avez des conditions sur la fichage du champ, pensez à vérifier que la valeur est bien un input ou un élément dans le dome avant de faire un quelconque traitement. Et après, comme je vous le disais, c'est quelque chose qu'il ne faudra pas utiliser vraiment à tout bout de champ, mais c'est utile que dans deux situations, quand vous avez des champs non contrôlés, ou lorsque vous avez des libraisers externes, que vous les faire communiquer avec React.