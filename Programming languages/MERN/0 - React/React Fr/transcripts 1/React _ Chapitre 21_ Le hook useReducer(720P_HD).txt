 A bienvenue dans ce nouveau chapitre, je vous propose de découvrir ensemble le look Use Reducer. Donc ce est très important parce qu'il va vous permettre de gérer des états qui ont des mutations qui sont un petit peu complexes à décrire. Donc jusqu'à maintenant on a utilisé le Use State pour des choses qui étaient relativement simples. Le problème c'est que si jamais vous avez des états qui sont un petit peu complexes, ça peut être difficile de représenter l'imitation avec simplement un appel au set quelque chose. Et pour vous l'illustrer, je vais imaginer que je veux un compteur mais qui puisse être incrementé, décrementé et réinitialisé. Donc pour l'utiliser, il suffit de faire un Use Reducer. Un premier paramètre, il recevra un Reducer. Donc un Reducer, c'est tout simplement une fonction qui va recevoir une action et un fonction de cet action qui va changer l'état. Alors pour notre cas, un système d'incrémentation et de t'incrémentation, on va créer une fonction que l'on va plier Reducer, qui recevra l'état et ensuite l'action à effectuer. Ensuite on va souvent avoir un Switchcase et on va regarder quel type d'action on a. En fonction de cet action, on va muter notre état. Donc par exemple si l'action est incremente, on va lui dire d'offrir un retourne et on va changer la valeur du de l'état en faisant State. Plus un. Donc on retourne ici le nouvel état. Ensuite on lui dira si le cas c'est décriinte dans ce cas-là, on lui retournera le nouvel état et ça sera State Moise. Dans le cas contraire, c'est-à-dire qu'on reçoit une action que l'on ne connaît pas, mais dans ce cas-là on pourra faire un gros, un New, Error et renvoyer une erreur en disant l'action. On pourra mettre peut-être le nom de l'action et être inconnue. Donc plutôt qu'à avoir une simple fonction qui s'appelle 7, coute ou 7 State ou je ne sais quoi d'autre, là on aura quelque chose qui va pouvoir effectuer plusieurs types de mutations au niveau de notre état. Une fois que j'ai cette fonction réduisseur, je peux l'envoyer un premier paramètre ici. En deuxième paramètre, il recevra la valeur initiale donc nous pour notre compteur en mettra 0. En troisième paramètre, il peut obtenir une fonction d'initialisation qui va faire un traitement particulier. Donc on en parlera juste après. Maintenant cette fonction, elle va retourner un tableau de taille 2 un petit peu comme le New, The State au final. En premier on aura la valeur qui correspondra à l'état, nous ça serait ici coute. Et ensuite en second il va recevoir une fonction qui ne sera pas 7 coute, mais qui sera ce qu'on en appelle un dispatcher. Donc c'est une fonction qui devra être appelée et laquelle on passera une action. Cette action permettra de déclencher un type de mutation particulière. Donc on s'imagine du coup avoir ici la valeur de compteur donc on mettra compteur de point compte. Et là ça nous donnera automatiquement la valeur 0. Maintenant je veux un bouton pour incrementer. Donc je vais créer un bouton, je vais mettre la valeur incrementée à l'intérieur. Et pour déclencher l'incrémentation, il va falloir que je vais vous disent lorsque tu clique, je veux que tu appelle la fonction dispatch. Et tu lui passeras un objet qui a comme type increment. Comme ça automatiquement je rentrerai dans cette fonction là et il déclentera ce changement d'état. Si je réactulise ma page, avec ce que je sois au garde avant, j'ai bien mon bouton incrementé et il incremente la valeur. Si je veux décrementer, je peux utiliser ici décrement. Et dans ce cas là j'aurai un bouton qui permettra d'appeler la partie décrementation. Il va décrementer. Et automatiquement ça incrementera ou décrementera. Ce qui est intéressant avec ce système de réduisseur, c'est que dans le réduisseur, on peut mettre un petit peu de logique. On peut lui dire par exemple ici si l'état du compteur est inférieur ou égal à 0, dans ce cas là je veux que tu continue à retourner 0 ou que tu retournes l'état précédent. Dans le cas contraire, tu peux continuer à décrementer. Ce qui fait que maintenant, lorsque je vais cliquer sur décrementé, il ne se passe pas rien, tant que la valeur est égal à 0. Alors maintenant on va parler du troisième paramètre. Le troisième paramètre est une fonction qui va permettre d'initialiser l'état qui sera ensuite utilisée par notre hook réduisseur. Donc moi dans mon cas, je n'ai plus envie de simplement avoir une valeur qui est un chiffre mais j'aimerais bien avoir un objet qui contiendra une propriété coute, qui contiendra la valeur. Là ça veut dire que j'aurai un objet, je ferai un gson point stringify de coute. J'ai toujours envie de lui donner une valeur initiale simple, je n'ai pas envie de m'embêter. Mais par contre, j'aimerais bien qu'à l'intérieur, à ce niveau là, je me retrouve avec un objet. Dans ce cas là, il faut simplement créer une fonction d'initialisation. Cette fonction prendra un premier paramètre à la valeur, donc on va l'appeler initial, value, et devra retourner l'état. Donc moi, ça sera simplement un objet qui contiendra coute et qui sera la valeur initiale. J'envoie donc ensuite cette fonction, un troisième paramètre de mon user réduisseur. Si je s'affiguearde, je me retrouve maintenant avec au niveau de coute, un objet qui contient une propriété coute et une valeur 0. Attention par contre, parce que maintenant je dois changer les actions qui sont faites lorsqu'on incremente ou lorsqu'on décrimente. Effectivement, si je clique sur « Incrementer », ça n'a pas été type top. Donc là, à ce niveau là, lorsque j'ai incremente, je vais dire de faire un nouvel objet qui contiendra une propriété coute et sa valeur, ça sera state point coute plus un. Lorsque tu décrimente ici, je veux que tu fasses un coute, sera également la state point coute moins ou moins. Si jamais la valeur de state point coute est égal ou inférieure à 0, dans ce cas-là, je veux que tu ne fasses rien. Et dans ce cas-là, je te retourne l'état. Donc ça, c'est intéressant parce que ça veut dire que si votre oeuvre ne fait rien, ne change pas la valeur de l'état. Si vous avez des composants qui reçoivent coute, eux ils vont dire « Ah, ben non, je n'ai pas besoin d'être heureux rendu parce qu'effectivement, le coute n'a pas changé ». Donc dans ce cas-là, il sait qu'il ne devra pas rendre les composants en fin. Pour vous illustrer les choses, je vais créer une fonction que je vais appeler « Child » et à l'intérieur, je vais retourner une dive, je vais mettre « Elo » et je vais mettre un console point log de « Render ». À ce niveau-là, je vais ensuite utiliser mon composant « Child ». Donc je sauve « Garde », je réactualise ma page, je clique sur « Incrementée », la valeur s'incrémante bien et on a un rendu. Je clique sur « Descrémentés », on a un rendu. Je clique sur « Descrémentés », et vous voyez ici qu'il n'a pas rendu le composant « Child ». Pourquoi ? Parce qu'il a été capable de détecter qu'on a retourné le même state, que du coup notre réduisseur n'a pas changé la valeur de l'état et il n'y a pas de raison d'avoir rendre les enfants. Ça peut vous permettre aussi d'avoir gratuitement des optimisations à ce niveau-là. La valeur d'initialisation, ce qui est intéressant, c'est qu'elle peut aussi être utilisé dans notre réduisseur. Par exemple, je peux avoir un nouveau bouton, je vais lui dire de dispatcher un événement de type « Prizette » et je vais lui dire « Réinitialiser », « Réinitialiser » comme ceci. Dans ce cas-là, lorsque je clique, pour l'instant, je vais avoir une erreur parce qu'il va me dire que l'action « Réset » est inconnue, mais ce que je peux faire, ça lui dire, de faire simplement un « case » lorsque tu recevras « Réset » comme action, je veux que tu fasses un « Return » et que tu renvoies « Init » ou « Réinitialise à zéro ». Et dans ce cas-là, lorsque je j'incrémente et que je clique sur « Réinitialiser », la valeur est réromis à zéro avec la même fonction d'initialisation. Donc c'est intéressant parce que ça permet de récupérer de la même logique et c'est plutôt pratique. Aussi, si vous voulez passer des valeurs à vos systèmes, par exemple, j'imagine, j'aimerais bien pouvoir spécifier de combien je veux incrementer. On peut s'imaginer ici, n'y pas assez un « Payload ». Donc on lui dirait, j'aimerais bien incrementer de 10. Comme ça, après, je peux lui dire au niveau ici de mon « Incrementation », je veux que tu incrementes de « Action point payload ». Si ça, ça n'existe pas, je veux que tu mettes comme valeur par des faux « 1 ». Automatiquement maintenant, je peux cliquer sur « Incrementer », ça c'est « Increment de 1010 ». L'avantage, je sais que vous pouvez avoir deux boutons, un bouton qui incremente « 100 payload », du coup, qui va automatiquement incrementer de 1 par 1, et un bouton qui va s'appeler « Increment de froidis », enfin plus « 10 », plutôt, qui va incrementer de 1010. Donc c'est très intéressant ce système de « Use reducer » si vous avez un état qui peut changer de différentes manières et vous voulez contrôler son évolution. Donc le « Use state » est intéressant pour des états qui vont être relativement simples ou pour créer des « OUK » spécifiques, mais si jamais vous avez des changements plus complexes à mettre en place, un « Reducer » peut être plus pertinente. Bon, faut juste être un petit peu habitué à cette logique avec les Switchcase, le système d'action et le système de Dispatch, mais une fois que vous avez bien pris le coup, ça peut vous permettre d'avoir une logique qui est beaucoup mieux décomposé et ça évite d'avoir des choses où on se retrouve avec du code un petit peu partout. Donc j'espère que ça vous aura permis de comprendre un petit peu mieux le principe de ce OUK la, et je vous tendrai un évolu dans le prochain chapitre.