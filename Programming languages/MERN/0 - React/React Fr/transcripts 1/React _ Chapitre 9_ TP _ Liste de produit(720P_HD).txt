 A bienvenue dans ce nouveau chapitre où je vous propose de continuer notre pratique de réactes et on va voir comment on peut réfléchir et morceler nos composants lorsqu'on travaille avec réactes. Donc encore une fois, on va prendre un exemple qui est issu de la documentation, c'est cet exemple là. Donc le principe est très simple, on va avoir une liste de produits qui proviennent d'une API, donc ici on crée un simplement une constante qui continuera ce gisson, et notre idée c'est de présenter ces listes de cette manière-là. On aura en plus tout en haut un petit formulaire qui permettra de filtrer les produits en se basant sur le nom et qui permettra d'an afficher que les produits qui sont instocques, lorsqu'un produit n'est pas instoc, il apparaîtra à en rouge. Donc lorsqu'on en a ce genre d'églacie s'affaire, il faut tout de suite réfléchir à comment on va décomposer et quel composant on va utiliser au niveau de notre application. Donc je vais descendre un petit peu et on a ici un petit schéma. Donc si on réfléchit, on a deux composants principaux dans cet interface. On a un premier composant qui va être le formulaire de recherche. Donc c'est le formulaire qui va permettre de filtrer et qui va permettre de... d'an afficher que les produits instocques. En dessous on aura la liste des produits. Pour cette liste des produits, on aura deux composants, un composant qui permettra d'afficher les catégories et un composant qui permettra d'afficher individuellement chaque année produit. Donc là on a décomposé et on sait qu'elle composant on va utiliser. Maintenant la dernière étape qui nous va faire, c'est comment on va gérer l'Etat. Est-ce que certains composants vont avoir un éterne et est-ce que certains composants vont recevoir des propriétés? Donc la première idée c'est de se dire de manière générale qu'elle et l'Etat dont on a besoin. On a besoin d'un état principal qui sera tout simplement la liste des produits. Et le composant qui va être responsable d'obtenir cette liste, c'est le composant principal. Au niveau du composant formulaire, finalement, lui n'a pas besoin de connaître une grande chose. Il a un simplement besoin de savoir quand est-ce qu'on va changer le filtre de recherche et quand est-ce qu'on va changer l'apticase. Donc ce composant-là, pour moi, il n'est pas nécessaire qu'il est à Nétaparticulier, il recevra simplement des propriétés. Et il fera remonter le filtre et la l'Etat de Koch de cette checkbox aux composants par an. Ensuite pour le composant vert, lui pareil, il n'a pas besoin d'un état particulier, on va lui passer des propriétés, on lui passera la liste des produits et les différents filtre appliqués. Et automatiquement, il la filtera les choses. Donc voilà, pour ce principe-là. Alors maintenant, on va essayer de traduire un peu cette réflexion au niveau du code. Et vous avez un exemple avec les différents composants que l'on va devoir créer ici. Donc l'idée, si vous voulez pratiquer, va essayer de créer cette structure là vous-même et ensuite encore riche-en-sample. De mon côté, je vais juste renommer ce fichier-là. Et on va la poler convertisseur, température, et on va créer un nouveau fichier pour repartir de zéro. Donc je vais créer un nouveau fichier app.js et à l'intérieur, je vais créer une constante que je vais appeler Produx avec tout en majucule pour dire vraiment, c'est une constante qui nous servira ici de tests. Mais plus tard, on pourrait s'imaginer vraiment récupérer ça depuis une appei. Et je vais lister les produits. Donc mon objectif, c'est de créer cette interface en utilisant les composants, tel qu'ils soient affichés ici. Donc, d'abord, on va réfléchir aux composants principales. Donc c'est le composant en orange qui va représenter toute notre petit système. Donc ce composant, il doit s'appeler filterable, producte table. Donc on est parti. On va créer un nouveau composant, que l'on va appeler filterable, producte table. Ah, je vais juste replier ça. On a un petit peu plus de place. Et peut-être agrandir l'espace qui est disponible ici. Ce composant, il va donc étendre de React.component. Et à l'intérieur, je vais avoir une fonction Render qui va permettre de rendre les choses. Ce composant-là, on s'imagine qu'il va recevoir en paramètres les produits affichés. Donc il va avoir une propriété que l'on va appeler producte. Donc je vais tout de suite utiliser la destruction pour récupérer cette valeur-là depuis viz.props. Et ensuite, à l'intérieur, je pourrais rendre mes choses. Donc pour l'instant, je vais simplement retourner une dive. Et à l'intérieur, je mettrai un gisson point stringify et on va stringifier les produits. Maintenant que ce composant est créé, je vais pouvoir le rendre au niveau de mon application. Donc on va utiliser ReactDom, on utilisera la fonction Render. Et on rendra notre composant filterable producte table. Et on ne passera la liste des produits à partir de notre grosse constante clonin haut. Là, j'autopère ce composant-là, vu que je n'ai pas l'intention de m'aider du contenu à l'intérieur. Et ensuite, on va le binder, on va monter ce composant-là sur l'élément qui a l'ID app. C'est toujours un même chose d'ocumen.gattéléments. ByID et je sélectionne l'élément qui a l'ID app. Voilà, donc je vais sauvegarder et je vais regarder au niveau de ma page, je suis un résultat. Je vais aussi sortir ma console pour évaluer les éventus à l'erreur que je pourrais avoir. Alors, avec cette console, juste en bas. Donc pour l'instant, j'ai une petite erreur, parce que j'ai oublié ici de fermer la parenthèse. C'est ce qui m'était dit au niveau de Visual Studio Code. Donc j'ai bien maliste de produits, impeccable. Maintenant, on va s'intéresser à la partie du bas. Pour l'instant, on ne va pas s'intéresser à la partie formulaire. On veut juste avoir quelque chose qui va être capable d'afficher la liste de nos produits. Donc ce composant-là, c'est le composant qui est en verre, il va s'appeler Productable. Donc on réfléchit de quoi il va avoir besoin. Lui aussi, il va avoir besoin de la liste des produits. Et pour l'instant, il n'a besoin que de ça. Donc on est parti, je vais alicrer ma nouvelle classe. Alors, vous pouvez soit créer une classe, soit créer une fonction. Là, vous de voir, vu que c'est quelque chose qui n'a pas besoin d'avoir un état, vous pouvez simplement avoir une fonction ici. Sachant que ça n'a pas vraiment d'importance pour le coup, si vous êtes plus à l'aise avec les classes, vous pouvez continuer à utiliser les classes. Donc on va créer une fonction que l'on va appeler Productable. Cette fonction va prendre en paramètre des propriétés, et nous, on ne passerait en paramètre les produits. Et tout de suite, je vais retourner cette liste-là. Pour cette liste, on ne va pas s'embêter, c'est finalement tout simplement un tableau. Donc on va créer un tableau. Si vous utilisez bootstrap ou autre, vous pouvez rajouter des classes si vous le souhaitez. À l'intérieur, on va avoir une première ligne qui sera lenté. Donc on utilisera un théade, un hop, théade. Et si vous voulez aider votre éditeur pour qu'ils comprennent vraiment que vous êtes en G6, vous pouvez cliquer sur le langage qui est en dessous ici, et vous tapez React, et vous mettez JavaScript React. Ça permet d'avoir une meilleure coloration. Et quand vous tapez des non de balises, par exemple, terre et table, ça va faire ça. Donc ça, un petit peu plus pratique. Donc je vais mettre un terre, un théâche, et je vais mettre le nom de mon produit. Et ensuite, juste en dessous, on va mettre le prix. Donc là, on a notre entête. Maintenant, je vais devoir créer un tébodi et mettre mes différentes lines. Alors, le problème des lines, c'est que je dois les générer dynamiquement. On a parfois des lines qui sont d'ailleurs en bleu et parfois des lines qui sont en rouge. Donc parfois des lines qui représentent une catégorie, et parfois des produits. Donc là, il va nous falloir un petit peu plus de logique. Un attendant d'écrire cette logique, je vais maintenant pouvoir utiliser ce composant-là au niveau de mon composant principal ici. Donc on va utiliser directement le composant productable. Alors, pour l'instant, c'est vrai que c'est un peu bête d'avoir ce composant-là, vu qu'il ne sert à rien, mais plus tard, on aura juste au-dessus la partie avec le formulaire. Et on lui passera les produits, que l'on récupérera depuis les propriétés. Donc là, on fait descendre la liste des produits. Jusqu'à notre composant de tableau. Et on voit bien que l'on a le nom et le prix. Donc maintenant, ce qui va nous falloir faire, c'est construire les différentes lines. Donc pour construire les différentes lines, il va nous falloir deux composants, un composant permettra de représenter une catégorie et un composant permettant de représenter une ligne de notre tableau. Donc on va créer ces deux composants-là. Donc là, pour l'instant, on va simplement créer des fonctions. Donc on aura une première fonction qui va s'appeler producte-rope, qui permettra de représenter une ligne de notre tableau. Alors au niveau du paramètre de ce composant-là, je me dis que une propriété qui contiendrait l'ensemble des informations serait intéressante. Donc à ce niveau-là, lui, il recevra un paramètre un produit. Et ce qu'il fera, c'est qu'il retournera donc une ligne de notre tableau. C'est un TR, avec un intérieur un premier TD qui contiendra le nom du produit. Donc si on regarde la partie JSON ici, le nom du produit, ça serait product.name, un product.name, et ensuite on aurait une seconde ligne qui serait product.price, pour afficher le prix. Donc l'autre composant que l'on va avoir besoin de créer, c'est le product catégorie-ro. Donc ça, ça permet de représenter une ligne qui correspondra à une catégorie. Donc je me imagine de lui passer une propriété qui serait le nom de la catégorie, et ça ferait simplement un Richter, un petit TR, un TD qui fusionnerait de colonne. Donc là, on aurait un colspagne de deux. Alors attention, dans le cadre de React, les attributs HTML ont une apparence qui est un petit peu différente. Donc en HTML, on écrit Récolespane, mais tout est en CamelCase en React. Donc dès que vous avez des attributs, on l'a vu par exemple avec le ON-Clique, c'est ON, un minuscule, et clique avec un séme à jucule. Pour les colspans et d'autres attributs qui sont composés de deux mots, c'est la même chose. Donc on écrit plutôt les choses comme ça. Et à l'intérieur, on aurait le nom de notre catégorie, donc nous, on pourrait tout simplement mettre catégorie ici. Donc si on considère que ça, c'est une entête, parce que c'est un peu plus gros que le reste, on va utiliser plutôt un THC. Donc maintenant, on a nos deux composants permettant de représenter une ligne dans notre tableau, qui sera une ligne de produit ou une ligne de catégorie. Du coup, ce qu'il nous faut faire maintenant, c'est parcourir l'ensemble de nos produits, et remplir un tableau qui contiendra nos différentes clés. Donc on va faire une simple boucle, et on va le dire, bah si on rencontre une nouvelle catégorie, on commence par créer un product catégorie gros. Et ensuite, pour chaque ligne, on va créer un product gros. Donc là, on va créer une constante que l'on va appeler Rose. Et par des fausses, ça sert à un tableau vite. On va aussi créer une constante qui va s'appeler LAST-CATÉGORI, qui permettra de connaître la dernière catégorie que l'on a rencontrée. Maintenant, on va pouvoir parcourir l'ensemble de nos produits. Donc là, on va faire un petit forage, donc on fera product 0.forage. Pour chaque produit, on prendra par mettre le produit, et ensuite, on fora notre traitement. Donc d'abord, on va vérifier, est-ce que finalement notre catégorie est nouvelle? Donc là, on va lui dire, il product 0.4égorie est différent de la dernière catégorie, dans ce cas-là, je change la valeur de LAST-CATÉGORI pour mettre product 0.4égorie. Alors attention, j'avais déclaré que c'était une constante, ce n'est pas vrai, c'est en fait une simple variaire. Ensuite, je vais pousser dans la liste des lignes-là un nouvel élément de type product catégorie-reau. Donc là, je ferai Rose, point Pouch, et je lui demande de pousser un nouvel élément qui s'appelle product catégorie, et je lui passe le nom de la catégorie, comme ceci. Là, j'écris simplement du V6. Pour chacun de mes produits, il faut que je pousse une nouvelle ligne de produit. Quoi qu'il arrive, je pourrais faire un Rose, point Pouch, et je vais envoyer un nouveau product raw, et je lui passerai le produit, comme ceci. Donc là, je suis en train de créer un tableau qui contiendra la liste de mes différentes lignes sous forme de composants réactes. Maintenant que j'ai cette variable qui contient l'ensemble de mes lignes, je vais pouvoir l'utiliser dans mon tableau. Donc dans mon tableau, je vais lui dire ici, grâce à une expression, je veux que tu affiche les différentes lignes. Si je sauve garde et que je regarde au niveau de ma page, je vais avoir ici une petite erreur. Il me dit que catégorie n'est pas définie, effectivement, attention, là, c'est product point catégorie. Donc je sauve garde et j'ai bien mon résultat. On voit sporting good ici avec la liste des éléments et ensuite electronics avec la liste des éléments. Par contre, il faudrait que j'affiche en rouge. La partie, par exemple, basketball parce que ce n'est pas en stock. Donc là, ce que l'on va faire, c'est que pour la partie, non, on va peut-être créer une variable. Et on lui dirait d'entourer d'une spagne qui aura la classe texte d'anger pour mettre de la couleur rouge. Donc on va créer une constante que l'on va appeler name et on lui dirait que si le produit est en stock, dans ce cas-là, on renvoie simplement product point name. Dans le cas contraire, on utilisera une spagne et sur cette spagne, on rajoutera une classe texte tirée d'anger. Et à l'intérieur de cette spagne-là, on mettra product point name, le nom du produit. Donc on va aller juste à la ligne pour un petit peu plus de clarté, mais vraiment là, vous de voir ce qui vous semble le plus intéressant. Maintenant, je peux à la place de la partie product name ici. L'huile, j'aimerais bien que tu utilises le composant que j'ai défini au-dessus. Et on voit bien que la partie basketball et iPhone 5 apparaient en rouge. Alors d'ailleurs, si vous n'utilisez pas de frein morque cesse-essence, vous pouvez utiliser la attribution style pour définir le style. Et vous pourriez mettre ici color.red Et on s'imagine que ça fonctionnerait. Pourtant, le résultat n'est pas celui que l'on attend. En fait, pour la partie style, lorsque vous la précisez, il faut la préciser sous forme d'objet. D'ailleurs, ici, vous allez lui dire, c'est un objet. Et je vais lui donner color.red. Et dans ce cas-là, ça fonctionne convenablement. En revanche, faites attention. La clé, ce n'est pas la propriété SSS. C'est-à-dire que si vous voulez faire un bas grand de color, ça ne sera pas comme ça, mais ça sera comme vous le feriez avec la définition d'estil. Donc c'est toujours un camel case comme ceci. On nous va rester sur le cas simple. On a tout simplement l'utilisation de la frein morque ici. Donc on utilise texte tirer d'anger. Et vous voyez que ça fonctionne convenablement. Alors, le petit détail ici, c'est qu'on nous dit attention. Chaque enfant doit avoir une clé. Et ça, c'est important. Donc ça permet à rien, que lorsque il y a des changements, et par exemple, lorsqu'on filtera les données, de ne pas récrasser tout là, on met simplement de savoir quel élément il doit changer. Donc pour traquer ça, il a besoin de définir une clé sur chaque élément. Dès que vous lui passez lors d'une expression un tableau d'élément, il faut que chaque élément dans ce tableau est une clé. Sinon, vous allez toujours avoir ce petit warning ici. Donc moi, ce que je vais faire, c'est que pour les produits, la clé, ça sera le nom du produit, vu qu'on n'a pas de produit qui a le même nom. Et pour les catégories, je mettrai le nom de la catégorie tout simplement. Donc là, on va rajouter une clé, et on dirait que la clé, c'est product.categorie. D'ailleurs, on peut utiliser l'asde catégorie, vu qu'on l'acrée juste avant. Comme ceci. Pour la partie producte-ro, on lui dirait que la clé, c'est le nom du produit. En product.net. Donc faites bien attention, il est important que cette clé soit unique, sinon vous allez avoir des problèmes, mais on voit que dans notre cas ici, on a plus d'alerte, notre liste de produits fonctionne convainement. Donc là, on a fait ce premier composant. Maintenant, on avait l'autre composant qui était le petit formulaire tout en haut. Et on avait dit que ce composant-là allait s'appeler search bar. Donc on est parti, on va aller créer cette partie search bar. Vu qu'ici, on va avoir un petit peu plus de logique, je vais plutôt créer une classe. Donc je vais créer une classe search bar qui va étendre de React.comp. À l'intérieur, je vais avoir ma fonction Render, qui va permettre de rendre mon formulaire. Donc pour l'instant, je ne m'occupe pas de la partie logique. Je vais juste faire un sorte que mon formulaire s'affiche convenablement. Donc je vais créer une dive qui aura comme classe forme groupe. Alors, peut-être, je vais y entourer tout d'une dive, qui me permettra peut-être de mettre un padding plus tard. À l'intérieur, je vais créer une dive qui aura la classe Forme Thierry Group. Et à l'intérieur, je vais créer mon input qui aura la classe Forme Thierry Ctrl. On mettra un play-solder qui correspondra à ce qui est émis dans l'exemple. Donc ici, ils ont mis search et ils vont mettre à rechercher. Donc play-solder égal recherchait. Et ensuite, on crée notre checkbox. Donc on va peut-être créer un nouveau forme groupe ici. Et on lui donnera plutôt la classe Forme Check. On mettra un input de type checkbox. Vous voyez un d'avoir mis l'auto-completion en mode React GSX. Ça nous simplifie quand même pas mal la tâche. Parce qu'on peut utiliser les raccourciques ou on a l'habitude d'utiliser. Donc là, l'idée, ça se rassaut. Et ensuite, je crée le label qui va être associé. Donc il aura la classe Forme Thierry Group, Thierry Label. Et on lui donnera en niveau de l'HTML For, que c'est le label pour la partie stock. Et on mettra produit un stock seulement. Voilà. Donc maintenant, ce composant, je vais pouvoir l'utiliser au niveau de mon composant principal, qui est la table filetrable. Donc on peut utiliser une dive pour englober tout ça ou on peut utiliser le système de fragment, qui permet d'en glober plusieurs éléments, sans forcément avoir un élément HTML qui correspond. Donc là, je vais mettre un React.fragment. Voilà, parce qu'on ne peut pas utiliser le petit raccourci comme ça. Ça ne marche pas dans le cas de Babel. Et là, à l'intérieur, je vais pouvoir utiliser mon système de recherche. Donc c'est sur tu bars. Et pour l'instant, c'est un composant qui n'a pas besoin de propriété. Donc là, on arrive maintenant à une petite partie problématique. Idealement, quand je tape ici une recherche, j'aimerais bien que ça ont tant réel, ça me filtre mes produits. Donc ça veut dire que la partie producte table, elle doit être au courant de ce qui a été tapé, du filtre qui est actuellement utilisé. Dès la même manière, il faut que ma search bar soit capable de faire remonter les changements. Du coup, on va s'imaginer que ce composant-là, il devra maintenir un état qui sera l'état actuel du filtre. Donc on va tout de suite créer le constructeur qui prend en paramètre les propriétés. Et on appelle la méthode parante. Tout de suite, on va définir l'état. Et donc l'état il est double. On a filter texte qui permet de connaître l'état du texte. Et on va avoir in stock only, qui permettra de savoir si, pour l'instant, on ne veut voir que les produits qui sont in stock ou non. Maintenant que j'ai cet état-là, je vais pouvoir le faire passer à search bar. Donc là, au niveau de search bar, je vais lui donner filter texte. Et ça sera directement visp.state.filtertexte. Et je vais lui donner aussi, alors peut-être aller à la ligne, pour pas avoir une ligne trop longue, in stock only. Donc je vais dupliquer cette ligne-là et utiliser in stock only. Ensuite, on va pouvoir changer la valeur. Donc qui est responsable de ce changement? C'est ce composant-là. Vu que c'est lui qui a l'état, c'est lui qui devra avoir les fonctions qui permettront de changer la partie filter texte et la partie in stock only. Donc là, on va créer une première fonction qui va s'appeler un dole filter texte change. Et ça sera une fonction qui prendra en paramètre le nouveau texte, pour l'appelera filter texte, et qui changera la valeur de filter texte pour la nouvelle valeur. Et là, on peut écrire les choses comme ça pour gagner un peu de temps. On va avoir la même fonction, mais qui va permettre de changer le in stock only. Comme ceci. Pour éviter tous les problèmes avec VIS, dès le début dans mon constructeur, je vais lui dire que VIS.handle filter texte change est égal à VIS. Vous avez compris le principe, ça, ça sera toujours la même chose pour éviter les problèmes. Et on fait ça à ce niveau-là aussi pour la partie in stock only. Donc on va l'appeler, handle in stock change. Donc ces deux fonctions vont permettre à search bar de faire remonter les informations. Soit search bar, il va prendre de nouvelles propriétés. Une première qui s'appellera on filter texte change. Et nous, on lui passera de notre fonction ici. Alors là, c'est une convention dans réacte lorsque vous avez des choses qui sont liées à des événements. Vous allez toujours les préficser par on. Et pour la partie stock, vous allez mettre on stock change et vous ne lui passeraz cette fonction-là. Voilà. Donc là, le composant par un va bien envoyer à search bar toutes les informations montées la besoin. Et là, il va falloir travailler dans search bar pour faire remonter les informations et utiliser aussi les informations qui sont disponibles ici. Alors juste pour tester, on mettra juste ici foot et au-dessus à ce niveau-là, on fera un gson.stringify de state pour voir si à ce niveau-là, les choses remontent bien. Donc maintenant, on peut replier ce composant-là et on va travailler dans notre search bar. Donc au niveau de search bar, je vais avoir besoin de récupérer le texte et le l'état du produit depuis les propriétés. On peut utiliser encore une fois la destructuration. Donc nous, on va l'appeler filter texte et en d'extructeur aura aussi, comme on avait appelé, j'ai une mémoire de poissons rouge, Instaconly. Voilà. Donc c'était à ce niveau-là. Et on récupère à ça, depuis vies points props. Maintenant, au niveau de mon input de type texte, je peux lui donner comme valeur le filtre qui a été demandé. Donc ce sera filter texte. Au niveau de match-checkbox, on peut lui dire de coucher les choses. Donc on mettra à checked. Et on lui dirait que ce sera couché seulement si Instaconly. Voilà. Donc si je réactualise, on voit bien que foot a été pré rempli. On a des erreurs qui nous disent attention que tu as mis une valeur sans en change. Donc ça a pris le problème qu'on a bien à la fois. C'est-à-dire ça bloque les choses. Si je mets le Instaconly à trou, ici, je vais voir que c'est bien couché. Donc maintenant ce qui nous faut faire, c'est faire remonter les informations grâce à nos deux événements qu'on lui a envoyé, un filter texte change et un stock change. Donc on va créer au niveau de ce composant de fonction. Une première qui va permettre de gérer le changement en niveau du filtre et une seconde qui va amétera de gérer le changement au niveau de la checkbox. Donc à ce niveau-là, hop, on est reparti. Donc je vais créer une fonction qui va s'appeler un del filter texte change et c'est une fonction qui prendra un paramètre cette fois-ci l'événement. Ce que cette fonction fera, c'est qu'elle fera simplement remonter les informations aux composants par a, au travers de l'événement, un filter texte change. Donc ici, je pourrais faire un vise.prox.one filter texte change, donc c'est la propriété que j'ai reçu et je lui envoie la valeur que j'ai récupéré dans mon champ. Pour éviter les problèmes avec vise, dès le constructeur, hop, je vais faire un super de props et un vise.andle.filter texte change et galvis.andle.filter texte change.indv Maintenant que j'ai cette fonction au niveau de ce composant-là, je vais pouvoir l'utiliser dans le OnChange de cet input. Donc à la fin ici, je vais rajouter un OnChange et je vais lui dire que la fonction qu'il doit appeler c'est Andle.filter texte change. Si j'orce sauvegard et que je tape quelque chose, on voit bien que les informations remontent. Alors on va faire une petite pause pour récapituler ce qu'on a fait. Notre composant de recherche, il va avoir besoin de permettre à l'utilateur de taper des choses, mais il va aussi devoir informer le composant-paranc qui y a eu des changements. Donc ce composant-là va recevoir deux choses, la valeur et va recevoir aussi le callback à appeler lorsque un changement a été effectué. Au niveau du composant-paranc, mais on va pouvoir avoir un état et on pourra lui donner un Andleur qui va permettre de gérer les changements d'états. Donc le fait de lui envoyer la valeur permet de faire descendre l'information dans un composant-enfant et le fait de lui passer un callback permet aux composants-enfants de faire remonter de l'information. Donc c'est toujours le même système que vous allez avoir. Soit vous avez besoin de passer de l'information vers les composants-enfants et dans ce cas-là, vous allez simplement passer une propriété qui contiendra la valeur et les enfants ragiront en fonction de cette valeur. Soit vous avez besoin que les composants-enfants informent les composants-parancs d'un changement et dans ce cas-là, vous allez devoir utiliser des callback et faire remonter l'information de cette manière-là. Donc là, on le voit en faire remonter l'information avec trois niveaux. L'input fait remonter l'information grâce au un change et le search bar fait remonter l'information grâce à son un filter text change. Et vous avez comme ça une information qui remonte de composants-enfants-enfants. Donc maintenant, il faut faire la même chose mais pour cette petite case-là. Donc c'est le même principe. On va les créer ici une nouvelle fonction qu'on va appeler un dole Instock Change qui prend en par-a-mettre l'événement et ça fera un vise.prox.onStockChange et on récupéra l'Etat de la coche. Est-ce que c'est coché ou non ? Ensuite, tout à l'heure, je fais le vise.byinVise que d'habitude pour éviter les problèmes avec le contexte. Et maintenant, lorsque la checkbox change, je vais pouvoir le dire, lorsque la checkbox change, il faut que tu appelles vise.onsandolInstockChange. Ça va appeler ensuite le InstockChange et faire remonter l'information jusqu'au composant-par-a-moi. Donc je s'en fasse garde, j'essaye de cocher la calme et on voit bien que ça change. Donc là, on a fini avec notre optis-systeme de recherche. Je vais peut-être changer légèrement les choses, lui préciser ici que on aura un MB tiré 0 pour ne pas avoir de marge en bas. Et par contre, rajouter une classe ici, MB tiré 2 pour mettre un petit peu d'espace en dessous de notre formulaire, ou même on peut se dire que c'est peut-être un petit peu 6 et rajouter un petit peu plus. Voilà. Donc là, on a notre optis-systeme et ça remonte bien. Ce qui va nous falloir faire maintenant c'est passer les informations du filtre, l'Etat de notre filtre, à l'autre composant celui qui affiche la liste de nos produits. Là, on a juste besoin de lui passer filtre texte et Instoconly. Donc, au niveau de mon producte table, je vais rajouter ses nouvelles propriétés. Donc la première s'appellera filtre texte et je lui passe filtre texte et la seconde s'appelle Instoconly et on lui passera Instoconly. Alors attention, ça c'est au niveau du state. Donc, pensez à mettre VIS.state sinon ça ne va pas fonctionner. Donc je sauve garde, ça ne change rien. Je vais peut-être enlever ici le gson.stringify ou un limite, on va le laisser pendant la phase de débug. Et maintenant, au niveau de notre liste de produits, la seule chose qu'il va falloir faire c'est changer notre manière de faire la boucle. Donc là, on a envoyé systématiquement tous les produits. On va plutôt mettre une petite condition, les disant, finalement, si cette colonne ne correspond pas au filtre, on rite, et on ne va rien pouche. Donc au niveau de nos propriétés, on recevra Instoconly et on recevra Filter Texte. Alors on va d'abord juste gérer la partie produire Instoc seulement. Donc ici, on lui dira If Instoconly et Trou. Donc on sait que c'est un bouleur. On a pas forcément besoin de faire égal et galentrou. Donc si on a effectivement la demande d'un stock et que le produit point stocked est égal à false, alors là c'était toujours un bouleur. Donc on peut mettre et le produit n'est pas en stock. Mais dans ce cas-là, on rite. Ça veut dire qu'on saute ce produit-là, il n'est pas en stock, il ne correspond pas à notre filtre. Donc on ne peut pas la fichée. Je vais réactualiser ma page. Je clique ici sur l'affichée que les produits est en stock et on voit bien que nos deux produits disparaissent. Pour notre partie Filter Texte, ça va être un petit peu le même principe. On va lui dire If Product.Name.indexoff du texte qui a été demandé. Si ça, c'est égal à moins 1. Ça veut dire qu'on n'a pas du tout trouvé parce qu'il a été demandé. Et dans ce cas-là, on rite en aussi. On saute ce produit-là. Donc après, vous pouvez combiner ces deux choses-là. En mettant des petites parenthèses, en utilisant 1, cette condition-là. Faites attention à bien mettre des parenthèses. C'est une pas forcément nécessaire. Vu qu'on a qu'une seule condition, dans ce cas-là, je rite. Donc si quelqu'un t'app fout, on voit que ça n'a fiché que les éléments qui ont rapport avec le football. Si je t'appille, ça me donne que les produits qui commencent ou qui contiennent un I, et donc ça me donne l'ipod Touch ou l'iphone 5. Si je veux retirer la partie iphone 5, je peux cocher cette case-là et je n'ai que l'ipod Touch qui apparaît. Donc là, on a mis en place un système de filtre produit. Et là, vous le voyez, ça vous permet de créer quelque chose qui serait quand même assez compliqué à mettre en place avec du JavaScript Brute. Ça obligerait à faire pas mal de traitement, à savoir quelle ligne doit supprimer. Là encore une fois, on se concentre sur les états et automatiquement les informations et l'interface utilisateur et adapté en fonction de notre état. Je vais juste retirer la partie gison de Point Stringify et ne sert plus à rien. Donc là, c'était à ce niveau-là et on aura fini avec cet exemple-là. Donc l'objectif de cet exercice c'est de vous montrer comment va s'opérer la communication. Avec React, c'est très important. On va essayer de décomposer notre structure en différentes composants pour pouvoir travailler plus simplement. On pourrait, ce n'est pas forcément très efficace, mais créer un seul composant qui continueraient toute la logique. Le problème, c'est que ça deviendrait très compliqué et si on a des petits changements à faire, ça devient assez problématique. Donc on va essayer lorsqu'on a une nouvelle problématique avec React, de décomposer les choses en composant et ensuite on va réfléchir où est ce que l'on place l'état et comment les choses communiquent les unes avec les autres. Donc c'est toujours le comportement qu'il faudra avoir. D'abord, on réfléchit quels composants on va créer et quels sont les éléments qui composent notre interface. Une fois qu'on a résolus cette problématique-là, on va supposer une seconde question où est-ce que réside l'état? Est-ce que certaines composants vont être responsables de leur propétat? Ou non. Nous, dans notre cas, c'est le composant principal qui est responsable de l'état. Les autres composants, finalement, ne sont pas responsables de quoi que ce soit. Ils prennent un paramètre des propriétés et agissent un fonction. Mais le cerveau de l'opération, c'est ce composant filterable producte table qui va se charger de connaître le filtre qui a été demandé et qui va le transmettre aux autres composants. Et c'est lui qui permet de faire communiquer notre search bar et notre producte table. Donc c'est une des solutions. Il n'en existe d'autres effectivement. Mais voilà, ça vous permet de voir comment se passe cette communication. Et je le répète encore une fois. Vous pouvez faire descendre de l'information grâce aux propriétés et faire remonter de l'information grâce aux propriétés en utilisant des handler et des callbacks. C'est comme ça que l'on va travailler avec Rias. Maintenant que vous avez bien compris les différents principes de base jusqu'au propos de s'édexplorer un petit peu plus en profondeur certaines spécificités et certaines fonctionnalités avancées de Rias. Parce que là même si on n'a pas vu grand chose, vous voyez que c'est déjà puissant, mais il y a quelques petites particularités qui nécessite d'aller un petit peu plus en profondeur sur le fonctionnement du freymorque. Donc je vous donne rendez-vous dans une prochaine chapitre.