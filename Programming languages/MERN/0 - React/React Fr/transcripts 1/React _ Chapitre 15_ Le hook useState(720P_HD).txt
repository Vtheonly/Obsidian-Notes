 Dans ce nouveau chapitre ainsi que les chapitres suivants, nous allons découvrir les hooks sur React. Donc les hooks sont un ajout qui est relativement récent, ils ont été ajoutés dans la version 16.8 de React et ils permettent d'ajouter certaines fonctionnalités aux composants qui s'en définissent sous forme de fonction. Là, ils résolvent deux problèmes principaux. Le premier et en l'abut dans les chapitres précédents, c'est que lorsqu'on en crée un composant sous forme de fonction, ce composant peut prendre effectivement des propriétés, mais il n'est pas possible de lui donner un étal local. On doit créer une classe qui est extensible de React Component et à l'intérieur on peut faire appel à State et 7 states. Et c'est un peu dommage, je ne peux pas utiliser les fonctions pour ça. L'autre problème, il va se voir lorsqu'on va commencer à créer véritablement des applications avec React, c'est que souvent, on a les mêmes manipulations d'État à faire. Et vu qu'on utilise le système de classe, ce n'est pas forcément évident d'extraire les choses. Pour vous illustrer le problème, j'ai ici créé deux petits composants, un qui permet de récupérer une liste de tout d'où, depuis une pays sous forme de liste et un autre qui permet de le faire sous forme de tableau. Le problème, c'est que finalement, la logique à l'intérieur du composant, la logique qui permet de changer l'État, elle est relativement similaire. Mais on ne peut pas l'extraire en dehors de cette classe-là et, du coup, on se retrouve, très souvent malheureusement, à devoir répéter de la logique entre les différents composants. Et ça, c'est pas forcément idéal. Donc ça, c'est un problème que va permettre de résoudre les oeufs. Donc, ce que je vous propose de faire, c'est de les découvrir à travers un petit exemple simple et on va repartir de zéro. Donc je vais supprimer l'effiché que j'ai créé juste pour vous démontrer les choses et au niveau de notre index.gx, on va simplement mettre le code de base. Et imaginons, on va reprendre le premier exemple que l'on a fait avec le compteur qui s'incrémentez. Donc on va créer un nouveau composant que l'on va appeler compteur et ce composant va donc avoir un État qui permettra de mémoriser le compteur. Donc, juste au dessus, je vais créer une fonction qui s'appelle compteur. Et cette fonction retournera simplement un petit bouton qui continuera le compteur. Et là, on a un petit peu embêté parce que vu qu'on a créé une fonction, on ne peut pas définir d'État locaux. Donc on va pouvoir le faire grâce justement à cette nouvelle ajout qui est le OOK Use State. Alors OOK ne vous formalisez pas trop, c'est juste un nom qui a été donné à cette nouvelle à pays de React. En fait, c'est une série de fonctions qui commence par Use et qui permettent de rajouter des fonctionnalités qui ont attrées à l'État ou au cycle de vie de notre composant. Donc le premier ou que l'on va découvrir, c'est le OOK Use State. Ça va permettre de dire que cette fonction va avoir besoin d'un État. Donc on fait Use State et c'est au niveau de React. Donc si vous utilisez React importé depuis l'extérieur, vous pouvez être un React.useState. Et si vous utilisez le système d'Emport, vous pouvez directement importer Use State comme ça. En premier paramètre, vous allez lui donner une valeur initiale. Moi par exemple, mon compteur va commencer à la valeur 0. Une fois que vous avez fait ça, cette fonction va retourner un tableau de type 2 qui contient en première valeur l'État et en seconde valeur la fonction qui va permettre de modifier l'État. Donc nous, pour l'instant, on va simplement sauvegarder le résultat dans une variable que l'on va appeler State et ensuite on va faire un console point log, vu que c'est la première fois que l'on travaille avec, pour voir de quoi il en retourne. Et je sauvegard tout de suite. Donc je vais me rendre sur ma page web et je vais sortir mon inspecteur. Si je regarde dans la partie console, j'ai un tableau de type 2. Dans ce tableau, j'ai une première valeur qui contient la valeur de mon État. Lui que j'ai dit initialement sa vée la valeur 0, je me retrouve bien avec 0. En seconde valeur de mon tableau, j'ai une fonction qui permettra de changer la valeur de l'État. On se qualifiera lorsque l'on travaille avec les UseStint et ce ou-là, c'est que directement on va utiliser la destructuration et on récupérerra directement la valeur de coute et ce qui va permettre de changer la valeur cette fonction. Au niveau de notre bouton, on va pouvoir dire nombre suivi de la valeur du coute. Donc pour l'instant, ça fonctionne bien, ça nous donne la valeur 0. Mais j'aimerais bien qu'on se clique que ça vient de changer la valeur du nombre. Dans ce cas-là, on va directement créer une fonction en double-click que l'on va mettre dans notre fonction. Il n'y a pas de problème à ce niveau-là. Elle prend en paramètre l'événement. Ça fera un E.20 des fold. Vous n'avez même pas besoin d'utiliser la fonction fléchée ici. Vous pouvez utiliser une fonction classique. Il n'y a pas de contexte de vis. C'est aussi un des avantages de ne pas utiliser les classes. Et ensuite, à l'intérieur, je pourrais faire un 7 counts. Donc c'est la fonction qui est renvoyée en deuxième valeur de notre tableau. Et on lui passe la nouvelle valeur de l'Etat. Donc moi, ce que je peux faire ici, c'est mettre 10 par exemple. Maintenant que ce mandeur est créé, je peux lui dire au niveau du bouton. Je veux que lorsque tu clique, tu appelles en double-click. Si je s'affigue, dès que je réactualise ma page, lorsque je clique sur nombre 0, je vois bien que ça passe un nombre 10. Alors, ça peut paraître surprenant et pronon le temps de réanalyser ce qui a été écrit ici. Lorsque l'on fait un user state, automatiquement, ça va créer un État et ça va sauvegarder la valeur qui correspond à l'Etat dans la première clé. Ensuite, un seconde clé, ça nous donnera une callback que l'on pourra appeler, dès qu'on veut modifier l'Etat. Dès que ce callback est appelé, ça va redéclencher un rendu. Ça veut dire que ça va redéclencher la peine de cette fonction-là. Ou dans le cadre du second appel, la valeur de coute sera changée vu qu'on a fait un 7 counts à 10. Et du coup, le nombre qui sera affiché ici sera égal à 10. Si on regarde dans l'inparti inspecteur, donc si on s'en sort notre composant, je regarde l'Etat de mon compteur. On voit ici qu'il me montre l'Etat de mon compteur, mais il ne me montre pas la partie state. On a un nouvel anglais qui s'appelle x qui nous montre les différents x. Pour l'instant, on a un seul x qui est le x qui contient notre nombre. Et on voit qu'il me dit à ce moment-là l'Etat est à 10. Maintenant, on peut se dire comment il fait pour savoir que ce compteur est à 10, et si on en a plusieurs, comment il traque les choses ? Parce que finalement, c'est la même fonction. Comment il est capable de dire que celui-là doit être à 10 mais pas l'autre. Alors en fait, lorsque vous faites un user state, en interne, ce que fait React, c'est qu'il dit OK. Là, je vais créer un étape pour le composant qui est actuellement en train d'être exécuté. Donc c'est ce qui lui permet, grâce au contexte d'exécution, de savoir que ce user state fera référence à l'Etat de notre compteur. Il voit aussi que c'est le premier appel à user state dans cette fonction. Donc c'est l'ordre d'appel qui lui permet de savoir et de retrouver la correspondance. Ça nous amène à une réglème importante. Un user state ne peut pas être dans une condition uniboucle. C'est important, parce que si vous faites ça, ça peut changer l'ordre des appels, et du coup ça peut poser des problèmes au niveau du fonctionnement de D.O.K. Ensuite, autre optie d'étaille, à l'intérieur du user state, vous pouvez avoir n'importe quoi. On va supprimer ce qu'on a écrit ici, et on va s'imaginer simplement qu'il y ait une dive, et dedans on affichera une valeur qui s'appelle state. Donc je vais recommencer et on va s'imaginer récupérer un state et un set state. Et cette fois-ci, on fera un user state, et on lui dirait que la valeur initiale, c'est un objet. Et plutôt là, on va déveuger cet objet-là. Donc si je sauve garde, je vais voir que j'ai un objet vide. Maintenant, on s'imagine que lorsque je clique, je vais changer la valeur de cet objet. Donc on va lire un clic en del-plique. Et à l'intérieur, on va avoir donc notre fonction en del-plique, qui sera une fonction qui prend un paramètre l'événement, qui fera le prévent des fold. Je ne vais pas du tout supprimer. Et ensuite, je fais un set state et je change l'état. Je lui dis par exemple que maintenant, le coute sera égal à 10. Si je sauve garde et que je réactuise ma page, lorsque je vais cliquer sur ma dive, on voit bien que ça change et ça crée un objet qui a comme clé coute qui vaut 10. Détai important, contrairement aux sets states, il n'y a pas de fusion d'objets. C'est-à-dire que si mon état initial était un objet qui contonnez une valeur arbitraire, lorsque je clique, on voit qu'il change complètement les choses. Par rapport au set state que l'on avait au niveau de nos composants, c'est complètement différent. Si jamais je veux réécraser et rajouter une clé supplémentaire, il faudra plutôt que je lui dise. Là, je vais avoir une fonction qui prendra l'état précédent et qui retournera le nouvel état auquel je rajoute la clé coute qui vaut 10. Et dans ce cas-là, on aura bien une fusion avec les états précédents. Si je reclique, ça me donne bien coute 10 en plus de l'état initial. Donc faites bien attention, il y a une grosse différence entre le modifier d'état des OUK, du modifier d'état avec les classes. Ce qui est aussi super intéressant, c'est que vous pouvez créer plusieurs appeles à ISO state. On va s'imaginer qu'on a à l'intérieur de bouton. On va créer un premier bouton qui permet d'incrémenter. Donc on va mettre incrémenté, suivi du compteur, donc on va le renommer compte comme tout à l'heure. Et on s'imagine aussi qu'on va créer un autre bouton qui permettrait d'incrémenter une autre valeur. C'est juste pour l'exemple, ça part vraiment de sens, mais on aurait un second compteur qui s'appellerait compte 2 et qui lui s'incrémenterait de 2 en 2. Je vais maintenant créer un premier compteur et je vais avoir la méthode qui permettra de le modifier qui s'appelle 7 coute. Au niveau du state, plutôt que d'avoir un objet, je mets simplement une valeur comme ça. Ensuite, je crains le second compteur qui s'appelle compte 2, qui aura du coup un seteur qui s'appellera 7 coute 2, et qui aura aussi comme valeur initiale 0. Automatiquement, j'ai bien mes 2 boutons. Je vais d'ailleurs supprimer le second compteur, ce sert à rien. Maintenant, je vais créer mes deux fonctions qui vont permettre de gérer le clic. Donc on va l'appeler handle clic. Ce sera une fonction qui prend en paramètre l'événement, qui annulera le comportement des faux et qui fera un set compte et qui incrementera la valeur. Donc là, on pourrait être tenté de faire compte plus un, mais attention, comme on l'avait vu lorsqu'on a parlé des 7 states au niveau des composants sauf en deux classes, lorsque vous modifiez l'état à partir d'une propriété ou d'un état précédent, mieux vous utilisez un callback. Ça évite lorsque réacte groupe les choses d'avoir des problèmes. Donc là, l'émide, vous pouvez écrire les choses comme ça, c'est encore plus rapide. Ensuite, je vais créer une autre fonction qui va s'appeler handle clic 2 et cette fonction, elle va modifier l'autre compteur en faisant un set compte 2 et un increment entre deux en deux. Maintenant, au niveau du premier bouton, je vais lui dire lorsque tu cliques, je veux que tu fasses un handle clic et lorsque tu cliques sur le second bouton, je veux que tu fasses un handle clic 2. Si je regarde au niveau de ma page, on voit bien que mon compteur a 2 oucs, donc le premier ouc qui permet de se regarder l'état et le second ouc qui permet aussi de se regarder cet état-là. Je clique sur le premier et automatiquement, ça change l'état du premier ouc pour mettre la valeur 1. Si je fais incrementer 2, là c'est le second ouc qui change de valeur et automatiquement, il change la valeur. Ce qu'il faut bien comprendre, c'est qu'à chaque fois que vous faites un set ou n'importe quoi, automatiquement cette fonction est entièrement rappelée. C'est à dire que si je fais un console point lock de Render, comme quand on change les propriétés au final, dès que je clique automatiquement, on va voir de nouveaux Render qui vont avoir lieu. En fait, react va en interne, c'est le premier ouc qui a été appelé, donc j'ai gardé une trace de l'état précédent et automatiquement, je te remet dans la valeur le nouvel état. Je vous avouerai que ce n'est pas forcément une logique et très évidente, c'est assez original en termes de fonctionnement mais n'hésitez pas à faire des petits d'expérimentations et à regarder ce que vous pouvez faire à partir de ces outils-là pour bien comprendre comment il fonctionne. Maintenant, on peut se dire qu'est-ce que va apporter cette syntaxe-là, moi, à première vue, d'après ce que je vois, ça l'ère plus compliqué que la proche précédente. C'est moins lisible, je préfère peut-être la proche par classe. Ce qui est très intéressant avec les outils, c'est qu'on va pouvoir extraire une partie de la logique dans des fonctions et pouvoir exploser des outils personnalisés. Pour vous montrer un tout petit exemple, on s'imagine que de nombreuses reprises dans notre application, on a besoin d'incrémenter des valeurs. Je peux me faire un outil qui va s'appeler UseIncrémenté qui permettra de garder cette logique-là. Un outil est simplement une fonction que l'on va affixer par Use. C'est juste une convention de React et on va l'appeler UseIncrément. À l'intérieur de cette fonction, je peux appeler des outils. Je peux lui dire que je vais créer une valeur de coute qui sera à l'état et je fais un set coute. Et je utilise un intérieur, le look de React UseState. Maintenant, je vais créer une fonction qui va s'appeler Increment. Qui permettra d'incrémenter une valeur. Cette fonction ce qu'elle fera, c'est qu'elle fera tout simplement un set coute. Elle prend un paramètre la valeur et elle fera une incrementation. Enfin, en retour de cette fonction, je vais envoyer un tableau qui sera le coute et qui sera ma fonction incrementée. Et je garde la partie set coute à l'intérieur de cette fonction. Maintenant, ça me permet si je souhaite avoir quelque chose d'incrémentable de pouvoir faire une constante. Je récupérer coute et incremente, qui sera la fonction d'incrémentation, et je ferai un UseIncrément. Et je mettrai aucune valeur parce que la valeur initiale, c'est toujours 0. Et au niveau de mon bouton, je lui dis quand tu pliques, je veux que tu appelles Increment. Et ça nous permet maintenant quand on regarde le code de ce composant-là, d'alléger la logique. Toutes la logique qui a très aux changements d'État est extrait dans une autre fonction, qui est un hook personnalisé. Et comme ça, ça rend le code à l'intérieur du composant un petit peu plus léger. Si je essaye de regarder, que je clique sur Increment, ça s'incrémente bien de 1 an. On pourrait même avoir des variants dont on pourrait lui dire, ben là, je pourrais avoir la valeur initiale et le pas par exemple. Donc on mettrai ici initial et le step. On lui dirait, ah, ben lorsque tu fais un UseState, tu donnes la valeur initiale et lorsque tu es increment, je veux que tu utilises la valeur de step. Et automatiquement, on a maintenant quelque chose qui permet d'incrémenter de 2 en 2 et on peut avoir un hook personnalisé qui prend des paramètres et qui permet de faire des traitements un petit peu plus poussés. Et ça nous permet d'isoler une partie de la logique en dehors du composant. Ne vous inquiétez pas si vous n'êtes pas forcément encore à l'aise avec ce découpage. On va revenir dessus encore et encore parce qu'on va découvrir de nouveaux hook qui vont aussi ouvrir de nouvelles perspectives au niveau des hook personnalisés. Ce qu'il faut retenir, basiquement, c'est que lorsque vous faites appel à UseState et il va créer une variable qui va être self-guarde comme l'état du composant. Et tout au long de la vie de ce composant-là, ce hook va permettre de mémoriser la valeur. Donc à chaque fois qu'il y a un nouveau rendu, la fonction est réappelée, mais grâce à UseState, automatiquement réacte connaît la valeur précédente et dans votre première valeur, il mettra la valeur qui correspond à l'état. Le second paramètre, c'est toujours un 7h qui va permettre de changer la valeur de l'état. Donc comme pour la fonction setState, si vous faites une mutation qui dépend de l'état précédent, vous verrez utiliser un callback. Et contrairement à setState par contre, dès que vous faites un changement d'état, vous devez lui passer un nouvel objet. Il n'y a pas de fusion comme ça pouvait être le cas sur cette state. Ensuite, quelques règles importantes. Vous ne pouvez pas changer l'ordre des UseState, sinon ça perd complètement réacte. Réacte utilise le ordre d'appel pour savoir à quel état correspond chaque appel à UseState. Donc si vous changez l'ordre suite à des conditions ou des boucles, vous allez avoir des problèmes. L'autre chose, c'est que si jamais vous décidez d'extraire, mais on aurait le temps d'en reparler dans les prochains chapitres, comme je l'ai fait ici, vous ne devez faire appel aux hook de React, que dans des hook personnalisés, que dans d'autres fonctions qui agiront comme des hook, vous ne pouvez pas le mettre dans n'importe quel fonction de votre système. C'est très très important, sinon ça crée à des problèmes. Mais je pense que vous voyez ici, qu'on a un petit avantage, si on prend notre composant de compteur, par rapport à ce qu'on aurait pu écrire avec toute une classe, finalement, la logique de ce composant est extrêmement simple. Là, on a un composant qui permet de créer un bouton qui va s'incrémenter et on a que deux lignes à écrire. Parfait que les classes ont des objectes de faire un set state, on sera obligé de faire le state, on aurait le render, on aurait tout de suite une structure qui serait un petit peu plus compliqué. Ce qui est intéressant, on l'a aussi, c'est que, si on décide de changer la structure pour mettre un lien ou créer un autre composant, on peut récupérer de la même logique avec une fonction de rendu qui serait complètement différente. Et ça, c'est plutôt intéressant à ce niveau-là. Là, on pourrait avoir un compteur qui fonctionnerait sous forme de lien. Hop ! Et là, hop ! C'est un lien qui s'incrément de deux en deux. Encore une fois, si vous avez un petit peu du mal avec le UserState, ne vous inquiétez pas, on va en reparler dans les prochains chapitres au fil du temps, au fur et à mesure qu'on découvre de nouveaux oucs. Donc je vous donne rendez-vous dans le prochain chapitre.