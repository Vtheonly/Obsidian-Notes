 A bienvenue dans ce nouveau chapitre où nous allons parler de l'utilisation des événements sur React. On va avoir la possibilité de décuter certaines événements qui vont se dérouler sur certains éléments et de pouvoir agir en fonction. On va prendre un petit exemple concret, on aimerait bien créer un incrementeur, mais cette fois-ci qui ne fonctionne pas sur un timer, mais qui fonctionne avec un bouton qui nous permettra d'incrémenter les choses. On va commencer par créer ce nouveau composant. On va aller ici créer une nouvelle classe que l'on va appeler manual, comme manual, incrementeur, désolé pour ma condensation. On va étendre du React.component, vous devriez commencer à prendre le coup, et tout de suite à l'intérieur, je vais créer mon constructeur, qui prend un paramètre des props et qui appellera la méthode super props. Alors, s'imagine ici qu'on n'a pas besoin de step ou de start, on va directement juste utiliser une valeur qui commence à 0. Pour maintenir notre incrementeur, il va nous falloir s'obgarder l'état. Donc ici, je vais faire un vis, point state, et on va s'obgarder la valeur de N avec une valeur initiale à 0. Maintenant, je crée ma fonction au Render, et à l'intérieur, je vais créer la vichage de la valeur, donc je vais créer simplement une dive qui mettra valeur suivie de N, et surtout un petit bouton qui permettra d'incrémenter les choses. Sur la fonction incrementée, je vais prendre ce que j'avais fait pour le système qui s'est créément automatiquement, et je vais lui dire d'incrémenter de un à un par contre. Maintenant, le problème, c'est que ce composant-là, on ne le voit pas, donc je vais remplacer mes incrementeurs automatiques par mon manual incrementeur. Et on le ferme comme ça. Alors, il me sort ici une petite erreur, si je regarde un console, où il me dit que N n'est pas définie. Effectivement ici, c'est vis, point state, point N, autant pour moi. J'ai maintenant mon bouton incrementé et la valeur. Donc, là, ce qu'il me faudrait faire, c'est que lorsque je clique sur un incrementé, ça bouge et appelle cette méthode-là. Donc, ce qu'on ferait sur du domme classique, c'est qu'on ferait un AD 20 les sneurs. Dans le cadre de React, on a la possibilité de faire appel aux AD 20 les sneurs, grâce aux propriétés. Donc, on a une propriété qui s'appelle ON, clique, qui va permettre d'écouter le clique. Et vous avez comme ça des propriétés qui correspondent aux différences des ventes que vous pouvez avoir au niveau du domme. À l'intérieur de ce ON, clique, vous allez devoir les donner une fonction. Donc, nous, ici, on va les dire, j'aimerais bien que tu incrementes. Alors, attention, comme pour un événement classique, vous allez perdre ici, si vous faites ça, la référence à vis. Donc, il faudra faire un bind vis. Non, ce qu'elle a maintenant, si je clique sur incrementé, je vois que la valeur s'incremente bien. Autre petite détail important, lorsque cette fonction sera appelée, elle sera appelée avec un paramètre qui sera l'événement. Si ici je fais un console point log de E, qu'est-ce que je m'attends à obtenir? Normalement, je m'attendrai à obtenir un événement de type mouse-event, de type cliquet-event. Je ne sais plus exactement. Pourtant, si je regarde, je obtiens un objet, qui est un objet un petit peu particulier, qui est ce que l'on appelle un synthétique-event. Donc, ça, c'est propre à React, vous n'aurez pas forcément sur d'autres frameworks, mais également, ce que fait React, c'est qu'il travaille avec des événements synthétiques, où vous pouvez avoir des informations au niveau de l'application, qui sont tout simplement une classe qui va enrober les événements classiques. Pourquoi? Parce que lorsque l'on travaille avec React, comme je vous disais, on peut cible les différents contextes. Nous ici, on travaille avec le dom, mais si jamais on fait du React native, on va travailler avec les éléments natifs. Donc, cette surcouche permet d'avoir une appuy qui est générique, quelle que soit la cible que vous utilisez pour mon composant React. Donc, on peut s'imaginer, avoir un composant qui fonctionne à la fois sur du dom, mais qui fonctionnerait aussi avec React native, par exemple. Donc, c'est pour ça qu'on a ces synthétiques-eventes. Au niveau de leur fonctionnement, il fonctionne assez naturellement, ça ressemble beaucoup à la pays des événements que l'on a au niveau des navigateurs. Donc, les trois quart du temps, la chose que l'on va faire, c'est faire un prévent default pour empêcher le comportement par défaut. Donc, ici, on fera un E point prévent default. Et ça permettra d'annuler le comportement par défaut. Ça serait très utile si au lieu d'avoir un bouton, on aurait un lien qui point aurait vers un site. Donc, je ne sais pas pourquoi vous aurez besoin de faire ça, mais au moins ça permettra quand on clique de ne pas se rendre sur le site en question. Si maintenant, je reviens sur ma page, et que je clique sur Incrementé, automatiquement, ça s'incrémente, ça me rediriger vers le site. Alors que si je n'avais pas le prévent default, ça incrementerait et je me retrouverai rediriger chose que je n'ai pas envie d'avoir. Donc, voilà comment vous pouvez gérer les événements, mais vous avez comme ça tout un tas d'autres événements que vous pouvez utiliser. Alors, ce que je vous invite à faire, c'est essayer de modifier notre incrementeur ici. Donc, on va remettre notre incrementeur automatique. On va supprimer ce code-là, et j'aimerais bien avoir la possibilité pour cet incrementeur de le mettre en pause. Donc, j'aimerais bien que vous rajoutiez un bouton, permettant de mettre en pause l'incrémentation. Donc, là, on crérait ici un nouveau bouton. Et on mettrai à l'intérieur, pause, et on veut que le texte change. Donc, lorsque l'animation est lancée, on veut que pause à fiche pause, mais lorsqu'on en cliquera sur pause, on veut que ça lance play. Donc, je vous laisse essayer d'écrire le code et on corrige un ensemble juste après. Donc, pour imprimanter cette fonctionnalité-là, on a deux solutions qui s'offranont. La première, elle consiste tout simplement à couper et à relancer le timer à chaque fois que l'on va cliquer sur pause. L'autre solution, elle consiste tout simplement à changer la valeur du pas et de dire, si jamais on ne fait rien, on se plairmer le pas à zéro. Ce que je trouve le plus performant pour moi, ça serait de stopper le timer. Parce que, comme ça, on n'a pas de traitement qui est fait chaque seconde. Donc, on va d'abord créer nos différentes fonctions. Donc, on va avoir une première fonction qui va s'appeler pause et qui va mettre en pause les choses. Donc, pour mettre en pause, il suffit simplement de utiliser cette méthode-là. Ensuite, lorsque l'on lance les élements, lorsque l'on va utiliser la fonction play, il va falloir relancer notre timer. Je peux d'ailleurs utiliser ces fonctions-là, maintenant, au niveau de mes composants, au niveau de mes méthodes de composants, pour éviter la répétition. Maintenant, il me faut savoir si on a un timer de l'ancée ou non. Nous, on avait créé une propriété au niveau de la classe, mais finalement, vu que c'est quelque chose qui doit être tracé par réacte et qui doit relancer des rendus, mieux que cette propriété timer soit disponible au niveau de l'état. Donc, je vais lui dire ici, je mets timer et par défaut la valeur, ça sera nulle. Lorsque je lance ici, lorsque je crée mon interval, je vais lui dire, je veux que tu fasses un vis, point-set-state, je vais prendre en premier paramètre à l'objet et je te donnerai le timer qui sera le timer. Je n'ai pas besoin de lui redonner la valeur de N parce que automatiquement, lorsqu'on fait un set-state, il va fusionner cet objet-là avec l'état courant. Ensuite, lorsque je fais mon pause, il va falloir que je fasse un set-state et que je lui demande de définir dans la valeur timer nulle. Donc là, on fera nulle. Et ce qu'on fera aussi, c'est qu'on fera un clear interval de vis.state.timer. Maintenant, au niveau de mon bouton, je vais pouvoir lui dire, j'aimerais bien que lorsque l'on clique sur le bouton, tu appelles la méthode pause. Donc je vais directement lui passer vis.pose.bindvis. Je sauve garde, je laisse un petit peu le temps défilé, je clique sur pause et automatiquement, c'est bien stopper. En revanche, je n'ai pas la possibilité de relancer les choses. Donc ce que l'on va faire, c'est créer un autre bouton qui permet de le lancer. Donc on va d'uplicer ce bouton là pour l'instant et mettre un lecture. Et là, on lui dira de faire un bind, mais de la méthode play. Donc je sauve garde, je clique sur pause, ça met un pause, je clique sur lecture, ça va relancer. Le problème, c'est qu'on aimerait bien d'afficher que le bouton qui permet de faire les choses. Parce que si on essaie de faire un pause plusieurs fois, ça va poser un problème de la même manière. Si je fais lecture plusieurs fois, bien dans ce cas, ça va faire un peu n'importe quoi. Alors, si j'ai peu pu le lecture plusieurs fois, ce qui se passe en fait, c'est que le précédent timer n'a pas été supprimé. Donc ce que je peux lui dire, c'est lui dire, de nettoyer le timer au préalable. Comme ça au moins, on n'a pas de problème. On ne peut pas lancer plusieurs fois des timers si on clique plusieurs fois. De la même manière, au niveau de la partie component will and mount, c'est assez peu naturel de faire appel à un set state. Donc nous, ici, on ne fera pas appel à pause, mais on fera juste un clear interval. Parce que si vous faites un set state, ça va créer des problèmes au niveau du fonctionnement intern. Il ne faut pas appeler set state au niveau de cet événement-là. Maintenant, j'ai envie de gérer une logique conditionnelle pour affiche le bouton pause ou lecture. Donc là, ce que je peux faire, c'est utiliser du ternerre. Donc je fais une petite condition. Je lui dis ici, list.state.timer. Dans ce cas-là, je veux que tu affiche le bouton qui va permettre de mettre en pause le timer. Dans le cas contraire, je veux que tu affiche le bouton qui permettra de lancer la lecture. Et ensuite, je ferme mon expression. Et dans ce cas-là, on voit que ça gère bien les choses. Une autre possibilité serait d'avoir un seul bouton et de se regarder la méthode. Par exemple, on pourrait faire un const-method et lui dire si list.state.timer. Dans ce cas-là, la méthode à appelée, ça sera list.pause. Et dans le cas contraire, ça sera list.play. Ensuite, je peux lui dire le texte du bouton, donc ça va être le label. Mais si list.state.timer, dans ce cas-là, ça sera pause et dans le cas, ça sera play. Où ce que vous pouvez faire, c'est carrément avoir une fonction label, qui est elle, ce charge de faire un return, list.state.timer. Et si c'est définie, vous avez compris le principe. Donc on mettra pause et sinon lecture. Et on pourrait avoir une fonction qui va s'appeler Toggle, qui choisira d'appeler la méthode en fonction de la condition. Donc on lui dira si list.state.timer, dans ce cas-là, on fera un list.state.impose, et dans le cas contraire, on fera un list.state.play. Faut pas hésiter à décomposer votre code pour éviter d'avoir quelque chose qui est trop compliqué aussi au niveau du retour. Donc maintenant, ça me permet de simplifier cette logique-là d'avoir un seul bouton. De lui dire ici, je veux que tu appelles la méthode qui s'appelle Toggle et je veux que au niveau du texte, tu appelles la méthode Viz.abel. Et maintenant, on voit bien que ça m'est emploi. On nous donne juste une petite erreur. Ici, c'est Viz. C'est pas dans l'état que l'on a les méthodes, c'est directement au niveau de l'objet. Donc j'ai mis en pause le monde le lecteur et je peux rappuyer sur l'acteur pour relancer les choses. Si vous voulez vous exercer un tout petit peu plus, essayez de créer un bouton qui permet de réinitialiser et de remettre la valeur à 0. Donc pour créer ce bouton, c'est très simple. On fera un bouton. On clique, on va appeler une méthode qui s'appelle Rizet. Voilà, donc on fera le bind Viz. Et ensuite, au niveau du libolé, on met très réinitialisé. Je vais ensuite créer la méthode Rizet. Donc cette méthode de ce qu'elle va faire, c'est qu'elle fera un Viz.cetState. Elle va changer l'étape pour lui passer la propriété. Qui était la propriété de démarrage, qui était Props.start. Puis qu'on utilise Props, comme je vous l'ai dit, on va plutôt utiliser cette fonction-là. Dès qu'on utilise Props ou State à l'intérieur de cette state, mieux vous utiliser la fonction. Donc je vais lui passer ici comme valeur de N, la valeur initiale, qui sera Props.start. Et dans ce cas-là, je laisse incrementer et quand je clique sur « Initialiser », ça repara zéro. Ce qu'on pourrait faire, c'est peut-être mettre en pause le timer et le relancer. On pourrait ici faire un Viz.cetState. histoire de stopper le timer et ensuite un Viz.cetState play. histoire de relancer le timer. Si je clique sur « Initialiser », on va bien que ça va réattendre une seconde à va lancer. Dernier petit détail important. concernant les performances. Il faut savoir que la fonction Render va être appelée à chaque fois qu'il y a une tix, c'est à dire que à chaque fois qu'il y a un set state qui est fait et un changement d'état, le Render est appelé. Si je fais une console point de log ici, vous allez voir que on voit un Render toutes les secondes. Le problème c'est que ce que j'ai écrit ici, créer une nouvelle fonction de toutes les secondes, ce qui n'est pas forcément très optimal. Ce que vous pouvez faire, c'est que vous savez que vous n'avez pas besoin du contexte. C'est définir vos fonctions en utilisant les fonctions fléchées ou tout simplement utiliser le bind dès la construction. Donc là, je vais récrire toutes mes fonctions. Donc ça sera la fonction toggle et la fonction Brisette. dès le début. Donc là je vais dire, vice point ogel, égal vice point ogel point bind vice, vice point risette, égal vice point risette point bind vice. Et je peux faire ça avec les différentes fonctions. Ce qui me permet maintenant de ne plus avoir un soucié à ce niveau-là de faire un bind vice et de faire toujours appel à la même fonction. Donc c'est un exemple si jamais vous voulez optimiser légèrement les performances. Et dans ce cas là, ça ne change rien mais ça continue à fonctionner. Donc faites attention, pensez et gardez sans tête que le code du Render est appelé à chaque fois qu'il y a un changement d'état. Donc si jamais vous avez des traitements qui peuvent être un petit peu lourds à mettre en place à l'intérieur, ça peut poser des problèmes en terre de performance. Donc voilà pour cette petite vidéo sur l'utilisation des événements. Mais vous commencez à boire un petit peu ce qui est intéressant avec réacte. On a vraiment des composants qui contiennent leur propos logique et qui fonctionne de manière individuelle et que l'on peut manipuler via des propriétés. Donc ça permet de maximiser une logique réutilisable et d'améliorer aussi la modification qui s'en fait au niveau du don. Et je vous donne rendez-vous dans le projet chapitre.