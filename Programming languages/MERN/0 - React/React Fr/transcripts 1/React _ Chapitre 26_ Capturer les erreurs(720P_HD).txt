 A la bienvenue à ce nouveau chapitre, nous allons parler de la gestion des erreurs sur React. Donc ici, j'ai une application qui était créée avec Crue8Riact app, et on peut se demander qu'est-ce qui se passe si on a une exception qui est levée à certains endroits. Donc globalement, dans une application React, vous pouvez avoir des exceptions à deux endroits, soit lors d'un callback lorsque un événement l'invainte va être lancé, mais à le code du traitement de cet événement va avoir une erreur, soit tout simplement dans le code qui va permettre de rendre un composant. Donc on va prendre d'abord la première situation. Donc dans le chapitre précédent, j'avais créé un petit clic qui permettait de faire un console point-log, ben je vais juste rajouter ici un frôme, et on va bloquer notre script en envoyant une erreur. Donc on peut se demander qu'est-ce qui va se passer. Si je clique ici quelque part sur ma boîte, on voit automatiquement qu'on a un overlet qui s'affiche avec cet erreur-là. Donc cet overlet s'affiche ici parce qu'on est dans le cadre d'un template qui était créé avec Crue8Riact app, et en fait, c'est simplement une e-frame qui vient se placer au dessus. Dans le cadre d'une application réelle, par exemple une application que vous aurez déployée, cet erreur ne s'afficheraient pas. De la même manière, si on ferme un petit peu cet erreur-là, on voit que d'ailleurs notre application continue à fonctionner. Donc là, c'est comme si vous aviez en fait une erreur dans un AD20Listener, globalement, ça plante le code qui permet de traiter l'événement, mais ça ne crache pas dans de certes et de votre application. Maintenant, on peut carrément avoir une erreur au niveau du rendu. Donc on s'imagine, par exemple, que notre boîte modèle lorsqu'on la fiche, on a peut-être un traitement avec des oucs et dans un de ces traitements, on a un petit problème et une exception élevé sans être capturé. On peut alors se demander qu'est-ce qui va se passer. Le comportement est un petit peu inétenu parce que lorsque je vais cliquer ici sur ce go-somm-ware, on va voir que l'entirter de notre élément a disparu. En fait, lorsqu'une erreur est renvoyée dans le code qui va permettre de rendre un composant, cette erreur va remonter au composant par un et si ce composant ne capture pas les erreurs, ça remonte sa remonte, jusqu'à arriver ici à la racine. Vu que les erreurs n'a pas été capturés, réacte va choisir de démontrer l'entirter de notre arbre. Et on se retrouve ici avec notre dive qui avait la ID route qui est complètement vide. Donc c'est comme si toute votre application avait été démontée. Donc on a ce comportement ici, mais on aurait la même chose dans le cadre d'un user effect ou à l'intérieur d'un oeuvre qui serait directement exécuté pour le rendu de notre composant. Alors maintenant on peut se dire oui mais moi c'est pas idéal, comme situation, j'aimerais bien capturer ces erreurs là. Donc on a la possibilité de créer ce qu'on appelle des erreurs bonnes d'arrêt, donc des frontières d'erreurs, c'est un composant qui va capturer les erreurs et qui va empêcher les erreurs de remonter et du coup toute notre application de se démontrer. Donc pour créer un composant qui sert de erreur bonnes d'arrêt, il faut créer un composant sous forme de classe. Il n'y existe pas à l'heure actuelle, à laquelle j'enregistre sur cette vidéo, de manière de créer ce composant sous forme de fonction. Donc nous on va créer cette classe, on va l'appeler erreur bonnes d'arrêt et on va étendre de react point-componnette. À l'intérieur on va avoir notre fonction de rendeur ou on va rendre les différents enfants. Donc là on fait un return de vis point-props point-chindreur. Maintenant ce composant erreur bonnes d'arrêt, je vais lui utiliser pour entourer notre structure. Donc dans mon composant application, je vais utiliser ici autour de ma boîte modale un erreur bonnes d'arrêt. Donc ça c'est pas une classe de réacte, c'est ce que je viens de créer. C'est mon petit composant. Mais pour l'instant il ne va rien faire, si je remets ici un gros, nouveau erreur, hop, ben mon application continuera à planter de manière générale et tout sera démontée. Donc pour qu'un composant capture les erreurs, soit il doit implementer une méthode qui s'appelle Component ditecache. Cette méthode prend un premier paramètre, l'erreur et les informations associées. Et ensuite ça pourrait faire un traitement particulier. Donc nous par exemple on fera un console point-log, erreur et erreur info. Si je se regarde maintenant, je clique sur go-sa-mouer. On voit effectivement qu'on a une erreur en console. Et si je referme mon e-frame, l'entirité de mon composant n'a pas été démontée. Si maintenant je souhaite mettre en place peut-être une erreur et affigée quelque chose, ce que je peux faire c'est implementer une autre méthode qui s'appelle GetDariveStateFromEreur. Donc c'est une méthode qui va être statique. On l'appelle GetDarive ou Dérive. Je sais pas du tout comment ça se prononce. StateFromEreur. On va prendre un premier paramètre, l'erreur. Et ce que l'on devra faire, c'est retourner un nouvel état qui déclencheera du coup un nouveau rendu. Donc nous on peut s'imaginer qu'on fera un Ritterne et on mettra erreur et on mettra trou pour dire il y a une erreur. Au début de mon composant, je vais faire un constructeur qui prend en paramètre donc les propriétés qui appellera la méthode parente sans l'oublier pas et dans son état, je lui dis que on n'a pas d'erreur. Donc je mets que erreur est égal à force. Maintenant dans ma partie Render, je pourrais lui dire si on a des erreurs. Donc If, Vist.State.Ereur, je vais afficher quelque chose et je vais afficher ici, par exemple, une dive qui aura comme classe alerte, alerte, tchir, tchur, c'est magnifique qu'on a eu un petit problème et à l'intérieur je pourrais mettre quelque chose. Alors là, je n'ai pas forcément sauf garder l'erreur, effectivement, mais on pourrait récupérer le message d'erreur dans notre état. Nous on va se contenter de dire il y a eu un problème. Maintenant, je vais recevoir des. Je vais peut-être pour éviter de m'embêter systématiquement, préciser au niveau de notre CSS que je veux retirer les iframes. Ça évitera d'avoir la petite erreur en sur impression. Là, c'est vraiment pour tester les choses. Donc dans mon index.js, je vais aller importer mon index.ss et dans mon index.sss, je vais lui préciser que je veux que les iframes soient en display node et je vais mettre importants. Je me concentrerai et vous montrerai vraiment le comportement habituel. Donc si je clique maintenant sur go-sa-mouer, on voit que ici on a marqué IGAI un problème. Et dans ma console, je me retrouve toujours avec mon console.log. Ça peut vous permettre de capturer les erreurs et d'afficher un retour à l'utilisateur pour l'informer de ce qui ne sait pas passer correctement. Globalement, pour qu'un composant permette de capturer les erreurs, il faut qu'il implémente une de ces deux méthodes. Soit l'une soit l'autre soit les deux. Si par exemple je retire cette partie-là, on voit voir que lorsque je clique sur go-sa-mouer, on a rien qui est capturé en console, donc on voit les erreurs qui iront monte, mais on n'a pas l'entirter d'une trappication qui est démontée. Ici, il le capture et maintenant il affiche ça. Enfin, d'un ép petit détail, donc là on va retirer notre erreur Boundary.s, c'est tout simplement par rapport à comment interpréter une erreur qui n'aurait pas été capturée. Lorsque je clique sur go-sa-mouer, vous allez voir que à ce niveau-là, on a l'erreur par défaut qui est renvoyé par le javascript, qui peut ne pas forcément être très clair, et ensuite on a une erreur aussi qui est renvoyée par React, qui nous donne un peu plus de déclarcissement sur la raison de l'erreur. Donc on vous a dit attention, ben là, vous avez une erreur au niveau de modèle, et on vous explique, ah, il faudrait rajouter une erreur Boundary, donc ce qu'on l'a déjà fait, à ce niveau-là, et on vous donne directement un lien. Donc ça ça peut être très pratique pour débuguer et comprendre quel composant pose problème, plutôt que directement lire l'exception qui est renvoyée par React. Donc voilà, pour ce principe-là. Enfin, on peut se demander finalement à quel endroit on va mettre un erreur Boundary. Donc là, il n'y a pas forcément de règles particulières, ça va dépendre de vous comment vous voyez l'interface, et à quel endroit vous pouvez la placer. Ce qu'il faut être réévité par contre, c'est de se dire, bon, ben j'entoure maintenant tous mes éléments de erreur Boundary, comme ça, je capture les erreurs. Non. Parfois, même, au niveau que ça soit intéressant, que ça remonte à un certain niveau, pour ensuite démontrer tous les enfants pour afficher une erreur. Par exemple, si je pense à une liste d'articles, si vous faites des actions et que, bah, vous avez un problème, peut-être que toute votre interface se trouve dans une étape qui n'est pas bon. Donc dans ce cas-là, mieux que les erreurs remontent à la liste et vous démontez cette liste pour afficher une erreur. Et du téteur, va à soir affricher la page, soit vous lui prévoyez une action qui permettra de raffricher les choses. Pareil, si vous avez peut-être un petit module de commentaire et que vous dites, à même peut-être un jour, il y aura des erreurs à ce niveau-là, bah ça peut être intéressant de ne pas faire remonter les erreurs pour pas que ça plante toute la liste. Et ainsi de suite, ainsi de suite. Donc, il faut toujours réfléchir un petit peu dans lequel situation vous allez mettre les choses et aussi réfléchir où est-ce que vous pouvez éventuellement avoir des erreurs. Donc j'espère que ce chapitre vous a plu, et je vous donne rendez-vous dans le chapitre suivant.