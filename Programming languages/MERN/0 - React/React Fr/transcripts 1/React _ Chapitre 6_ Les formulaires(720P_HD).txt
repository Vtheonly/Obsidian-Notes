 Bienvenue dans ce nouveau chapitre, nous allons maintenant voir comment gérer les formulaires au sein de React. Les formulaires sont des éléments un peu particuliers parce que, dans le cadre du domme classique, ils sont capables de maintenir eux-mêmes leurs propriétats, c'est-à-dire que lorsqu'on va taper quelque chose dans un champ, on a une propriété value qui permet de persister l'information qui a été tapée. Or avec React, on l'a vu, React a sa propre manière via le système de state de gérer son état, donc il va falloir demander à React de contrôler les choses. Pour vous donner un petit exemple, on va créer un nouveau composant qui va contenir notre champ. Donc ce qu'on va faire, c'est qu'on va effacer tout ce qu'on a écrit jusqu'à maintenant, sauf la dernière partie. On va juste garder ce composant Home. Je vais recréer ce composant Home, mais cette fois-ci, on utilise un approche class. Donc on va faire une nouvelle classe qui va étendre de React.componente. À l'intérieur, on va créer une fonction Render. Cette fonction va simplement rendre une dive qui va contenir notre champ. Donc je riteurne une dive qui va contenir notre label. Pour le label, on va avoir un attribu fort. Alors faites attention, vous ne pouvez pas utiliser fort comme ça, mais dans le cadre de React, on va avoir HTML4. Pourquoi, comme pour le système de classe, fort est un mot clé du laud à ce script. Donc pour éviter tous les problèmes, ils ont choisi d'utiliser HTML4 à la classe. Donc au niveau du fort, on va mettre donc. On imagine que c'est un champ qui va permettre de taper notre nom. Dans ce label, je mets mon nom. Ensuite, on va avoir un champ. Donc on met ici un input de type texte. On ne l'umie pas de valeur, mais par contre, on lui donnera un ID non et un nom qui va s'appeler. Donc là, je peux automatiquement fermer cette balise pour que ça fonctionne. Alors faites attention, dans le cadre de l'HTML, on peut mettre des balises comme ça. Mais si vous écrivez ce code-là, vous le voyez, il vous dit, non, ça ne passe pas. Donc dans le GX, il faut nécessairement que les balises et une version fermente ou soit auto-fermente. Voilà, ça ne fonctionne pas et ce ne sont pas les mêmes règles que l'HTML. Donc par défaut, on voit bien que ça affiche un champ, mais le problème, c'est que quand on tape une valeur, on a aucun moyen de traquer les choses. Du coup, il va nous falloir créer un état qui permettra de savoir quelle est le nom qui a été tapé. Donc on va créer un constructeur. Dans ce constructeur, on prend en paramètre les propriétés et on appellera la méthode parande. Ensuite, on va définir notre état. Donc on va faire un vise, cette state, et on s'imagine que dans cet état, on aura le nom de la personne. Et par défaut, on imagine que la valeur sera jam. Maintenant, au niveau de mon change, je peux utiliser dans la tribut value cette valeur-là. Donc je ferai un vise.state.nom. Donc tout de suite, vous allez remarquer quelque chose d'un petit peu étrange. Donc on voit bien que notre champ a ce nom-là, par contre lorsqu'on vous essaye de taper une valeur dans ce champ, rien ne se passe. Tout simplement parce que maintenant que vous avez défini une valeur, ce champ va être contrôlé par Riat. Donc Riat va s'assurer que la valeur qui est dans le champ correspond à ce que vous avez mis dans l'UGS. Donc le problème c'est que là, vous n'avez aucun moyen de changer le nom. Et c'est pour ça que ce champ devient complètement bloqué. Du coup, il va falloir définir un événement qui va permettre de gérer les changements. Donc cet événement, c'est l'événement On Change. On va tout de suite appeler une autre méthode que l'on va appeler Endole Change. Cette méthode, je vais définir plus haut, donc ça sera Endole Change. Elle prend en paramètre un événement qui sera du coup un synthétique évente. Et on va tout de suite faire un console point log de E. Attention pour que VIS face bien référence à la bonne chose. Dès le constructeur, on fera un VIS point Endole Change. Égal VIS point Endole Change. Maintenant, si je réactualise ma page et que je sors mon inspecteur, donc je vais sortir ici. C'est un inspecteur en mode console. Non, ce que je vais taper quelque chose, je vois que ça ne change rien comme d'habitude. Mais par contre, j'ai bien mon objet avec l'événement. Et dans cet objet-là, je vais pouvoir récupérer Target qui sera la cible, mais je vais surtout pouvoir récupérer la valeur. Et cette valeur, il faut que je la change au niveau de l'état de mon composant. Pour lui dire, maintenant que la personne a tapé Jean-Prouille un caractère, il faut que la valeur de mon composant change pour que lui, il change le rendu. Donc, au niveau de mon Endole Change, je vais lui dire il faut que tu set State, il faut que tu change le l'état. Tu vas changer et la valeur de Non. Et tu mettra ce que le tour se verra au niveau de l'événement. Donc, si vous voulez récupérer la valeur, vous pouvez le faire en faisant un E point Target, qui vous permettra de récupérer le champ. Et ensuite, Value pour récupérer simplement la valeur. Donc, je sors de garde et mets de l'anciet je tape une lettre. On voit que le champ reflète mes changements. Donc, il n'est plus en lecture seulement, mais il est modifiable. Donc, dès que l'on va taper quelque chose, il va appeler cette méthode qui va changer l'état et qui va faire en sorte que le composant ici correspond à ce que l'on attend. Donc, ça c'est ce que l'on appelle un champ qui est contrôlé via React. Maintenant, qu'est-ce qui se passe pour d'autres champs? Typiquement, on va prendre par exemple le textariat. Un textariat normalement quand on le tape en HTML, on fait un textariat. Et ensuite, un étarior en met la valeur. Donc, dans le cadre de React, ça va être un petit peu différent. Donc, je vais reprendre les différentes propriétés ici. Voilà, donc ça va fonctionner de la même manière. Sauf que dans le cadre de React, un textariat peut avoir un attribu value qui définit sa valeur. Et c'est ça qui permettra de changer les choses. Si je s'obgarde, j'ai maintenant monté Extariat avec la valeur initiale et quand je tape des choses, ça les modifie. Donc, c'est la petite subtilité. Les textarats ne prennent pas des enfants qu'on pourrait attendre dans le cadre de l'achet d'email classique, mais ça prend une valeur. Alors maintenant, on va parler du select. Alors, pour le select, ça va être un petit peu différent. Donc, on va avoir un select et normalement, on aurait plusieurs options. Donc, on va mettre une première option qui aurait comme valeur d'email 1 et en mettrait au niveau du libelé d'email 1. Donc, on va en créer simplement 3. Donc, on mettra d'email 2 et d'email 3. Dans le cadre du domme classique, parce qu'il faudrait faire, c'est prendre une de ces options et lui mettre un attribuant selectif pour le sélectionner. Dans le cadre de React, ça va fonctionner complètement différemment. On va simplement ici avoir une valeur et on mettra la valeur qui est traquée par React. Donc, nous ici, ça sera Viz.state.nom. On s'imagine que le nom par défaut, ça serait par exemple des moudes 2. Par aille, lorsque l'on change la valeur, il faudra faire un en change. Et là, on utilisera la même méthode qui sera Viz.and.change. Lorsque l'on fora un e.target.value, ça nous mourra la valeur qui était sélectionnée. Donc, si je s'obgarde, on voit bien notre démo 2 qui est sélectionné par défaut. Mais si je sélectionne une autre valeur, automatiquement, c'est celle-là qui est sélectionnée. Si vous voulez vous en assurer, à ce que vous pouvez faire, c'est par exemple au dessus de votre label, mettre la valeur. Donc, on mettra ici affiche-moi Viz.state.nom. Donc, lorsque je s'obgarde, dès que je change du valeur, automatiquement, elle change. Si votre champ accepte plusieurs valeurs, vous pouvez lui préciser ici que c'est un champ select de type multiple. Dans ce cas-là, ça va changer un petit peu la parence. Mais par contre, dans les valeurs que vous lui envoyez, il faudra lui envoyer un tableau. Donc par exemple, je peux lui dire par défaut, il faut que tu sélectionne des moudes 2 et aussi des moudes 1. Et automatiquement, là, ça va bien fonctionner. Et quand vous changez les valeurs, ça vous renvoie un tableau. Donc ici, il faudra plutôt mettre un gisson de point stringify. C'est un tableau, hein, hop, hop, hop. Et on mettra Viz.state.nom. En revanche, quand j'essaye de sélectionner plusieurs valeurs, on voit que c'est réinitialisé. Il faut faire attention le E.target.value ne va pas fonctionner dans le cas de un select multiple. Là, ce qu'il faudra faire, c'est récupérer l'ensemble des options qui ont été sélectionnées. Donc, c'est Selected Options. Convertir ça sous forme de tableau. Donc, soit en faisant un réframe, soit en utilisant les sprits d'opérateurs comme ça. Et ensuite, sur ce tableau là, on va m'appeler pour récupérer l'ensemble des options. Et nous, ce qui nous intéresse, c'est simplement la valeur. Voilà. Dans ce cadre-là, si je fais une sélection multiple maintenant, ça va fonctionner convenablement. Donc, faites attention à la logique du One-Dole Change ici. Enfin, le dernier point ce sont les champs de type radio ou de type checkbox. Donc, là, pour le coup, c'est plus proche de l'HTML. On aura un input de type checkbox. Et si on veut le sélectionner, on aura un attribué Checked qui sera un boulet aim pour dire si c'est sélectionné ou pas. Donc, là, on va peut-être recréer dans notre State. Voilà. Une propriété de Checked. Et on mettra que c'est trop par des faux par exemple. Et à ce niveau-là, on lui dira vis.state.check. Maintenant, on aura aussi une méthode On Change qui permettra de détecter le changement. Donc, on appellera ici encore une fois OnDole Change. Et on auto-ferme ce champ-là. Donc, par des faux, c'est déjà caché. Et quand on décoche, on veut que je changeais quelque chose. Donc, là, on ne changera la propriété Checked. Mais on ne changera pas en utilisant un e.target.value. Mais on utilisera un e.target.check. Voilà. Comment vous pouvez avoir une checkbox qui va être tracée. Donc, ce que l'on pourrait faire par exemple, c'est afficher quelque chose en dessous. On imagine, hop, mettre une dive, un message affiché si on coche la checkbox. Donc, de tracer ce champ permet par exemple d'afficher ce message seulement si check. Donc, là, on lui dira, si check. Dans ce cas-là, je veux que tu affiche ça. Dans le cas, je, contraire, je veux que tu n'affiche rien. Maintenant, ça devrait fonctionner, si ce n'est ici que ces vise.state.check. Ça attends. Et il lorsque je décoche la case, les lémants se masque et ça fiche. Donc, voyez, c'est très, très simple de connecter des comportements, au modification, au niveau d'informulaire. Enfin, le dernier type de champ que l'on peut être amené à rencontrer, c'est les champs de type Fischly. Donc, ces champs-là ne peuvent pas être contrôlés par React parce que les informations qui sont dans le champ sont disponibles en lecture-sol. Donc, il n'est pas possible pour React de modifier la valeur d'un input de type Fischly. Donc, par défaut, si vous avez un input de type Fischly, vous pouvez gréffer des événements dessus, par contre, vous ne pouvez pas changer sa valeur dynamiquement depuis React. Ce n'est pas possible. Mais dans tous les cas, ce n'est pas possible, un javascript de base non plus. Donc, maintenant, imaginant, on a un formulaire qui contient plusieurs champs. On veut le prénom, le nom et le fait qu'on en accepte ou non la newsletter. Donc, pour l'instant, on va mettre tout le code à ce niveau-là. Donc, je vais créer une première dive qui va permettre de tout englober. Ensuite, je vais créer une première dive qui va contenir mon premier champ. Donc, c'est le champ qui permettra de rentrer son prénom. Donc, je mets un label, je utilise l'attribu Alt-T-H-TML-FOR et ça sera l'attribu pour le nom. Donc, on mettra non. Ensuite, je crée un input de type texte et je vais lui donner comme valeur. Viz.state.com. Comment l'a fait tout à l'heure ? Et lorsque on change ce champ-là, je vais lui demander d'appeler la méthode OnChange. Donc, ça sera Viz.andoldChange. Donc, là, on pourrait se dire, je vais créer une méthode OnChange pour le nom, OnChange pour le prénom, OnChange pour la newsletter. Le problème, c'est que dans ce cas-là, vous allez dupliquer beaucoup, beaucoup de logis. Donc, nous, on va plutôt essayer de penser quelque chose de manière très générique ici. Et on va utiliser la même méthode AndoldChange pour nos différents champs et aussi pour la checkbox. Au niveau de l'aidee, je vais mettre non et je vais lui donner aussi un name qui s'appelle Rannan. Voilà. Donc, là, j'ai créé mon premier champ et au niveau de mon état, je vais préciser une valeur initiale. Donc, on va imaginer que le nom sera vide par défaut. Le prénom sera vide aussi par défaut et ensuite, on aura newsletter et on mettra false par défaut parce que l'utiateur n'a pas accepté la newsletter par défaut. Donc, je vais dupliquer cette dive-là. Donc, là, on mettra tout simplement prénom. On n'a pas grand-chose d'autres à changer si ce n'est que dans le state, on récupéra le prénom et ici, on récupéra prénom et prénom. En fin, dernier champ, c'est l'abonnement à la newsletter. Donc, là, on mettra newsletter. Et je vais oublier de changer prénom ici. Donc, ça sera newsletter. Ah, pop, pop. On l'a d'ailleurs, on mettra plutôt sa abonné à la newsletter. Bonne interrogation. Là, ça sera un input de type checkbox. Donc, on n'a pas value, mais on mettra checked. Et ça sera coché, CVS.state.newsletter. Lorsque l'on change, on appelle aussi la méthode handle change et on va changer son nom et son ID. Donc, ici, on mettra newsletter. Donc, là, on a notre formulaire. Bon, il n'est pas très joli, mais on se concentre avant tout sur le fonctionnement. Donc, on aimerait bien qu'on change les choses que ça change le état. Et pour voir un petit peu les évolutions de l'état, juste après notre formulaire, on mettra un gson.stringify de vis.state. Donc, lorsque je tape une valeur ici, il faudrait que ça change la valeur au niveau de nom ici. Donc, au niveau de notre handle change, on va devoir récupérer le nom du champ qu'on a un train de modifier. Donc, on peut le récupérer en faisant un e.target. Donc, ça, on va le sauvegarder dans une variable que l'on va appeler. Ensuite, on peut lui demander de faire un vis.state et on va lui demander de changer la valeur qui correspond au nom. Donc, pour cela, je peux utiliser cette notation-là. Donc, je vais mettre un clé le nom du champ. Donc, ça sera non-prénom ou newsletter. Et, au niveau de la valeur, je mettrai un e.target.value. Et là, ça me permet de muter seulement la clé qui correspond au nom de mon champ. Donc, je sauf garde, je modifie le nom. On voit que le nom est changé. Je modifie le prénom, ça fonctionne bien. Par contre, pour la checkbox, ça va poser un problème. On voit que la valeur est toujours pod. Donc, ce que l'on peut faire ici, c'est vérifier le type du champ par exemple. Donc, on va faire un const type, égal e.target.tip. Maintenant, on va créer une constante pour récupérer la valeur et on va lui dire si le type est égal à checkbox. Dans ce cas-là, on récupera e.target.check. Dans le cas contraire, c'est-à-dire si c'est un champ placé, qu'on fera un e.target.value. Maintenant, à ce niveau-là, je n'ai calu passer la valeur qui est gérée ici. Donc, si j'essaye de soumettre les différentes choses, on voit bien que les valeurs correspondent à ce que l'on attend. Donc, après, on pourrait faire des traitements supplémentaires, voir si on a des erreurs, ce genre de choses. On va envoyer comment on peut traquer les changements fait au niveau d'informulaire dans un objet et au niveau de l'état de notre composant. Alors, maintenant, un petit détail important. On va mettre au niveau du render un console.log de render. À chaque fois que vous tapez quelque chose dans un champ, il faut bien comprendre que ça va redéclencher un rendu, c'est-à-dire que à chaque fois que vous faites un changement, il appelle un set state, donc logiquement, le composant est revendu. Donc, là, on a une logique assez simple, mais il faut bien comprendre que ça demande du travail au niveau de React à chaque fois que vous faites quelque chose dans un champ. Ce qui peut poser un problème en terre de performance. Donc, si vous n'avez pas forcément besoin de traquer l'état de votre champ au niveau de React, par exemple, vous avez un champ et vous ne avez besoin de la valeur que lorsque on soumait le formulaire, ce n'est pas forcément utile de traquer les choses. Donc, là, ce que l'on a créé, c'est ce que l'on appelle des champs contrôlés, mais vous avez la possibilité de créer des champs non contrôlés. Dans ce cas-là, alors, je vais peut-être laisser mon console point log de Render, mais vous pouvez avoir un input de type texte, et vous n'allez lui mettre aucune valeur. Et on va automatiquement le fermer. Ce champ-là est un champ non contrôlé, c'est-à-dire que c'est un champ qui est mis dans le dom, et c'est le dom qui est chargé de traquer la valeur. Si plus tard, on aura récupéré la valeur, il faudra récupérer le champ dans le dom et récupérer sa valeur comme on le ferait avec du JavaScript Classique. Autre petit détail, si le champ a une valeur initiale qui est définie par React, donc c'est ce qu'on a vu tout à l'heure, ce champ va être contrôlé et il n'est du coup plus possible de le modifier. Un revanche, si la valeur qui est donnée ici est une valeur nulle, dans ce cas-là, c'est comme si on n'avait pas de value, le champ n'est pas contrôlé par React, et on peut taper absolument n'importe quoi. Et là, on vous dit d'ailleurs, mieux voudrait utiliser un difaint. Donc là, on va mettre un difaint. Mais le mieux reste de ne pas mettre de valeur du tout si vous voulez laisser le dom gérer l'état de ce champ-là. Enfin, d'un petit détail, on pourrait se dire, oui, mais moi, j'aimerais bien mettre une valeur initiale au niveau de React et ensuite, bien, sans forcément pour autant, le contrôler. Dans ce cas-là, vous avez une autre propriété que vous pouvez utiliser qui est des fold value. Là, vous pouvez mettre une chaîne de caractère ou le résultat d'une expression React, nous on va mettre salut. Et dans ce cas-là, ça sera la valeur que prendra le champ initialement, sans forcément forcer les choses. C'est-à-dire que maintenant, vous pouvez taper n'importe quoi d'autre et il n'y a aucun problème. Donc si vous avez besoin de suivre les modifications qui sont faites au niveau de l'état, on utilisera des champs contrôlés. Donc il faudra nécessairement avoir un value, ou un en-chain de l'associé. Si vous voulez avoir des champs qui ne nécessitent pas forcément d'être contrôlé par React, il vous suffit de ne pas mettre de valeur et d'utiliser des fold values si vous voulez mettre une valeur initiale. Donc si par exemple, vous gênerait un formulaire et le formulaire sera soumis de manière classique, parce que ce n'est pas forcément pertinent de traquer les valeurs par React. En revanche, si par exemple, à chaque fois que vous lutteriez à un tab quelque chose, vous voulez valider les données au niveau de votre composant et faire peut-être des traitements, dans ce cas-là, c'est plus intéressant d'avoir des champs contrôles. Alors après, ici, on a écrit quand même pas mal de code, mais il faut savoir que vous pouvez évidemment séparer dans des composants dédiés. Alors je vais vous donner un petit exemple, mais on va imaginer qu'on a envie d'utiliser bootstrap à ce niveau-là. Donc on va simplement prendre le RCSS, qu'on va sur la version 4, get start, et on prend simplement l'RCSS. Et on va mettre ce RCS au niveau de notre index.html. Le principal problème que l'on a en général avec bootstrap, c'est que finalement, il y a pas mal de classe et de structures que l'on doit mettre. Et puis on s'amuse pour chaque champ à mettre un classe naïm, égalforme contrôle, formes group et tout ça, ça peut être un petit peu embêtant. Le grand vantage ici, c'est qu'on va pouvoir séparer dans des composants. Donc je vais pouvoir créer un composant. Donc je vais créer une classe qui va s'appeler Field. Et cette classe, elle va étendre de React.componet.html. À l'intérieur, je vais avoir simplement un Render pour l'instant. Et dans ce Render, je vais récupérer des propriétés. Donc qu'est-ce qui change entre les champs? J'ai le libelet qui est ici. Et ensuite, j'ai le nom du champ. J'ai besoin peut-être d'une méthode OnChange et d'un value. Donc au total, j'ai besoin de quoi? Value OnChange et Nave. Donc au niveau de mon Render ici, je vais utiliser la destructuration. Ça me permettra de tracier un petit peu plus simplement ce que je suis censé avoir dans les propriétés. Donc là, on va avoir un Nave. On va ensuite avoir une valeur et le OnChange. À l'intérieur, je vais retourner une dive qui aura comme classe forme tirée groupe. À l'intérieur, je vais avoir mon label. Je vais utiliser le HTML4 et je vais pouvoir utiliser le nom, comme I'di, ou si vous voulez éviter les conflits, vous pouvez générer un ID à partir d'autre chose. Mais là, pour l'instant, on va partir du principe que l'on fait ça simplement. Et dans ce label, je mettrai le label. Pour l'instant, je ne sais pas comment je vais passer les choses. Ensuite, je vais avoir un champ, qui sera donc un champ de type texte. Ça, pour l'instant, ne le change pas. Je vais préciser que la valeur sera la valeur qui me sera envoyée par le composant par an. Je vais avoir un OnChange et je fais faire appel à la méthode OnChange parent. Donc il y a un temps envoyé par les propriétés. Je vais lui donner un ID qui sera donc le Nave comme ça. Là, ça me permet de créer la structure de base. Je vais aussi pouvoir lui donner un ClassName et je mettrai forme tirée contre l'ol. Et j'ai autrefaire, ce champ-là. Donc j'ai maintenant ce petit composant que je vais pouvoir réutiliser. Donc à ce niveau-là, quand je veux créer un nom, je peux faire simplement un fil. Je lui donne comme Nave, pas non. Je vais lui donner un value et ça sera Vist.State.Nom. Je vais lui donner le OnChange. Comme on le faisait pour une poute de type classique, vous voyez, vous pouvez vraiment passer des propriétés qui sont des callback. Ça, c'est très intéressant parce que ça vous permet d'envoyer des informations vers les composants en enfant. Et après, je n'ai pas besoin de lui passer d'ID ou quoi que ce soit d'autre. Autobatiquement, ça va être géré par ce champ-là. Et ensuite, je ferme ça. Donc on va enlever le reste pour l'instant. Et je vais réutiliser. Donc automatiquement, on voit bien on a ici un champ qui est bien formaté avec la structure HTML de base de bootstrap. On va peut-être mettre ici une classe container juste pour le principe. En revanche, sur le niveau de ce champ, j'aimerais bien préciser un e-ballet. Donc soit on met ici un label et à l'intérieur on met un label, soit on peut se dire, bah ça serait peut-être pertinente d'avoir directement un enfant et en mettrai le nom. Et ensuite, on fermerait notre champ. Dans ce cas-là, au niveau des propriétés, il faudra lui dire attention, je veux en plus le chidrun, les enfants de ce champ-là, et je vais mettre les enfants directement ici. Et hop, comme ça, on a maintenant la possibilité de créer des champs rapidement et beaucoup plus simplement qu'au paravant. Donc je peux avoir un champ pour le prénom. Donc ça sera ici prénom. Et je mettrai prénom. Après, hop, je continue et je vais avoir, en dessous, un gison point stringify et je vais juste stringifier l'état pour vous montrer que ça change bien les choses. Donc lorsque je change le nom, ça change le nom et là, ça change le prénom. Et à juste un petit détail, hop, ici c'est prénom. J'ai mis un accent, ça ne passera pas. Pour la partie checkbox, là il faut réfléchir. Est-ce que l'on crée une condition ici, c'est-à-dire qu'on rajouterait dans les propriétés un type et suivant le type, on peut en changer la structure, ou est-ce qu'on se dit, on crée à notre champ, qui s'appellerait de checkbox. Alors là, il n'y a pas forcément de bon ou de mauvaises réponses, c'est à vous de voir suivant la structure de votre élément. Donc dans le cadre de bootstraps, la structure HTML est tellement différente que je me dis que pour l'instant, le plus simple serait de créer une classe différente à nouveau composant, donc si vous avez des composants comme ça, qui n'en besoin de rien, vous pouvez les définir simplement comme des fonctions, c'est plus rapide, là on pourrait avoir au lieu de avoir tout ce truc-là, une fonction qui s'appelle field, cette fonction, elle prendra en paramètre les propriétés, qu'on peut destructurer dès le début comme ça, et ensuite, elle retourne la dive. Voyez que la syntaxe est un petit peu plus simple. Je vais juste réindenter ça convenablement et on va t'oupliquer ce composant-là pour créer un composant checkbox. Ce composant finalement, il va avoir besoin des mêmes propriétés. Là, la dive n'a pas la classe de forme groupe, mais c'est forme tirée check dans le cadre d'une checkbox. On a l'input qui se situe avant le label. Ensuite, il lui le recevra effectivement une valeur, mais il devra l'utiliser pour définir si on check ou non. Donc là, on dirait un check. L'input sera de type checkbox, et il aura comme classe. C'est juste la classe que l'on va changer ici, forme tirée check, tirée input. Au niveau du label, on mettra une classe particulière, qui sera la classe, forme tirée check, tirée label. J'ai choisi de mettre value plutôt que check pour garder une signature qui est un peu présimilaire entre field et checkbox. Mais après, libra vous de changer ça, si ça ne vous convient pas. Maintenant, si je veux une checkbox pour changer les choses à la fin, il me suffit ici, de mettre checkbox, de mettre un name, c'était newsletter. Value, on utilisera visp.state.newsletter, et on change, on utilisera la même méthode. Donc là, je vais carrément tout dupliquer, et on mettra ça bonnet à la newsletter. Et pouffe comme ça, on aura notre système de petite checkbox. Ça permet de simplifier la structure de notre composant principale, en séparant la logique, dans des sous-composants. Et là, vous le voyez, vous avez un formulaire qui est une apparence plutôt sympa, sans forcément trop charger cette partie-là. Alors, le principal inconvenien que l'on aura systématiquement avec les champs, mais ça, on ne peut pas y couper, c'est qu'il faudra nécessairement préciser value et on change. Sinon, le champ ne peut pas être contrôlé par iacte, et du coup, il faudra gérer les valeurs directement manipulant le temps. Donc là, vous le voyez, bah, ça nous permet vraiment de créer des composants avec une petite logique et qui permet de gérer à la fois la logique et la apparence, et ça permet de simplifier le code que l'on a ici. Alors, peut-être une dernière chose, si on veut compléter notre exemple, on aurait normalement un bouton. Donc là, on va créer un bouton. Donc on ferait un button, on lui donnerait comme classe, BTN et BTN tirer primari et on mettrai, envoyer. Pour que ce système fonctionne, on aurait ici un formulaire. Donc je remplace ma dive par un formulaire. Et peut-être ce bouton, j'en tourais d'une dive que je le ferai à la classe. Forme tirer group. Ah, il ne te complète pas. Donc un pique, dive, classe, name, égal, forme tirer group. Et ensuite, à l'intérieur, je mets mon bouton avec envoyer. Ça me permettra juste d'espaceer un petit peu plus par rapport à la newsletter. Bon, ça va pas l'air de bien marcher, mais ça va l'air de bien marcher dans les exemples de bootstraps non plus. C'est pas grave. Maintenant, au niveau de ce formulaire, si je veux écouter la submission, ben il me faudra un 1 submitte. Et là, on aura une méthode qui s'appellerait vice point-handle submitte. Cette méthode, je vais aller la créer, elle prend en paramètre l'événement et elle fera un e.dfdfd pour empêcher la submission classique de notre formulaire. Tout de suite, en haut, je vais faire un vice point-handle submitte point-handle submitte point-by-newice, histoire d'avoir toujours le bon contexte. Maintenant, à ce niveau-là, parce que je pourrais faire ces stringifiés et les résultats et les envoyer un Ajax par exemple, un autre serveur qui ferait le traitement. Donc là, on ferait un conste data et GalGiSon.stringify et on peut directement stringifier l'Etat, parce que c'est l'Etat qui contient l'Etat de notre formulaire. Je fais un console point-log de data et lorsque je teste les choses, là, il me sent juste une petite erreur ici parce que j'ai oublié de mettre class name au lieu de classe. Donc, je modifie les choses, je clique sur envoyer et on a bien ici notre Gison. Et il s'en touge au mon erreur, j'ai laissé un classe quelque part ici aussi. Faites bien attention à ça. Ça serait que quand on a la vidéo de travail avec l'HTML, ça me tire et réflexe à prendre. Et là, une fois que le formulaire serait soumis, donc, faudrait mettre un petit brin de logique, on pourrait s'imaginer, réinitialisez les données pour pas que l'utilateur puisse reçoumettre le formulaire. Donc, on ferait un vis.setstate, on remet les valeurs initiales, on pourrait sauver des ça dans une constante, des peu importe. Et dans ce cas-là, ça va automatiquement réinitialiser les champs parce qu'ils sont contrôlés par ryâtre. Et ça donne ça. Donc voilà un petit exemple de manipulation de formulaire et de champs en utilisant ryâtre. Donc, voyez-ce qui est intéressant, encore une fois par rapport à la manipulation de données classiques, c'est que finalement notre centre d'attention, ce n'est plus le dom, où il faudrait mettre à quel évalueur, modifier les valeurs, revider les champs. Mais c'est cet état-là. On définit notre fonction, qui dépend de notre état, et la seule chose qu'on a à faire, dès qu'on a besoin d'écrire un brin de logique, c'est simplement changer l'état. Et c'est réacte ensuite, qui s'occupe du reste pour nous. L'autre gros avantage, c'est la capacité d'utilisation de composants qui nous permettent de mieux séparer notre code. Donc là, on a des composants réutilisables qui permettent de générer des champs avec votre strap, et automatiquement, on peut les utiliser au niveau de notre composant principal. Donc à force, avec le temps, vous allez vous créer une sorte de collection de composants qui vont vous permettre d'accélérer votre développement, ou aussi utiliser des composants de tiens qui sont déjà fournies par notre personne. Alors du coup, ce que je propose, c'est dans le prochain chapitre de faire un petit épais pour m'avoir, si tout ce que l'on vient de dire ici, et bien assimilé. Ou je vous donne rendez-vous dans le prochain chapitre.