 Bienvenue dans cette nouvelle vidéo. Aujourd'hui je vous propose encore un petit cas pratique avec React pour parler aussi de l'organisation de certaines futures et on va voir comment mettre en place un système de message toast. Donc le principe c'est de faire en sorte d'affichir une petite alerte à l'utilité à teur lorsqu'une action c'est bien effectuée ou lorsque il y a eu une erreur dans l'application. Vous savez c'est le genre de petits messages qu'on a en général en haut à droite. Donc là j'ai une petite application réacte très simple. J'ai déjà un composant toast qui permet juste d'afficher un message en particulier et j'aimerais bien faire en sorte de l'afficher lorsqu'on clique sur ce bouton ou ça pourrait être le cas lorsque une sauvegarde a bien été effectuée. Du coup la première chose c'est que je réfléchis à la pays qui me semblerait la plus facile à utiliser. Moi ce que j'aimerais bien faire c'est avoir comme ça un roug qui s'appelle le use toast. On imagine avec un S. On récupérerait de ce roug une méthode pousse toast par exemple et ensuite on pourrait quand on le souhaite. Par exemple on submit. On effecturait des actions et on lui dirait à la fin mais il faut que tu fousche toast et on me pourrait mettre des informations comme le titre et ce genre de choses. Vous mettez ici bravo et le contente ça serait votre action à bien marcher. Et là on mettrai ce comportement lorsqu'on en cliquerait sur ce petit bouton. Maintenant comment on fait en sorte que ça fonctionne ? Je me dis que le système de toast finalement c'est quelque chose qui va être global à mon application et je vais avoir besoin de faire communiquer ça avec les différentes composants. Donc typiquement on est en cas d'utilisation assez parfait pour le contexte. Je vais aller dans mon dossier toast que j'avais déjà créé et je vais aller créer un nouveau file chez que je vais appeler toast contexte. Point T6 je fais du type script mais vous pouvez suivre avec du JavaScript il n'y a aucun problème. Donc la première chose que l'on va faire c'est créer notre valeur par défaut pour notre contexte. Donc on va l'appeler des fold value et là on a plusieurs solutions. Donc une première solution serait de sauvegarder finalement toast qui continueraient un tableau avec les différents messages et on aurait une méthode de cette toast qui permettrait de changer les valeurs. Pour l'instant je me fiche complètement des types et de toutes les erreurs que vous voyez le but c'est de poser un prototype et aussi de vous parler des problèmes. Ensuite je peux créer mon toast contexte et je vais créer mon provider donc je fais créer une fonction que je vais appeler toast contexte provider et ça sera du coup une fonction qui ne prendra rien par amètre. À l'intérieur je vais sauvegarder mes toasts donc je vais faire toast cette toast et je vais dire que c'est un tableau vide initialement. Donc là ça sera un tableau vide. Ensuite je peux faire un return je vais utiliser mon toast contexte point provider et au niveau des valeurs mais je vais pouvoir passer finalement les deux valeurs que j'ai ici. Donc dans la value je lui passe à la fois mes toasts et mon set toast. Voilà je me fiche à que les types ne correspondent pas et je passe les enfants à ce contexte provider. Donc ça veut dire que ici je vais avoir besoin des enfants et pour que ta hyps crypte n'aura le pas je lui dis que c'est de type Props with Sinon. Donc on est pas mal. Il me faut juste un composant supplémentaire pour afficher mes petits toasts donc je vais aller créer une fonction que je vais appeler toast au pluriel et cette fonction elle va utiliser le contexte pour récupérer les toasts à afficher. Donc on va lui dire récupère toasts et utilise le use contexte et utilise mon toast contexte. Je vais retourner ensuite une dive je vais lui donner comme le classe alors ça c'est spécifiquement mon application test container et à l'intérieur il me suffit juste de maper sur mes différentes toasts. Donc je vais faire un toast point map. On va récupérer chaque toast individuellement. On va récupérer la clé parce que ça me servait aussi de clé et je vais utiliser le composant toast que j'avais déjà créé. Au niveau du content je peux mettre toast point content. Au niveau du title je pourrais mettre toast point tittle donc finalement j'ai envie de utiliser toutes les propriétés que l'on aura mis à l'intérieur comme ceci et je vais juste un profiter pour ajouter la clé qui sera cas. Et attention à bien mettre les parenthèses. Donc ce composant qui va m'afficher les toasts je peux ensuite l'utiliser ici. Donc là concrètement j'aurai directement pu le passer la valeur mais ça n'a pas trop d'importance. Maintenant l'un des trucs qui me reste à faire c'est exporter ce contexte provider mais aussi exporter la fonction qui m'intéresse moi dans mon application j'aimerais bien avoir cette fonction juste toasts. Donc je vais exporter la fonction elle va le s'appeler use toast donc elle ne prendra rien en paramètres et ce qu'elle va pouvoir faire c'est extirrer depuis mon contexte donc dont puis mon toast contexte la fonction cette toaste qui m'intéresse. Et après je peux faire un return je vais lui dire c'est un objet je vais avoir donc la méthode pouche toast c'était cette méthode là qui m'intéressait au niveau de mon application et cette fonction qu'est ce qu'elle va faire. Elle va prendre en paramètre un toast en particulier. Voilà et elle faut rappeler la 7 toasts et elle lui rajoutera. Donc elle récupère la valeur qui est déjà dans le state. Et elle poussera à la fin le nouveau message comme ceci. Histoire que cette fonction ne soit pas regenerée systématiquement je vais utiliser un use callback. Voilà et ici je vais lui dire que le seul paramètre qui va être utile c'est cette toast si cette toaste a changé il faut que tu recrès cette fonction. Donc je vais sauvegarder je vais revenir dans mon application et importer le use toast voilà ce qui a faire que mon application va remarcher et au niveau de mon vrais part principal je vais entourer mon application du toast contexte provider qui ne prend finalement rien en paramètre et qui se débrouille un petit peu tout seul. Si je clique sur toast à ce niveau là on voit bien votre action à bien marcher et vous allez voir le problème de cette approche c'est qu'on a deux rendus. Vous ne voyez peut-être pas forcément très bien mais lorsque je clique sur le bouton de toast on a un petit cadre qui se met autour. C'est parce que dans ma console j'ai activé la fichage des re-rendus mais en pour résir c'est un petit peu dommage parce que finalement quand j'ai cliqué sur mon bouton j'ai envie d'avoir un nouveau message toast mais j'ai pas forcément envie de re-rendre ce composant c'est pas pertinent. Le problème il est ici on a un use state ici ce qui fait qu'il va devoir re-rendre cette partie là les valeurs vont aussi changer et finalement tous les composants qui utilisent ce contexte vont être infrèchés. Donc cette approche elle est pas forcément optimal et il y a moyen de faire beaucoup mieux et d'éviter justement ce système de re-rendu ce qu'on va faire c'est plutôt que de sauvegarder toutes ces informations à ce niveau là et de sauvegarder l'état des toast à ce niveau là on va plutôt les sauvegarder dans le composant que l'on a créé et au niveau de notre contexte on va simplement sauvegarder la fonction pouche toast et on va sauvegarder ça sous forme de rêve c'est à dire qu'on aura une propriété courante qui représentera notre fonction fonction qui prendra les paramètres de notre toast qu'on pourra mettre comme ça et cette fonction elle ne renda rien donc je peux lui dire de faire juste ça. Si vous êtes en type script nous on envie que finalement cette fonction là elle prenne un paramètre les propriétés du composant toast c'est propriété là. Vous pouvez le faire moi je crée un général un type d'édiat ici comme ça ça m'évite de faire de la répétition en utilisant le type component props et vous pouvez utiliser type of de toast. En fait type of de toast ça vous donne un fonction de components voilà et un component props ça permet d'extraire le type d'é propriété donc là l'avantage c'est que vous pouvez écrire les choses comme ça et ça permettra de ne plus avoir de problème. Maintenant dans notre contexte on veut juste une référence vers cette fonction là donc à ce niveau là on va utiliser un use-ref et vu que je vais avoir besoin de la même fonction de base je vais la mettre dans une variable on va appeler const des fold push également ce truc là donc maintenant ici je lui dis je vais utiliser le default push et à ce niveau là je vais sauvegarder un const on va la plé push toast ref et on va lui dire de faire un use-ref de ma fonction par défaut. A ce niveau là au niveau de ma valeur je lui passe push toast ref. L'avantage c'est que là on aura jamais deux fois un nouveau rendu il fera toujours la même chose et sera toujours la même valeur qu'il va renvoyer. Maintenant mon oeuvre use-t toast bel est plutôt simple il va récupérer depuis le contexte ce push toast ref qui sera finalement notre référence et on aura toujours notre use callback mais qui va dépendre de cette référence et qui fera appel directement à cette fonction. Push toast ref. Point courante et on lui passera le toast en paramètres et ici il faudra bien t'y paix ça pour pas avoir de problème. Je continue maintenant mon composant qui a fiché la liste du toast qui avant était extirpé depuis le contexte mais maintenant ça va être à lui de l'égérer. L'avantage c'est que c'est lui qui va être rendu et plus le reste donc on fait un con en concrèrent à l'état pour gérer la simple des toasts affichés en fait un use state et je lui dis que par défaut ça va être un table ou vide et je vais tipe ce table ou vide en lui disant que ça va être un tableau de params. Ensuite je vais avoir donc depuis le contexte du coup mon push toast ref et il va falloir que je le modifie pour qu'il fasse appel à ce set toast. Donc à ce niveau là je vais lui dire que push toast ref. courante ça sera également à une fonction fonction qui prendra en paramètres un toast du coup qui sera aussi de type params et qui viendra faire un set toast. Ça prendra la valeur initiale et ça veut rien de rajouter le nouveau toast quand l'hu pas sera. Donc ici ça serait toast. Voilà. Et après sur le reste de l'exécution je n'ai rien à faire. Donc si vous voyez la différence c'est que maintenant mon contexte ne sert juste qu'à se garder une référence vers notre fonction. Notre oeuvre que l'avantage c'est que lui ne va jamais changer parce que finalement notre référence elle ne va jamais changer et en fait on utilise l'écrasement dans la référence pour changer le comportement de la fonction sans toucher la fonction. Si je clique sur toast à ce niveau là on a bien votre action à bien marcher. On voit bien que ça s'affiche ici sans que pour autant on a un erreur en vue de ce bouton là. Donc ça permet de bien isoler les choses et de s'assurer de ne pas avoir de comportement un petit peu parasite. L'avantage aussi et là c'est plus une leçon au niveau du type script. Vous voyez qu'on peut utiliser component de propice pour extirper les propriétés. Ce qui fait que si jamais on rajoute une propriété à ce niveau là ça devient une propriété qui devient disponible aussi au niveau de notre fonction. Par exemple je peux tout ça faire ici. Il lui dit bah on va créer un nouveau bouton et ce bouton là, ce qu'est ce qu'il fera il fera un push. Toast et on peut s'imaginer, envoyer un type danger. Vous mettez ici comme content. Error. Si jamais dans mes tostes je décidais que danger n'était plus une possibilité automatiquement dans mon app ça deviendrait une erreur. Ça me permet vraiment de connecter des choses un petit peu isolées à autre à travers d'un seul et unique type. Ça permet d'éviter aussi la répétition et c'est pas mal. Si je clique sur le second tost, on a un message de danger qui fonctionne. Maintenant, imaginons que on est envie de gérer quelque chose où on peut spécifier la durée. Par exemple je peux mettre ici duration et on va mettre la durée serait en seconde. Donc là il me sort une erreur parce que forcément plus rien ne correspond. Dans mon tost contexte je vais lui préciser qu'au niveau de parâme j'accepte en plus que on est une durée. Donc c'est ce sera optionnel qui sera un number. Donc là ma signature fonctionne il n'y a plus de problème. Dans mon tost contexte je vais descendre un petit peu à ce niveau là. Je vais détecter est-ce que dans les paramètres j'ai une durée. Donc ça je vais un petit peu le renommer. Je vais dire que ça va être un objet. J'extrait tout dans le tost mais j'extrait la durée. Comme ça ça me permet d'extrère une donnée mais de garder les autres. A ce niveau là je lui dis si on a une durée. J'aimerais bien que tu fasses un set tost. Tu vas prendre la valeur et tu vas venir retirer le tost un question. Donc ça serait un v.filter et tu vas chercher chaque tost. On va les appeler t et je le veux que tu gardes les émiments que si le t est différent du tost. Je ne suis pas forcément fan ici du nom de mes variables mais la logique devrait fonctionner. Et attention ici faut que je le fasse après une durée donc on fera un set timeout. On lancera cette fonction là qui fera l'écrasement et ensuite on lui dira de le faire au bout de la durée indiquée. Et cette durée on a multiplié par mille parce qu'on avait le précisé qu'on était en seconde. Je clique sur rapide et on va voir qu'au bout d'une seconde l'élément disparaît. Si je clique plein de fois pour pom pom on a plein de dangers et il se masque. Si jamais vous voulez créer en plus un effet d'animation à l'apparition et la disparition, vous pouvez utiliser FrameArmOcean qui est plutôt pas mal. Donc vous faites un NPM install de FrameArmOcean. Ensuite vous allez entourer vos différents éléments ici d'un animate présence. C'est un composant de FrameArmOcean. Ensuite vous pouvez créer une dive particulière. Moi j'aime pas mettre ça au niveau du composant que je préfère entourer d'une dive spécifique. Voilà donc c'est Moshon.div. L'éditeur en général n'importe pas que je vais obliger moi de rajouter ça. Donc ça crée en fait une dive particulière qui va avoir des propriétés supplémentaires qui permettra de gérer l'animation. Et vous avez un petit exemple ici. Par exemple on peut préciser que par défaut ça aura une opacité de 0 et ça arrivera avec une opacité de 1. Et quand on quitte ça fait la même chose. Ce que je peux faire aussi c'est rajouter une transition par exemple faire un X à moins 30. Donc lorsque l'élément arrive il arrivera de la gauche vers la droite. Ensuite il sera un X à 0 et quand il repartira et repartira vers la droite. Comme ceci. Si je clique sur rapide ici, voyez qu'on a sa petite effet d'animation. Alors là avec la console ça donne un peu bizarre mais voilà. Et du coup il faudra basculer la clé à ce niveau là. Sinon l'animation qui fait un peu n'importe quoi quand on n'a plus le voir. Mais on peut aussi s'imaginer. Alors on va peut-être enlever la durée ici. Voilà parce que ça peut être un petit peu pénible. Pour pouvoir aussi cliquer sur une tost pour le supprimer si jamais on a des tost qui ont une durée illimité. On pourrait aussi avoir un petit petit croix pour les fermer dans certains cas. Moi je préfère carrément faire au clic ici. Donc à ce niveau là on va s'imaginer créer une constante qu'on va appeler OnRymove. Cette fonction lui passera un paramètre le tost à supprimer qui serait de type parâme. Finalement un petit peu comme tout le reste. C'est là que j'oralise que le nom parâme c'était pas forcément un type top. Et on utilisera la même fonction que celle qu'on en a écrit ici. Voilà. Et à ce niveau là je peux lui dire lorsque tu cliques sur cette livre OnClick, j'aimerais bien que tu fasses un OnRymove. Et que tu supprimes littéralement question qui sera le tost. Donc on réessaie Je clique sur tost, danger, tost, danger. Je clique à ce niveau là. Et on voit que l'animation fait un petit peu n'importe quoi. Le problème c'est que finalement quand je suis capable ici de supprimer un élément à l'index 2, ça va changer tous les index et le système de clé n'est pas forcément très adapté. Donc la meilleure solution c'est d'utiliser un ID pour gérer ça. Donc à ce niveau là lorsque je vais 7 un tost, je vais en profiter pour rajouter en plus un ID. Donc ça je vais plus l'appeler tost mais je vais appeler Props finalement et je vais faire une nouvelle constante tost et je vais les dire que ça sera donc les différentes Props que j'ai reçues et je rajoute en plus un ID et dans mon cas ici j'utilise la date du jour. Donc c'est un mille seconde donc c'est très peu probable que j'ai en une même mille seconde de deux notifications qui apparaissent au même moment. Vu que j'ai cette ID je peux l'utiliser un clé à ce niveau là tost.id. Le problème c'est qu'il va me dire que l'ID ne le connaît pas. Donc là c'est spécifique à Tabs Script, vu que j'ai tout tipez avec Params. Ça pose un souci. Donc à ce niveau là je vais créer un nouveau type que je vais appeler tost qui sera les component props de ce truc là et qui aura en plus un ID qui sera obligatoire et qui sera un number. Et on va l'appeler tost item. Je peux pas l'appeler tost parce que c'est déjà le nom qui est utilisé pour le composant. Maintenant que j'ai ce type là je vais pouvoir l'utiliser au niveau de mon composant. Je vais lui dire que dans le state on aura des tost items. Donc ensuite on est bon, on est bon, on est bon. Et c'est tout ce que j'ai à changer je pense. Peut-être là non le on remouve, on va supprimer un tost item et c'est tout. On va refaire un essai donc je clique sur tost rapide tost rapide. Voilà je clique sur fermé ici et on voit bien que ça fonctionne convenablement. Alors peut-être un dernier petit détail mais là c'est vraiment de l'optimisation. On va s'imaginer que nos différents tostes ont par défaut une durée de 5 secondes. Donc à ce niveau là je vais lui dire que je vais retirer ça et on va préciser que la durée sera par défaut à 5. Donc je clique ici, je clique ici, on voit qu'on a des reurs rendus et à chaque fois qu'un élément va être supprimé au bout de 5 secondes on a de nouveau reurs rendus. Mais regardez ce qui se passe. Si je clique ici sur tost, je clique encore sur tost et je choisis de fermer le dernier qui est arrivé. Je vais avoir deux refreshissements parce que lorsque on a ce style mount qui est exécuté, il fait nécessairement ce filtre. Mais ça un petit peu dommage parce que c'est pas utile de le faire si l'élément a déjà été supprimé et du coup n'est pas déjà dans la liste. Une solution serait de sob garder en fait dans les tostes le timer en plus. Donc là dans la partie où on a rajouté l'ID, vous pourrez lui dire que vous attendre ryer un timer qui serait du return type de type of set timeout. Voilà, je pense que ça ça devrait fonctionner. Et à ce niveau là on inverseer un petit peu les choses on a systématiquement un timer c'est intéressant ici. On fait un const timer égal ce truc là. On rebascule les tostes après coup. La calcul de l'ID on le fait avant. Ici constID égal. On va utiliser cetID pour faire la séparation à ce niveau là. Donc on lui dirait qu'il faut trouver tous les éléments que l'on aID différent. Ce qui nous permet de ne pas dépendre de la variable tost un amont comme ceci. Et à ce niveau là on pourra toujours lui donner l'ID et on pourra aussi lui donner le timer qui sera ce timer là. L'avantage est alors que lorsqu'on fait un ennemi move manuel, on peut choisir manuellement de venir faire un clear timelot et de venir supprimer ce timer pour venir annuler le rendu avant qu'il se déroule comme ceci. Je vais avoir un rendu en moins. Alors pour m'en assurer, je pense que la meilleure solution serait d'enlever ça. Voilà. Et de faire un console point log de rendeur à ce niveau là. Pour que vous voyez le nombre de fois que ce composant est rendu. Normalement pour trois appels avec un clic pour supprimer, on obtient, je pense, 18 appels. Voilà. Donc on a 18 messages. Mais par contre si je viens à faire le clear timelot, ça va m'économiser quelques petits rendeurs. C'est faible mais il faut penser à chaque moment dans notre application si on peut optimiser un petit peu les choses, c'est toujours intéressant. Donc là on a deux rendus qui ont été évité, qui sont les rendus qui correspondent au cet timeout, qui correspondait finalement au timeout qui est utilisée dans le vide. Voilà. Pour une petite astuce, c'est une micro-optimisation à ce niveau-là. Et vous savez maintenant comment créer ce système de logique. Donc moi je trouvais intéressant de vous montrer cette approche là, parce qu'elle vous permet de voir un petit peu comment vous pouvez optimiser les choses et comment parfois le chemin naturel n'est pas forcément le plus optimisé. C'est vrai que pour afficher une liste de tos dont vous pouvez s'imaginer qu'avoir un contexte qui contient l'ensemble des items, c'est le plus simple. Mais au final, c'est pas forcément le plus optimisé dans le cadre de réactes en tout cas, parce que ça cause des rendus et ce n'est pas forcément optimal à un table de performance. Mais si on utilise une rêve, c'est beaucoup plus efficace parce que ça nous permet de ne pas avoir trop de rendus et de toujours pouvoir passer une fonction. Finalement, c'est cette rêve là que l'on va pouvoir modifier et qui va nous permettre de modifier des fonctions à distance sans avoir de problème. Et on a utilisé pour la descente des informations, le système de contexte. Mais il faut savoir que ça fonctionnerait tout aussi bien si j'ai exporté cette fonction là. Et que à ce niveau là dans mon main, je n'utilisez que le composant qui contient les tosts. Ce composant sans son contexte autour. Aussi étrange que ça puisse paraître, ça va quand même fonctionner. Parce que finalement, ce que va juste faire ce composant c'est qu'il va modifier la propriété courante et modifier quelque chose. C'est ce qu'il fait au niveau du push-toast, d'un rêve point courante. Donc même si on n'a pas de contexte vu qu'on a par défaut ou cet objet là, il modifira quand même cet objet là, qui sera ensuite récupéré par les use contextes, vu que c'est la valeur par défaut. Donc malgré tout, ça permet d'avoir le comportement. Dans tous les cas, moi, je trouve qu'il a tout à son devoir ajouter un composant, autant ajouter un contexte provider qui va entourer notre application, ça revient au même. C'est finalement un composant à ajouter. Et l'avantage c'est que le système de contexte nous parlera un petit peu plus. Ce qui peut aussi être cool, c'est qu'on peut avoir dans des tests, un contexte qui serait différent, on pourrait imaginer créer un spy contexte provider, qui permettrait d'avoir une référence qui serait un petit peu différente, sur laquelle on pourrait espionner les choses. Et vérifier quand est-ce que le courante est modifié ce genre de choses. Mais voilà un exemple d'organisation pour créer ce système de toast. J'espère que cette vidéo vous a plu et je vous donnera des vous dans la prochaine vidéo. Ciao !