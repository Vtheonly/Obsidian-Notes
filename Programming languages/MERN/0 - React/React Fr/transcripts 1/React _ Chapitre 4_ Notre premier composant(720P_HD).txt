 A bienvenue dans ce nouveau chapitre, nous allons parler des composants. Vous allez le voir, les composants savent être à la base du fonctionnement et du travail avec réactes et c'est ce qui fait véritablement sa force. Donc ce que je vous propose, c'est de tout supprimer et on va repartir de zéro. Donc notre idée, c'est de créer un titre et ce titre va dire bonjour suivi du nom de la personne et on va utiliser un hm pour ça. Donc par des fausses que l'on ferait, c'est qu'on crée notre fonction qui renverait notre hm qui ferait notre contenu. Mais ce qu'on va pouvoir faire, c'est créer un composant. Donc un composant, c'est ni plus ni moins qu'une fonction. Donc on va l'appeler, welcome. Et cette fonction, elle prendra un paramètre des propriétés. Donc nous on va appeler sa proche. Ensuite ce que fera cette fonction, c'est qu'elle retournera à un nouveau neux réactes. Donc nous on retournera un hm avec marqué, bonjour. Pour l'instant, ne sais pas comment passer le nom. Maintenant, si je souhaite utiliser ce composant-là, je peux l'utiliser à la place des différentes tags que je mettrais normalement dans un élément. Donc par exemple, ce que je peux faire, c'est faire un réacte d'hommes, faut un randeur, et je vais lui demander de rendre à l'intérieur un welcome comme ceci. Et vu que je ne mets rien à l'intérieur, je mets une fermeture. En seconde paramètre, je vais lui demander de rendre ça dans l'élément qui a comme Heidi, App, comme on l'a vu tout à l'heure. Si je sauve garde et que maintenant je réactuise ma page, je vois bien que j'ai marqué bonjour. Mais ce qui est très intéressant, c'est qu'avec ces composants-là, comme on le voit avec ce paramètre, on va pouvoir passer des propriétés. Donc ce que je peux faire, c'est par exemple lui rajouter ici un nouvel attribu qui sera transféré comme une propriété, et c'est un attribu ça s'appelle Rannane. Et je mettrai le nom de la personne, par exemple le genre. Si maintenant dans mon welcome je fais un console point log et je log props, qu'est-ce que je vais voir ? Je vais voir tout simplement que j'ai un objet qui contient comme clé, name. Donc c'est le nom de la propriété qui a été envoyée. Ce que je peux faire après mon bonjour, c'est lui dire ici d'afficher props.name. Si je sauve garde, je vais bien voir bonjour Jean. Si je change le nom, on va mettre doroté. Automaticement, ça change les choses. Donc ça nous permet de créer des éléments qui vont être dynamiques et que l'on va pouvoir réutiliser et ça permet d'améliorer la conception. Alors souvent ce que l'on va faire, c'est que lorsque l'on prend des propriétés qui sont nécessaires, plutôt que lui dire ici je prends props et ensuite je fais props point name, on va plutôt utiliser un objet, en lui disant je prends un objet qui recevra le nom. Et après je peux utiliser directement non. J'utilise la destructuration ici. Pourquoi on fait ça ? Tout simplement parce que quand on analyse le code de cette fonction, ça permet de comprendre beaucoup plus aisément que finalement, on recevra une propriété ici qui s'appelera name et ça permet quand on écrit notre composant, de mieux comprendre sa structure. Et vous pouvez vous en rendre compte lorsque vous surez les welcome, on voit que notre éditeur dit attention, mais ça, ça prend name en paramètre et name peut être de n'importe quel type. Donc on voit que ça nous donne un peu plus d'information et c'est pratique. Alors maintenant on peut se dire, on a envie par exemple d'avoir une petite phrase de présentation. Donc je vais laisser mon welcome ouvert et je vais ici mettre du texte. Bonjour tout le monde. Et je vais faire même un welcome derrière. Comment je peux récupérer cette partie là ? Donc ça on peut le récupérer grâce à une propriété particulière qui s'appelle Chindrone. Dans les propriétés que je reçois, je aurait toujours une autre propriété qui s'appelle Rattchindrone qui contiendra les enfants. Donc si je le souhaite, je peux ensuite afficher ses enfants ou je le souhaite dans mon composant. Donc par exemple ici, je vais créer une dire. Je vais mettre d'abord mon achet, puis lui dire les enfants vont être dans un paragraphe ici. Et dans ce cas là, ça fait bonjour de rôté et ensuite, ça met le contenu qui a été demandé à cet endroit là à l'intérieur de notre composant. Si je regarde bien, c'est bien dans mon paragraphe. Donc les composants vont vous permettre de réutiliser au maximum votre code et de créer des blocs que vous allez pouvoir conserver et utiliser de manière modulable. Alors ça c'est la première manière d'écrire les composants. Donc c'est une manière qui utilise l'approche fonctionnelle, mais il faut savoir que vous avez une autre manière de créer les composants qui est une structure sous forme de classe. Alors ça je vais le renommer Welcome Function et on va créer une nouvelle classe que l'on va appeler Welcome. Cet classe, pour lui dire qu'elle va fonctionner comme un composant react, on va la faire étendre de react point component. À l'intérieur, il faudra nécessairement une fonction qui va s'appeler Render. Cette fonction se occupera du rendu et devra retourner à l'élément. Donc ça c'est exactement la même chose que ce qu'on avait écrit précédemment. Si maintenant on a besoin des propriétés, il faut savoir qu'elles sont passées au niveau du constructeur. Et ensuite elles sont récupérables en faisant un vis point props. Donc si je fais ici un console point log et que je regarde dans mon objet à quoi ressemble props, automatiquement je vois dans ma console que j'ai bien mes différentes clés. Donc après libre à moi de rendre la même chose au niveau de mon fond, une main fonction au Render comme ceci. Et il ralent parce que ici c'est vis point props, point name, et ici ça sera vis point props point shield run. Donc c'est props comme je vous disais elles sont appelées au niveau du constructeur. C'est juste pour vous montrer mais le constructeur il servira un petit peu plus de choses. Mais si ici je fais un console point log de props, je vais tout de suite avoir une petite erreur parce qu'il faut nécessairement appeler super pour appeler la méthode parente. Donc ça c'est bien important ne l'oubliez surtout pas parce que ça c'est créer des problèmes. Et là je vois bien que dans props que je reçois au niveau du constructeur, j'ai bien mes paramètres name et shield run. Et voilà c'était juste pour l'exemple. En vrai si vous n'avez une attention dans l'infer au niveau du constructeur, ça suffit comme ça. Voilà pour le principe de base d'un composant. C'est quelque chose qui est très utile pour mieux décomposer la structure de notre application. Donc vous pouvez aussi par exemple si on veut une liste de plusieurs personnes qui vont être accueillies, on pourrait se créer une place, que l'on appellerait homme. Là les limites on va créer simplement une fonction, qui va s'appeler homme, qui ne va apprendre aucune propriété et qui fera un return. Donc on va mettre une dive, on ne va pas utiliser des fragments pour l'instant. Et à l'intérieur on met notre premier welcome et on met d'oroté. Donc là on va mettre d'oroté. Ensuite on ne met rien à l'intérieur et j'affiche le nom d'une autre personne, j'encompe ça. Et je vais ensuite utiliser ce composant-là à la place du composant welcome lorsque je monte ma structure HTML. Comme ceci. Et je ferme de suite. Dans ce cas-là ça va répéter deux fois le nom de la personne. Donc je peux réaliser ce composant à plusieurs reprises et même utiliser un composant dans notre composant. Ça ne pose aucun problème. Maintenant on va parler de la notion d'état au sein d'un composant et des cycles de vie. Alors on va tout simplement s'imaginer d'un autre page d'accueil, on aimerait bien avoir quelque chose qui affiche la date du jour. Donc on va créer une nouvelle place que l'on va appeler, clock, comme hors loge. Cette classe elle va étendre de React.component. Et ensuite à l'intérieur je fais un render, un render. Et je fais un return. On va s'imaginer créer une dive. Et à l'intérieur de cette dive on aurait la date du jour. Donc je vais créer une nouvelle constante qui va s'appeler date. Je vais faire un new date pour créer une nouvelle date. Et ensuite à l'intérieur ici, je vais lui demander de faire un date. Point, tout, local, string. Et je vais mettre il est pour afficher l'heure juste avant. Maintenant j'utilise ce système d'or loge dans mon composant homme. J'ai tapé avoir accueilli un petit peu tout le monde. Donc j'utilise mon composant clock qui n'a pas d'enfant. Donc on me donne bien l'heure. Et si je veux le temps, je vais rajouter op.dat.local.timstring. Donc le problème c'est que cet or loge elle n'est pas du tout dynamique. C'est pas pratique pour les utilisateurs ainsi il laisse la page à afficher tout le temps. Donc ce que l'on va pouvoir faire c'est utiliser un état. Donc pour créer un nouvel état, il faut utiliser le constructeur. Donc on crée un constructeur. Il prend en paramètre les propriétés et qui fait super de props. Ça c'est toujours nécessaire. Maintenant, on va pouvoir définir l'état de notre composant. C'est un objet qui va représenter les données qui sont utiles à l'intérieur du composant et qui ne seront pas forcément exposés par des propriétés. Donc l'état c'est simplement un objet et il est accessible grâce à une propriété spécifique qui est state. Donc c'est un objet et moi je vais lui donner une clé date qui contiendra notre date. Donc par défaut, je vais lui donner comme valeur initiale, new date. Maintenant, si je souhaite utiliser cet état-là au niveau de notre affichage, il me suffit simplement d'utiliser visp.state.date et ici visp.state.date. Si je sauve garde, ça va réafficher les informations mais ça ne fait pas toujours l'actualisation automatique. Donc pour avoir leur affrichissement du temps, il va falloir utiliser un interval et toutes les secondes changent la valeur de la date. Donc c'est là qu'on est bloqués à quel endroit on va pouvoir faire ça, parce qu'on veut le faire que dans ce composant-là, on ne veut pas avoir à lancer des reindeurs tout le temps. Donc on va pouvoir pour cela utiliser les cycles de vie d'un composant. Donc on va avoir deux fonctions qui sont intéressantes mais il y en a plein d'autres qui sont les fonctions component d'id, mante, qui permet de déterminer quand un composant a été monté et component Will, un mante, quand un composant est supprimé. Donc attention, c'est un séminuscul. Ce que je peux faire ici, c'est dès le début, lui dire visp.timer.nl parce que j'initialise la valeur, on n'a pas de timer au début. Quand le composant est monté, je vais créer un nouveau timer en faisant visp.timer.nl et il y a le Windows.nc Interval. J'ai mal écrit les choses. Cet Interval. Et je vais lui dire de lancer ça tout les secondes. Et lorsque je démonte mon composant, je vais lui dire de faire un Windows.nc.interval. Et je veux que tu supprimes l'interval et s'offre garder dans la variable timer. La dernière chose qui nous reste à faire, c'est savoir qu'est-ce que l'on met ici? Ce que l'on devra mettre en l'intérieur de cette fonction, c'est simplement un appel à une fonction qui va venir changer l'état. Nous je vais aller créer une nouvelle fonction qui va s'appeler le tic, qui permettra de changer l'état. Pour changer l'état d'un composant, il faudra utiliser la méthode de cet state. Donc on fait visp.setstate et on doit lui envoyer un objet qui représente le nouvel état. Moi, je lui dis, je vais changer la date et mettre une nouvelle date. Donc cette méthode va changer l'état. Donc au niveau de mon timer, je vais pouvoir lui dire, dans cette fonction-là, j'aimerais bien que tu appelles la méthode tic. Attention, si je fais ça, le contexte de visp sera perdu, donc je vais lui dire de binder visp pour ne pas avoir de problème. Maintenant, je vais sauver des idées et je remarque quelque chose. La date se met automatiquement un jour. En fait, lorsque notre composant est monté, donc lorsqu'il arrive ici et qu'il est mis dans notre dom, automatiquement, il appelle le component d'idement qui va demander une mise à jour de l'état toutes les secondes et à chaque fois que l'état se met à jour, ce que va faire réacte, c'est qu'il va re-rentre notre composant. Il va comparer les modifications comme on avait vu tout à l'heure lorsqu'on avait parlé de la fonction Render de réacte d'hommes. Il va voir que seule la date a changé et du coup, il ne mettra à jour que cette information-là. Et c'est ce qu'on voit ici. La date est mise à jour toutes les secondes. Si vous voulez un apprendre un petit peu plus sur les différentes fonctions qui sont disponibles, il faudra vous rendre sur la partie d'ocumentation. Vous allez aller d'un appeler référence. Un appeler référence, c'est plus quelque chose qui contient les informations de brûte, on va dire. C'est moins sanguie de mes pluss une référence. Et si vous cliquez sur réacte.com. On va vous montrer l'ensemble des méthodes qui sont disponibles. Et vous avez ici le Lifecycle qui vous explique le cycle de vie. Donc ça, c'est quand même composant est monté, quand même composant est mis à jour, quand même composant est démonté, et vous avez l'ensemble des fonctions que vous pouvez utiliser et des propriétés qui sont disponibles au niveau de votre composant. Donc c'est ça qu'il faudra lire. Si vous avez besoin de plus d'informations, et si vous voulez découvrir l'intérêt de certaines méthodes. L'avouement pour ce que l'on veut faire, le component de monde, le component de dit de monde, et le component de mille à demande, et largement suffisant. Ce que je vous propose de faire, c'est maintenant de créer un nouveau composant. Donc celui-là, on va le laisser de côté. Et on va créer un composant qui incremente. Donc on fait une classe qui va s'appeler incrementeur. Et on va étendre de réacte.componente. À l'intérieur, je vais vous laisser écrire le code. J'aimerais bien avoir quelque chose qui incrementa un chiffre toutes les secondes. Et on le mettra juste après notre horloche, comme ceci. Et on mettra peut-être une propriété qui sera la valeur de départ. Donc là, on recevra ici un start, et je vous donnerai comme valeur 0. Même à l'heure, on va mettre 10. Donc votre objectif, c'est de créer un composant qui commence à 10, et qui toutes les secondes va incrementer la valeur. Je vous laisse essayer de créer le code et on corrige ça ensuite ensemble. Donc on est parti. Je vais commencer par créer mon constructeur. Donc je fais constructeur, et je vais recevoir un paramètre une propriété. Ensuite, je appelle tout de suite la méthode super de props. Tout de suite aussi, j'utilise la méthode Render pour rendre mon composant, et je retourne une simple tif. Alors le problème, c'est qu'on recevra lors du montage de la valeur initiale, mais ensuite, il faut pouvoir incrementer la valeur et garder notre état. Donc ça veut dire que ce composant-là a besoin d'un état pour conserver le nombre que l'on va incrementer. Donc dès le début, je vais faire un vis.state. On va lui passer un paramètre une valeur qu'on va appeler N, et on lui mettra comme valeur initiale, props.start. Maintenant, tout comme pour notre horloge, on va avoir besoin un petit timer. Donc tout de suite, je fais vis.timer, également nulle. J'attends que le composant soit monté. Donc c'était Component DiedMente. Et lorsqu'il est monté, je vais démarrer mon timer. Je vais faire un Windows.setInterval. Je vais lancer la méthode Tick. On va l'appeler avec le même nom. On va l'appeler increment. Ça sera un petit peu plus simple. Et on buying vis pour ne pas avoir de problème. Et un second paramètre, je lui donne un interval. Ici, on va mettre une seconde. Je vais écouter le Component Wheel and Mente. Et lorsqu'il est non monté, je fais un Windows. Point clearInterval. Et je supprime mon timer. Donc là, le principe est vraiment le même. Que d'aut à l'heure. J'ai besoin maintenant d'écrire ma fonction incremente. Donc je fais incremente. Donc ça sera une fonction qui fera un vis.state. Et qui changera la valeur de N. Donc là, je mettrai N et Gal. vis.state.n plus comme ça, j'ai incremente la valeur de 1. Maintenant, au niveau de ma vie, je peux lui dire valeur de point. Et je vais lui donner d'afficher vis.state.n. Je sauve garde. Et je vois que ça commence à 10 et que ça continue de 1 an. Alors maintenant, petit mis en garde concernant ce qui est système là. Il faut faire attention parce que le set state peut être groupé par React. C'est-à-dire que parfois, quand vous allez avoir plein d'opérations qui vont être dans le même temps, React va appeler les set states de manière consécutive. Et ce qui peut se passer ici, c'est que, en vue qu'on utilise le state pour construire le nouveau state, ça peut amener à des problèmes. Donc dès que vous faites un set state qui va modifier l'Etat, ce qui est conseillé de faire, c'est plutôt ici de créer une fonction qui prend en premier paramètre l'Etat et un second paramètre les propses. Et cette fonction, ce qu'elle devra retourner, c'est le nouvel État. Donc c'est à ce niveau là que l'on mettra que n sera égal à state point n, plus un. Si je sauve garde, ça ne change absolument rien au fonctionnement, mais ça permet d'éviter les problèmes si on a plusieurs fois des sets states consécutifs qui sont appelés. Prenez cette réglue d'or. Elle est très importante. C'est que si jamais votre changement d'Etat dépend d'un État ou d'une propriété, mieux vous le mettre dans une fonction. Donc mieux vous écrire ce cas de là. Donc vous pouvez ensuite le simplifier en effet une fonction fléchée. Vous pouvez le dire, oh, fais ça et ça, ça sera directement le retour. Et tu peux retourner quelque chose qui ressemble à ça. Après, c'est pas forcément plus lisible selon moi, mais chacun fait comme il veut. Là, on a un stem qui s'incrémande de 1. Et qui ne posera pas de problème si on a plusieurs sets states qui sont lancés en même temps. Alors, autre petite détail importante pour ceux qui n'aurait pas fait intention, mais chaque fois que le composant est monté, il est monté avec un État qui est individuel. C'est-à-dire que je peux avoir un incrementeur ici qui commence à 10 et avoir un autre incrementeur qui commence à 100 sans avoir de problèmes comme ceci. Et là, on voit que les deux fonctionnent de la même manière. Ce que l'on pourrait s'imaginer, c'est aussi avoir une propriété qui serait le pas. On pourrait lui dire ici, step et on veut aller dans ce cas-là de 10 en 10. Essayer de faire ça et on corrige ça juste après. Donc, pour avoir le pas, il faut que dans les propriétés, je reçois à ce steps et je peux donner une valeur initiale par défaut. Donc, si vous avez regardé rapidement lorsqu'on avait parlé de la référence de la pays, réacte componente, si je dessin un petit peu ici, hop, hop, on avait des fold props. Donc, des fold props permet de définir les propriétés qui seront reçus par défaut. Donc, moi, je peux lui dire que pour mon composant, la propriété step aura une valeur initiale à 1. Ça m'évite de devoir faire une quelconque logique ailleurs. Donc, je vais ici me placer sur un incrementeur et lui dire que pour un incrementeur, les propriétés qui sont par défaut, c'est tout simplement une valeur initiale à 0 et un step à 0. Voilà. Ça ne change rien pour l'instant. Maintenant, lorsque j'incrémente, je peux utiliser props. Et dans ce cas-là, celui-là va s'accrémenter de 10 en 10. Alors que l'autre va s'incrémenter de 1. Plus tard, quand le javascript et le support sera amélioré sur les navigateurs, on aura la possibilité de mettre ici statique, des fold props et de mettre des propriétés par défaut. Pour l'instant, vu que ça ne fonctionnera pas sur tous les navigateurs, je vais me contenter d'écrer les choses de cette manière-là. Mais voilà, comment vous pouvez créer des systèmes qui vont vous permettre d'avoir de la logique réutilisable. Alors là, on a créé des composants tout-bet, mais on peut s'imaginer très bien, plus tard, pour des formulaires, si vous utilisez bootstrap, par exemple, qui a une syntaxe et une structure HTML complexe, vous pourriez avoir un field, field, et vous pourriez lui mettre le label ici, et vous pourriez avoir le nom du champ à ce niveau-là. Et vous pouvez avoir comme ça tout un tas de logiques que vous allez pouvoir réutiliser, et vous allez pouvoir vous créer des composants qui vont vous simplifier le travail pour créer des éléments dynamiques en javascript. Donc dans le prochain chapitre, je vous propose de parler des événements et on va voir comment un nou en tant que utilisateur on peut interagir avec l'application et faire en sorte de modifier certains éléments.