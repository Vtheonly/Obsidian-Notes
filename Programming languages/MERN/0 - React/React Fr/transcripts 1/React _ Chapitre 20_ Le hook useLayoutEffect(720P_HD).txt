 A bienvenue dans ce nouveau chapitre, je vous propose de parler d'un nouveau OOK qui ressemble étrangement aux use-effects mais qui a une méthode de fonctionnement qui est différente. Pour comprendre la différence, entre use-effect et use-layant-effects, je vous propose un petit exemple. On va créer une constante qui va permettre d'incrémenter les choses. Vous avez vu, c'est vraiment le fil rouge de cette formation. Donc, à l'intérieur de cette constante, on va utiliser un état et on va lui donner comme valeur initiale 0. Ensuite, on va créer la fonction qui va permettre d'incrémenter. Je vais utiliser le use-call-back pour pouvoir ensuite faire appel à cette coute et incrementer les choses. On pourrait aussi se créer ici un OOK personnalisé. Pour l'exemple, on ne va pas trop s'embêter à ce niveau-là. Donc, à l'intérieur de cette fonction, je lui dis, tu récupéras l'état et tu feras un C plus un. Au niveau des dépendances, je ne méris, parce que finalement, ce cet coute n'a pas besoin de l'état précédent. Donc, on peut le relancer. Donc, on peut le garder en mémoire systématiquement. Maintenant, je vais créer un petit bouton et je vais mettre incrementer à l'intérieur. Et, lorsque l'on clique sur ce bouton, je veux que tu fasses appel à incrementer. Et je mettrai la valeur d'incrémentation juste après. Donc, comme on l'avait dit, le use-effect permet de détecter lorsqu'il y a des changements et de lancer un processus particulier. Donc, on peut le dire ici, je veux créer un use-effect et lui dire que, tout de suite, je vais changer la valeur du bouton ou afficher quelque chose en console. Donc, moi, je vais mettre ici un console point log de coute. Et, ce que je vais faire pour simuler une opération de lante, je vais lui dire d'attendre pendant 1000 secondes. 1000 secondes. Sinon, ça reste que d'être un petit peu long. Donc, je réactue l'isme à page. Je clique sur incrementer. On voit que le chiffre change instantanément et ensuite on a le 1 qui s'affiche. Donc, ça nous permet d'illustrer une première particularité du use-effect. C'est qu'il est asynchronous. C'est-à-dire que le code qui est un édauréat de cette fonction ne va pas être exécuté avant que le rendu de nos changements soit fait. C'est-à-dire que réacte va changer l'interface avant d'exécuter ce code-là, ce qui permet, si jamais, en a des opérations de lourdes dans le use-effect, de ne pas affecter le temps de rendu. Si maintenant, j'utilise l'autre ouc, le use-leia-out-effect. On n'oubliera pas d'importer tout en haut si ce n'est pas déjà fait. Ceux que là, va exécuter la fonction de manière synchrone. Si je réactue l'isme à page, je clique sur incrementer. Et on voit qu'il se passe une seconde avant que le statut change au niveau de notre page. Alors on peut se dire, finalement, à quoi ça sert du coup d'avoir ce use-leia-out-effect, c'est un petit peu dommage, de bloquer l'interface pour un petit traitement. Ça peut être très utile si vous voulez affecter des éléments au niveau... Si vous voulez appliquer en plus des modifications au niveau du dom. Par exemple, je peux vous imaginer, je vais avoir une constante button et à l'intérieur, je ferai un use-ref et je mettrai la valeur nue initialement. Je me dis au niveau du changement, dès que, par exemple, le chiffre dépasse une certaine valeur, j'aimerais bien changer la couleur du bouton et donner une couleur verte. Si le chiffre est paire et rouge, sinon, ou je ne sais quoi d'autre. Dans ce cas-là, on a envie de modifier le dom. Et c'est pertinente d'utiliser le use-leia-out-effect parce qu'on veut que ce changement-là soit appliqué sur le bouton, avant même le rendu. On ne veut pas attendre que réacter le rendu pour ensuite appliquer nos changements. C'est pour ça qu'il y a le mot clé layout, c'est que c'est déclenché avant le dessin au niveau d'une navigateur. Donc c'est au moment où le navigateur vient de changer le layout et qu'il n'a pas encore appliqué visualement les changements. Par exemple, ici, je pourrais faire un button.stil.attention. C'est point courante.stil. Point color et je changerai pour mettre du rouge. Au niveau des dépendances, ici, je n'en mets aucune parce que je veux qu'il exécute systématiquement ce codon. Donc je réactualise ma page. Il me sortira alors une erreur parce qu'il me dit qu'il n'arrive pas à dire style parce que pour l'instant, je n'ai pas appliqué la référence. Donc là, je lui dirai, la référence pour ce bouton c'est bottom. Et maintenant, lorsque je réactualise la page, on voit bien que c'est un rouge. Si j'applique le comportement que je voulais faire, en lui disant si le compteur module O2 est égal à 0, dans ce cas là, c'est que le chiffre est paire et je vais le mettre en verre. Dans le cas contraire, c'est que le chiffre est un paire et je veux le mettre en rouge. Alors clairement, ce n'est pas la meilleure manière de faire les choses. On pourrait utiliser la tribus style au niveau de la partie virtuelle d'homme. C'est juste pour vous illustrer concrètement la différence qu'il va y avoir au niveau du rendu. Et ça, ça va dépendre de coups. Si je ressort garde, c'est verre et dès que je change la valeur, ça change bien de couleur. Donc c'est pertinent d'utiliser ça dans le use-layer en effect parce qu'ici, on veut manipuler le dom avant le rendu. Use-effect, lui, fonctionne de manière AsyncRone, et ne va pas bloquer le process, tant que les modifications n'ont pas été affichées à l'utilisateur. Donc si vous avez des traitements et des manipulations à faire sur le dom, il faudra plutôt utiliser Use-layer en effect. Si vous avez plutôt des effectes bordes qui n'affectent pas la partie interface, mieux voudrais utiliser le use-effect car ce n'est pas bloquant. Donc voilà pour cette petite différence.