 Bienvenue dans ce nouveau chapitre, nous allons parler ensemble de la syntax GSX. La syntax GSX est une syntaxe qui va nous permettre de décrire du réact un petit peu plus simplement et d'éviter d'avoir à utiliser la méthode React.cruite-elemente à chaque fois. Le problème, c'est que le GSX est une syntaxe qui est propre à un réacte et qui n'est pas forcément supporté par l'innoviateur et qui ne le sera probablement jamais. Il nous faut un outil qui va permettre de convertir cette syntaxe là en javascript classique. Donc c'est outil là, il s'appelle Babel. Babel, c'est un outil qui est plus générique, qui permet tout simplement de convertir du code en écrire un javascript au modern et de sortir du code qui fonctionnera sur des navigateurs un petit peu plus anciens. Et il supporte différentes fonctionnalités dont notamment la possibilité d'écrire du GSX. Si je prends par exemple un des exemples qui est fournie dans la documentation, on va prendre cette exemple là et que je me rends sur Babel et que je mets ici dans la partie Traitable le code, je vois que ça me donne bien cette partie qui est élément. Donc pour utiliser Babel, on va devoir utiliser un outil que l'on va installer sur notre ordinateur ou temporairement si on veut juste essayer le GSX, on peut utiliser une version qui va fonctionner directement sur l'innoviateur. Donc lorsque vous allez dans la documentation, vous allez ici sur Ajouter React à un site web et on vous donne différentes informations et ici je descends encore un petit peu en bas, on va me parler de Babel. Donc vous avez la possibilité de charger ce javascript qui va permettre de faire fonctionner Babel au niveau d'une navigateur. Alors attention, je tiens vraiment à le préciser cette manière de faire les choses, ce n'est utile que pour le développement. C'est très très peu performant et ce n'est pas du tout quelque chose que l'on conseillera d'utiliser en production. Donc là, nous on va l'utiliser parce que notre but c'est juste de découvrir React, mais à terme ce que l'on fera, c'est qu'on installera un outil sur notre machine qui va convertir les fichiers pour qu'il fonctionne avec la fonction cuillette élémentte que l'on a vu. Donc je vais prendre ce javascript et le mettre au niveau de mon HTML au dessus de mon app.js. On va le mettre ici. Au niveau de mon script ici, je vais rajouter un nouvel attribute type et je vais mettre comme un attribute texte slash Babel. Ça va permettre d'indiquer que ce script là devrait être converti avec Babel. À partir de là, je peux maintenant utiliser la syntax GSX à l'intérieur de mon fichier javascript. De manière générale, quand un fichier utilisera la syntax GSX, on aura tendance à renommer le fichier avec l'extension GSX pour facilement faire la différence et aider aussi notre éditeur à comprendre qu'on va utiliser cette syntaxe là. Ici ce n'est pas forcément nécessaire de le faire, on peut directement commencer à travailler dessus. Donc imaginons, j'ai envie de convertir cette partie ici. Comment ça va se passer ? Donc je vais supprimer ce que j'ai écrit et on va utiliser le GSX. Donc en fait, pour recommencer à écrire un élément, il suffit d'utiliser une syntaxe qui est assez proche de l'HTML. Donc par exemple, je peux faire un H&M avec un intérieur marqué. Bonjour les gens. Donc vous voyez, mon éditeur souligne pas les choses et il comprend tout de suite que je travaille avec du GSX. Si maintenant je regarde ma page web, je vois bien que j'ai marqué bonjour les gens. Alors le problème dans l'entre case, c'est que ensuite on voulait ne se pas ne pas de problème, vous pouvez simplement aller à la ligne et vous allez mettre votre span comme ceci. Et à l'intérieur, on va y mettre pour l'instant un numéro. Si je sauve garde, ça veut donner bien mon numéro. Donc je peux même rajouter un petit espace. Alors attention, si vous mettez un espace là, ça ne va pas fonctionner parce que lui, il va supprimer les seaux de lignes. Donc faudra écrire les choses comme ça ou utiliser un espace insécal. Maintenant, j'aimerais bien ici qu'il interpole la variable. C'est à dire, j'aimerais bien afficher la valeur de N. Donc pour interpoler des choses et utiliser une expression à l'intérieur de notre GSX, on va utiliser une acollateur ouvrente et une acollade fermente. Ce que l'on mettra à l'intérieur, sera une expression qui sera évaluée et qui sera rendue. Donc par exemple ici, je peux mettre simplement N. Dans ce cas-là, je vais me retrouver avec le système d'ennemtation que j'avais la dernière fois. Alors au niveau de ce que vous mettez au niveau de la parenthèse, c'est tout simplement du code JavaScript Valide. Par exemple, ce que vous pouvez faire, c'est utiliser une fonction. Par exemple, on va avoir une fonction number format qui prend un paramètre entier. Et ce qu'elle fera, c'est qu'elle fera un N qui sera entier. On utilisera la méthode to string pour converter sa sous forme de chaîne de caractère et on lui demandera de rajouter un zéro pour avoir de caractère. Et ça, on le retournera. Si maintenant j'ai envie de formater mon chiffre, mais il me suffit simplement d'utiliser la fonction à l'intérieur de mon expression. Et dans ce cas-là, vous le voyez, ça met toujours un zéro initial. Vous pouvez utiliser des fonctions, mais vous pouvez aussi utiliser des conditions, par exemple. On pourra lui dire par exemple si N est divisable par 2, dans ce cas-là, je veux que tu affiche le nombre formaté. Dans le cadre contraire, je veux que tu n'affiche rien. Donc si vous mettez nulle, c'est comme si vous n'aviez rien mis. Dans ce cas-là, il ne mettra rien au niveau de cet élément-là. Si je s'avgarve, on voit que ça n'affiche rien, et tous les nombres impères vont être affichés. Donc vous pouvez avoir des expressions complexes à ce niveau-là. Aroi idéalement, moi, ce que je vous conseille de faire, si jamais vous avez des expressions complexes, c'est plutôt de créer une variable intermédiaire pour éviter que le G6 soit trop compliqué à lire. Autre petit détail, si vous mettez un tableau, il va concraterner les différents enfants. Par exemple, si vous avez un premier texte et un second texte, on va mettre un L ou peut-être un égal pour ces paroles et deux. Dans ce cas-là, il va dire, c'est comme si Span avait deux enfants. C'est vous vous venez, tout à l'heure, qu'on a parlé du CQT élément, c'est comme si on avait maintenant deux enfants qui étaient enfants de cet span de là. Voilà pour un petit aperçu, en tout cas, du fonctionnement de cette expression-là. Autre petit détail, on peut vouloir mettre en place des attributs sur notre HTML. Par exemple, j'aimerais bien que mon H1 ici est une classe spécifique. Donc si vous voulez gérer ça, vous pouvez mettre des attributs et ils seront automatiquement envoyés à la propriété. Donc par exemple, je peux mettre idée, égal, et je vais mettre petite ol. Si je sauvegarde, mon H1 ici a bien comme ID, petite ol. Si vous voulez voir ce que ça donne, vous pouvez toujours vous référer à Babel. Par exemple, je vais aller ici sur la partie Babel. Je vais coller mon code. Et voilà ce que ça donne. Ça fait un React.crui-télément, H1. Ça passe en seconde paramètre un objet qui vont d'y enra donc notre ID avec TITLE. Et un troisième paramètre, on a bonjour les gens. Puis ensuite une Span qui va contagner nos enfants. Vous voyez, ça fait simplement une petite traduction. Petit détail en revanche, parce que ça c'est le détail le plus déstabilisant et qui gêne beaucoup en général. Lorsque vous souhaitez utiliser le class, par exemple on veut rajouter le class TITLE, on ne utilisera pas cette syntaxe là, on utilisera plutôt class9. Alors ça c'est une petite particularité qui est liée à React. Tout simplement class c'est un mot clé qui est utile au niveau du JavaScript. Donc pour éviter tous les problèmes, ils ont dit que lorsque on souhaite rémettre le class, on utilisera plutôt class9. Donc utiliser class9 ou plutôt que class. Dans certaines situations, on suit un certain compiler ça fonctionne, mais toujours vous retrouverez class9 dans vos exemples. De la même manière, vous pouvez utiliser le système d'interpolation pour injecter une variable au niveau d'un attribu. Alors attention, vous ne pouvez pas écrire quelque chose qui ressemble à ça, parce que là, ils considèrent tout ça comme une chaîne de caractère. Par contre, ce que vous pouvez faire, c'est lui dire que la ID sera le résultat d'une expression. Et l'expression en cette TITLE, suivi de N. Et dans ce cas-là, vous allez obtenir un ID qui va changer à chaque ROND. Voilà, c'est un peu particulier, mais faut bien comprendre comment ça fonctionne. Alors maintenant, on imagine que l'on aimerait bien, on s'imagine plutôt, qu'on aimerait bien créer une liste. Donc je vais me créer une constante qui sera Items. Et à l'intérieur, je vais créer, par exemple, les éléments de matoudouliste. Par exemple, TACH 1, TACH 2 et TACH 3. Ce que j'aimerais bien faire, c'est créer un UL qui contient ensuite des LIs avec chacun de ces éléments-là. Ce que je peux faire, c'est faire ici un UL. Alors pas forcément dans le H1, on va le mettre après. Donc ici, UL, et ensuite, on aurait nos différents LIs. Et dedans, je mets mon premier LIs. Tout de suite, on voit que ça passe en rouge. Ce qui se passe, c'est que ça, ce n'est pas du GX Valide. Le problème, c'est que pour que le GX soit valid, il faut qu'il n'est qu'une seule racine. Et là, on se retrouve avec deux éléments qui servent de racine et qui sont H1. Et ça, ça ne va pas fonctionner. Donc ce que l'on pourrait faire ici, c'est tout simplement créer une Dive qui va permettre d'en glober les choses. Comme ceci. Si je sauve garde et que je regarde, ça fonctionne bien. Parfois, on n'a pas forcément envie d'avoir cette élément supplémentaire. On aimerait bien avoir dans notre Dive qu'à l'IDAP, tout simplement dans notre H1 et l'UL. Donc vous avez la possibilité d'utiliser un système de fragment. Donc c'est un système qui est propre à Riat. Et dans ce cas-là, vous allez créer un élément dans le GX qui n'aura pas de tag. Comme ceci. Si je sauve garde, ça ne fonctionne plus. Parce que ça, ce n'est pas forcément supporté par la version de Babel que l'on a à l'heure actuelle. C'est celle que l'on a chargé dans au niveau de notre Html. En revanche, si vous essayez de reconvertir cette fonction, au niveau ici de système, vous allez voir ce que ça va donner. Il va utiliser un React.fragment. Donc ça c'est un fragment, c'est quelque chose qui est utile dans React lorsque vous souhaitez créer plusieurs éléments sans forcément qu'il y ait une racine définie. Si vous utilisez une ancienne version de Babel, ce qui est notre cas ici, on utilise la version 6. Dans ce cas-là, il faudra utiliser le nom de l'éléments complètement. Donc là, on va lui dire, je veux utiliser React.fragment. On reparlera de cette syntaxe un petit peu plus tard. Et après, on ferme notre fragment. Et dans ce cas-là, on obtient bien notre résultat avec la dive qui a l'IDAP et bien nos deux éléments. On a plus cette fameuse dive à la racine. Donc le dernier problème qui nous reste à régler, c'est que l'on souhaite obtenir ici cette liste d'éléments entourés de l'ELEI. Donc d'habitude, ce que l'on ferait un JavaScript, c'est qu'on ferait une boucle forage. Et pour chaque élément, on construirait un OLEI. Là, malheureusement, on ne peut pas le faire. Ce qui va falloir faire, c'est créer un tableau qui va contenir les ELEI. Typiquement, on pourrait faire une constante qui s'appellerait ELEI. Et on lui dirait de faire un intense.map pour parcourir chacun des éléments. On récupérerait le nom de l'item et en retour, mais ce que l'on en verrait, ça serait du JSX. Donc on ferait un ELEI et un intérieur en mettrait notre item. Donc à l'intérieur de cette variable ELEI, on a une liste d'éléments qui pourra ensuite être injectés. Et après, je peux utiliser cette liste à l'intérieur de mon UR, comme ceci. Donc là, ça donne ça. Si je resserve garde, j'ai bien mes différentes tâches. Si vous regardez maintenant votre console, vous allez avoir ici une alerte qui va apparaître un rouge qui vous dit, « It's child in a list, should have a unique props. On en parlera juste après. » Ce que vous pouvez aussi écrire, c'est directement mettre cette expression à ce niveau-là. Après, attention à ne pas trop en abuser, parce que comme vous le voyez, en termes de lisibilité, ça peut très rapidement devenir compliqué de relire ce code-là. Donc il faudra faire attention et choisir un bon compromis entre lisibilité et rapidité. Enfin, donc le dernier point, c'est cette fameuse erreur. Il vous dit que chaque enfant dans la liste devrait avoir une propriété clé unique. Pourquoi il vous affiche ça ? Tout simplement parce que quand vous rendez une liste, ce qui va se passer, c'est que peut-être un jour, vous allez supprimer cet élément-là. Et lui, quand il va refaire son rendu pour pouvoir comparer les éléments de la liste, et se dire « Ah, ben tu as supprimé ce premier élément, il faut qu'il ait une clé pour identifier chaque élément-là. » Donc ça sera surtout très utile lorsque vous allez avoir, par exemple, une liste de commentaires, on peut s'imaginer, on a une liste de commentaires et peut-être quand vous ajoutez un commentaire, le nouveau commentaire apparaît au-dessus de la liste. Pour éviter que quand React face sa comparaison, il se dise « Ah, ben il y a tous les éléments qui ont changé, mettre des clés permet une meilleure performance au niveau de la manipulation du donne. » Donc nous, ici, faut juste qu'on rajoute un nouvel attribu « clé » qui contiendra une clé qui doit être unique pour chaque élément. Ce que je vais faire moi, vu que ici, je n'ai pas l'intention de les changer, c'est lui donner comme clé l'index du tableau. Donc ça m'oublie, j'ai changé légèrement cette boucle pour faire ça. Et là, maintenant, on a plus d'erreurs et un anotage qui sont rendus. Donc voilà, pour cette petite découverte du GX. Alors rassurez-vous si jamais vous vous sentez complètement dépassé par cette syntaxe-là, rassurez-vous dans les exemples suivants, on va réutiliser cette syntaxe avec des cas aimes-times un peu plus simples et ça vous permettra d'appréhender les choses plus progressivement. Ce que je voulais vous montrer dans cette vidéo, c'était vraiment que le GX va vous permettre de mettre des expressions au niveau ici des accolades et que vous pouvez mettre n'importe quoi et vous permettra de représenter des structures complexes. Mais vraiment, on est à l'aise au fil du temps en pratique. Donc je vous donnerai vous dans le prochain chapitre on va créer nos premiers composants.