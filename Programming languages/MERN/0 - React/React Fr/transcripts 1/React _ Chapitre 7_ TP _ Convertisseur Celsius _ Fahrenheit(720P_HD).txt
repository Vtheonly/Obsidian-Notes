 Bienvenue dans ce nouveau chapitre, je vous repose un petit peu de passer à la pratique à faire de solidifier nos acquis. Pour cet exemple, on va prendre le même exemple qui est disponible dans la documentation, comme ça vous pourrez vous y réferer si vous avez des problèmes. Notre objectif est de créer un système qui va être capable pour lequel on va pouvoir rentrer une température et qui va nous dire si l'eau est ou non. Et ce qu'on va rajouter après, c'est un système capable de convertir des degrés Celsius sans faroneite. Donc voilà le petit exemple qui est disponible au niveau de la documentation. Donc on entre le degrés Celsius et automatiquement ça nous dit l'eau ne bouffe pas ou l'eau boue. Si je rentre une température qui est supérieure à sang, l'eau boue. Et ensuite, juste en dessous, on a la température qui est convertie en degrés faroneite. Alors assurez-vous, on va commencer à faire les choses simplement et on va prendre morceaux par morceaux. Donc je vais commencer dans mon fichier JavaScript à tout effacé. L'idée c'est de repartir de zéro pour vous forcer à extraire les choses et pour bien assimiler les différentes motions. Vous, ce que vous pouvez faire, c'est garder ce fichier de côté si vous avez besoin d'une référence. Alors, en intérieur, j'aimerais bien que vous crée un premier composant qui sera capable de vous dire si l'eau boue ou non. Et si vous utilisez le bootstrap, vous pouvez rajouter des classes alertes pour changer la couleur suivant que l'eau boue ou non. Notre objectif c'est d'avoir un composant qui va s'appeler Bowling Verdict, qui va prendre un paramètre la température, on la passerait en degrés celles sus et on lui dirait par exemple 50. Automaticement, ce composant-là devra afficher un message qui dirait l'eau ne boue pas. Ensuite, on va passer une autre fois ce composant, on lui passerait une température qui est supérieure à sang de gré et ça devra nous dire l'eau boue. Donc votre objectif c'est de créer ce petit composant et de le monter au niveau de votre donne. Donc je vous laisse essayer de pratiquer encore et châne ensemble juste après. Pour créer ce composant, vu qu'on va lui passer des propriétés, il n'aura pas forcément besoin pour l'instant d'État. Alors, je vais simplement créer une fonction. Cette fonction va s'appeler Bowling Verdict. Elle prend un paramètre des propriétés et nous pour l'instant on a qu'une seule, c'est la température en degrés celles sus. Donc on va utiliser la destructuration ici pour un petit peu plus de clarté. A l'intérieur je vais simplement mettre une petite condition et vérifier est-ce que la température en celles sus est supérieure ou égal à sang. Si elle est supérieure ou égal à sang dans ce cas-là je vais retourner une dive qui aura comme classe, alerte, alerte tirée success. Et je mettrai l'eau boue. Maintenant que je crée ce composant, je peux le monter dans mon dom. Pour cela je fais un react-domme. Et je utilise la méthode Render pour rendre mon Bowling Verdict. Je vais lui passer pour l'instant une température qui est inférieure ou égal à sang. Donc on mettra à 50°. J'autoferme mon composant parce qu'il n'a pas d'enfant. Ce composant-là je vais le brancher au niveau de mon dom sur l'élément qui a l'ID UP. Je peux le dire à quoi rire les sélecteurs ou un guide élément de BayID ça fait pas de différence. Si je sommes garde maintenant on me dit que l'eau ne boue pas. Je vais peut-être au niveau de mon HTML entourer ma dive qui a l'ID UP d'une dive qui aura la classe container. Il soit que ce soit un petit peu centré et un petit peu plus joli aussi. Et je rajouterai un MT-4 pour espacer par rapport au haut de mon écran. Donc là on me dit bien l'eau ne boue pas. Si maintenant je change la température pour mettre 110° par exemple, ben là le message est envers et l'eau boue. Un pécable. Maintenant on va complexifier un petit peu notre composant. On s'imagine que l'on aura à notre composant qui va s'appliquer calculateur. Donc c'est ce composant-là qui va nous permettre de calculer les choses et de nous dire si l'eau est le bout. Dans ce composant on veut simplement créer un champ ou l'utilateur pour rentrer la température en degré Celsius et suivre l'interpérature qu'il rentre, il faudra afficher en dessous l'eau boue ou l'eau ne boue pas. Par exemple je vous laisse essayer de le faire et en correctant ensemble juste après. Alors pour ce composant il faut bien réfléchir. C'est un composant qui va avoir besoin d'un état parce qu'on a besoin à l'intérieur de savoir la température qui est rentrée par l'utilisateur. Donc vu que c'est un composant qui nécessite un état, on va utiliser le système de classe. Donc on fera une classe qui va s'appliquer calculateur et qui va étendre de react point component. À l'intérieur de suite je vais créer la fonction Render qui pour l'instant ne retourne rien. Aussi je vais créer un constructeur qui prend un paramètre et les propriétés. On en a aucune mais on doit toujours dès le début appelé super de propces. C'est nécessaire vous ne pouvez pas vous passer de ça. En dessous on va définir notre état. Alors au niveau de mon état je réfléchis, moi je vais avoir besoin finalement de la température. Je pourrais l'appeler c'est alçus mais vu que plus tard on va faire un système qui permettra de convertir, là on va la appeler température, température. Et par défaut on dirait que la valeur c'est du vide. Maintenant que j'ai cette état là je vais pouvoir créer mon champ. Donc je vais faire un return, on va avoir une dive qui va englober tout notre calculateur et je vais créer une dive qui aura comme classe formes tirer groupes et à l'intérieur j'y crée mon label. Donc ce label permettra de rentrer la température en celles sus. Donc là on mettra celles sus. Et on mettra température en celles sus. Ensuite je crée un mon champ donc ça sera un input de type texte. Il aura comme ID celles sus. On n'est pas obligé de lui mettre un nom. Il aura comme valeur la valeur que j'ai dans l'état. Donc vice point température point state. Plus tôt vice point state point température. Et pour l'instant c'est tout ce que j'ai besoin de faire. Évidemment il faudra gérer le moment où on changera les choses. Enfin on va avoir notre petit composant qui nous permettra de dire si ça boue. Donc là on va avoir un boiling verdict et on lui passe sur à la température en degré celles sus. Alors attention cette température va pour l'instant aller sous forme de chaîne de caractère ce qui n'est pas forcément pratique. Et on va utiliser la méthode par ce flotte pour passer notre chaîne de caractère sous forme de flotte. Et à ce niveau là je lui passe vice point state point température. Pour éviter de m'embêter je vais utiliser la destructuration en amont et je lui disais je récupère la température depuis vice point state. Comme ça après dans mon composant on est pas obligé de faire vice point state tout le temps. Et c'est toujours un petit peu plus pratique. Donc je s'affaire et je vois bien que j'ai la température ici. J'ai juste oublié au niveau de mon input la classe, alors classe name, forme tirée contrôle. Sinon je n'ai pas la bonne apparence. Donc je rentre une température et dès que j'essaye de taper dans le champ je suis ébloqué. Si vous souvenez on avait dit si vous ne mettez pas une valeur qui indiffine, de le champ est complètement verrouillé parce qu'il est contrôlé par hiat. Donc il va nous falloir une méthode handle change qui va permettre de changer la valeur. Cette méthode prendra en paramètre l'événement et dès le début avant même d'aller plus loin, comme ça je n'oublie pas, je fais un vice point handle change, égal vice point handle change point mind vice. Comme ça l'intérieur je peux le disais vice et ça fera toujours référence à ma classe. Là ce qui me suffit de faire c'est récupérer la valeur que j'ai dans mon champ et la mettre au niveau de mon état. Donc je fais un vice point state et je change température et je mets comme valeur e.target.value. Donc c'est identique aux exemples que l'on avait vu précédemment. Maintenant je vais lui dire lorsque on change la valeur au niveau de ce champ, donc on va mettre un on change, je fais un vice point handle change. Je s'affigarde et si je change la valeur dans mon champ, quand je rentre une valeur qui est supérieure à 100, j'ai bien le message lobo ou le noboopa. Donc là on a cette première partie qui est déjà fonctionnelle et vous voyez c'est relativement simple à mettre en place. Alors maintenant on a envie de pousser les choses un petit peu plus loin et d'avoir deux champs. On voudrait un premier champ qui permet de rentrer la température en sel sur c'est un autre qui permet de rentrer la température en 2°. Donc à fin de ne pas trop nous répéter à ce niveau là, on va simplement s'imaginer et créer un composant. Je vous donne la structureuse composant et ensuite vous allez essayer de l'écrire tout seul. Donc on va créer un champ qui va s'appeler température, température input. Ce champ aura comme propriété scale qui sera l'échelle que l'on soit utilisée. On aura deux échelles, c pour celle-sus et f pour Fahrenheit. Et ensuite on fait ça comme ça. Et là on aura f comme Fahrenheit. Pour la partie libelée pour que ça soit généré automatiquement, on va créer une constante tout au début de notre fichier qui va contenir les différentes échelles. On va la poler scale nays et ça sera un objet qui contiendra comme clé c et dans ce cas là ça sera celle-sus. Et ensuite une clé f qui sera Fahrenheit. Donc pour l'instant on ne va pas avoir de méthode qui nous permettra d'observer les changements de valeur, mais on veut simplement créer ces champs là. Donc je vous laisse essayer de le faire, faites en sorte qu'on ait deux champs qui permettent de rentrer une valeur et on veut que le libelée affiche température en Celsius et température en Fahrenheit. Alors j'espère que vous avez essayé de pratiquer et on est parti. Donc je vais créer une nouvelle classe qui va me permettre de gérer ses champs. Donc cette classe va s'appeler température input et va être tendre de react point component. À l'intérieur je vais avoir besoin de se regarder l'Etat qui va me permettre de savoir la température qui a été tapée. Donc tout de suite je fais appel à mon constructeur et je lui passe des propriétés. Au niveau de ce constructeur, j'appelle le constructeur parent en lui passant les propriétés et je vais définir mon État. Donc chaque champ aura un État qui n'y sera propre, qui permettra de maintenir la température. Donc on dirait ici que ça sera du vide. Maintenant je vais créer ma fonction Render. À l'intérieur de cette fonction, là je vais pouvoir tout simplement coller le texte que j'avais précédemment. Donc je vais retourner une dive qui aura la classe forme groupe. Je mettrai ici la température et là il faudrait que j'en rajoute 1 suivi du l'échelle et ensuite, le l'input de type texte ne changera pas. Si ce n'est ici que pour le HTML4, je vais utiliser directement le scale qui a été demandé. Donc là je mettrai scale, ou peut-être ici en le métrage comme constante, conste name et gale. Et en mettra scale, suivi du nom de l'échelle. Donc le nom de l'échelle en là au niveau des propriétés, donc ça sera vis.props.scale. Ce nom je l'utilise au niveau de mon HTML4, mais je l'utilise aussi au niveau de mon ID, qui se situe ici. Ça permet de connecter le libelé à notre champ. À ce niveau là aussi, il va falloir que j'en récupère le nom de l'échelle. Donc on va l'appeler scale name, conste scale name, et on lui dira de faire un scale name, donc ça sera notre objet là haut, et on récupérera la valeur qui est associée à la clé, qui est dans vis.props.scale. Maintenant, plutôt que de mettre celle-dessus sans dur ici, je peux lui dire d'afficher scale name. Donc là, première vue, on est bon, il me semble. Alors il y a juste un petit problème, que je ne peux pas être créé, par où on peut s'inspirer du handle change qu'on avait écrit ici, ou même tout simplement le copier. En faisant attention à faire un vis.handlechange.inv, là haut. Donc maintenant, je vais avoir mon champ de température input, qui va être en mesure d'afficher un champ, dans lequel je vais pouvoir taper la valeur. Donc à première vue, ça ne se rend pas au niveau de la page, pour les sortir mon aspecteur et voir où j'ai pu faire une erreur. Donc comme je me dis, température est non-difind. Effectivement, il faut que j'utilise la destructuration ici, pour extraire la température depuis l'état. Par contre, je devrais le garder ici, sinon ici, j'ai besoin de température pour faire mon parclet. Donc je self-guard, et j'ai maintenant un premier champ qui me permet de rentrer une valeur en celle-dessus, et à ce qu'on permet de rentrer une température en Fahrenheit. Donc maintenant, ce que l'on va en vie de faire, c'est que lorsque je t'appet dans un champ, il faudrait que la température soit convertie dans l'autre et inversement. Donc il va falloir relier les deux informations. Le problème dans l'approche que l'on a choisi actuellement, c'est que chaque champ est responsable de son état, de sa valeur, et il n'est pas possible de faire communiquer les deux champs ensemble. Donc dans ce cas-là, si vous avez besoin d'une communication, ça veut dire que c'est le composant qui est par an, qui englobe ses deux éléments-là, qui va être responsable de passer l'état. Donc ce que l'on va faire, c'est qu'on va maintenir et se regarder la température dans ce composant de calculateur. Et on va plutôt utiliser les propriétés pour lui envoyer la température. Donc on fera ici une propriété qui s'appelera température et on lui passera la température qui sera convertie dans la bonne unité. Alors pour l'instant, juste pour laisser, on va mettre une température en haut qui sera en deux grés. Donc on s'imagine, d'entre parties rinder, à ce niveau-là, on peut simplement nu passer la température parce que c'est la bonne température. Mais par contre, pour la partie Fahrenheit, il va falloir la convertir. Donc on va créer les fonctions de conversion. Ces fonctions n'ont pas forcément besoin d'être dans ce composant. Ça peut être des fonctions qui sont globales, vu que le système de conversion, il peut être n'importe où. Donc on aura un tout Celsius qui va permettre de convertir des Fahrenheit. Un désolé, j'ai du mal à l'écrire, un degrés Celsius. Et on aura la fonction inverse, qui va s'appeler tout fa renneite, qui va prendre des degrés Celsius et les convertir en degrés Fahrenheit. Alors j'ai besoin de me documenter, parce que je ne connais pas de tête les méthodes de conversion. Donc on va mettre formulae, faire unite. Alors plutôt Celsius, on va commencer par cela, Celsius tout Fahrenheit. Et on nous donne la formulae là. Je crois que sur ce site, on nous donne les deux. Voilà, c'est ça que l'on veut. Je ne sais pas si le copier coller va bien fonctionner. Un pécable. Donc on va se le mettre en commentaire au-dessus des deux fonctions, comme ça on aura une petite référence. Et il me manque la formulae qui fait l'inverse. Donc si je clique tête sur Fahrenheit ici, voilà, on m'explique que pour faire cette conversion là, c'est cela la bonne formulae. Donc si j'ai des Fahrenheit et que je veux des Celsius, il faut que je soustrer 32. Donc on va faire, et je vous viens de petit essai, un petit H ici. On va faire Fahrenheit, moins 32. Le tout multiplier par 5 divisé par 9. Faites bien attention à la priorité des opérations et la bienmête vos parenthèses. Et je vais directement retourner ça. Alors si j'ai des Celsius et que je veux des Fahrenheit, donc je suis dans ce cas là, il faut que je multiplie par 9 divisé par 5. Donc on fera un return de Celsius, celle-sus multipliée par 9-5ème et ensuite j'aditionne 32. Quand une fois, attention au parenthèses. Un pécable. Donc au niveau de mon système ici, je vais pouvoir lui dire pour l'instant, on va créer une constante qui va s'appeler Celsius, qui sera également la température. Et je vais avoir une constante qui va s'appeler Fahrenheit, qui sera également à tout Fahrenheit. Et je lui passe un paramètre, la température en Celsius. A ce niveau-là, je peux lui passer du coup la valeur en Fahrenheit et à ce niveau-là, la valeur en Celsius. Maintenant, au niveau de mes composantes températures input, je sais que je vais avoir une propriété température. Donc on ne va plus avoir besoin de gérer un état, donc je vais supprimer cette partie-là. Je vais laisser le handel change, peut-être le vidé de son contenu. Et maintenant, la température, on ne la récupère plus depuis VIS.state, mais plutôt depuis VIS.props. Si je ressetve garde et que je re-charge mon composant, on voit bien qu'ici il y a 20° par défaut et ça correspond à 68. Par contre, je ne peux pas taper de valeur parce que pour l'instant, mon handel change ne fait rien. Alors, là, il faut aussi réfléchir. Finalement, quand on va taper une valeur au niveau du champ, il faudrait que ça remonte au parent. Il faudrait que le calculateur soit capable de détecter quand on a changé la température. Donc on va créer un handel température change et il recevra en paramètre la température. Ce qu'il va faire tout de suite, c'est qu'il fera un VIS.state, et il changera la valeur de température par rapport à ce qu'il reçoit. Maintenant, au niveau de mon input de degré celles sus, je vais pouvoir le dire, mais je veux que tu puisses changer la valeur. Donc on imagineraient lui passer une propriété qui s'appellerait en température change et on lui passerait cette fonction-là. Cette fonction-là pour que VIS fasse bien référence à la bonne chose, on n'oublie pas le fameux, ou le copier colis incomprédemment forêt, c'est le point de la vise. Voilà. Maintenant, notre composant ici, température input, il va avoir besoin d'écouter les changements qui sont faits au niveau du champ. Donc on utilisera toujours notre handel change. Par contre, il va avoir besoin de faire remonter l'information. Pour faire remonter l'information, il va utiliser cette propriété-là, qui est un callback, qui le va pouvoir appeler. Donc on va lui dire, lorsque tu change les choses, je veux simplement que tu fasses un VIS.prox, point 1 température change et je vais te passer en paramètre la température, qui sera e.target.value. Automatiquement, le composant par an recevra le changement-là, changera la valeur de température, ça déclenchera à nouveau rendu, ce qui fait que ce composant va recevoir une nouvelle température et la valeur du champ ne trouvera modifier. Si j'essaye de faire un test, je rentre 200, on voit bien que l'eau bout et que ce champ a changé. Le problème que l'on a à leur actuel, c'est que ce champ a une valeur, mais quand lui il change, il ne se passe rien, parce que lui n'a pas de handel température change qui va être appelé. Donc si j'essaye de faire un essai, de rentrer n'importe quoi, on tombe juste sur une petite erreur. Parce que effectivement, je n'ai pas défini, mais vu qu'on n'a pas de handel température change, la valeur ne change pas, et le champ reste un petit peu en lecture 7. Donc on a rien poussé les choses un petit peu plus loin et faire un sorte que l'on puisse taper dans les deux champs. Donc on va devoir savoir, finalement, est-ce qu'on est en train de rentrer des valeurs en Celsius ou est-ce qu'on est en train de rentrer des valeurs en Fahrenheit ? Donc notre calculateur, il va avoir besoin de savoir sur quelle échelle il est. Donc ici on va mettre scale, et nous on avait dit par défaut, mais par contre cette échelle peut être différente et on peut passer en Fahrenheit. Maintenant pour calculer la température, bah ça va dépendre. Si on est en Celsius, mais dans ce cas-là, on retourne directement la température. Par contre si on est en Fahrenheit, mais il faut retourner la température Fahrenheit. Donc ici, je vais mettre une petite condition. Donc je vais lui dire, au niveau de state, j'aimerais bien aussi récupérer l'échelle, qu'on va appeler scale, et je vais lui dire si l'échelle est égal à c. Dans ce cas-là, il faut que tu me renvoies la température. Dans le cas contraire, ça veut dire que la température est en Fahrenheit, et dans ce cas-là tu ferais un tout Celsius, et je te passerai un paramètre, là, température. Pour la partie Fahrenheit, je vais lui dire si l'échelle est égal à Fahrenheit. Dans ce cas-là, bah il n'y a pas de problème, tu me retournes la température. Dans le cas contraire, tu me retournes la version Fahrenheit. Maintenant, quand je tape dans le champ qui est de type Celsius, il faut que je lui dise l'échelle et Celsius. Par contre, quand je tape dans le champ qui est Fahrenheit, il faut que je lui dise, bah attention, l'échelle va être du Fahrenheit. Donc je vais avoir besoin de deux fonctions différentes. Donc là, on va l'appeler, Andol, Celsius, change. Et dans le state, on lui passera effectivement la nouvelle température. Mais on aura aussi besoin de lui passer l'échelle. Donc on lui dirait à là, l'échelle, c'est c. Parce qu'on vient de changer les Celsius. Quand on change des Fahrenheit, on va utiliser une méthode qui va s'appeler Andol, Fahrenheit, change. Alors hop. Je crois qu'il choisira un mot plus simple à taper. Donc ça sera Fahrenheit, change. Dans ce cas-là, on fera un set state. On change au raléchelle pour dire qu'on est en mode F. Donc on est en mode Fahrenheit maintenant. Et ensuite, on lui passe aussi la nouvelle température. Au niveau de mes deux champs, mes températures input, je vais lui dire si tu es en train de changer le champ Celsius, je veux que tu utilises la méthode Andol Celsius change. Si tu es en train de changer le champ Fahrenheit, je veux que tu appelle le vis.andol Fahrenheit change. Attention par contre, a bien faire en sorte que vis face bien référence en autre classe. Donc là, hop. On va mettre dès le début, un vis.andol.set.schange, égal vis.andol.set.schange.binevis, et on fera la même chose pour les Fahrenheit. Et là, on devrait être bon. Donc on va s'aff regarder, en temps sur une petite erreur, ou il ne me dit qu'il ne connaît pas scale. Donc j'ai fait une petite erreur de typographie ici. Donc je rentre une température en degré, et on voit qu'on me dit l'eau bout. Je rentre une valeur en Fahrenheit, et on voit que ça te convertit la valeur en degré celles sus. Alors on pourrait faire un arrondi, parce que là par défaut, c'est un arrondi qui est fait un javascript, qui n'est pas forcément type top, mais vous voyez le principe à ce niveau-là. Donc attention si vous faites la ronde-y, au niveau de précision que vous souhaitez obtenir. Bon, l'ennêtement n'est pas si entré très scientifique, on veut juste savoir si l'eau n'est pas debout. D'ailleurs, ça semble un peu bizarre. Là, on me dit que l'eau bout, alors qu'elle ne devrait pas goûer, vu qu'on est à 37°. Effectivement, dans la partie boiling verdict, on faisait un par-se-flotte, et on lui envoyait la température. Maintenant, on a plus besoin de faire ça, on va simplement lui dire, je t'envoie la température en celles sus, parce que toi, effectivement, tu attendais des celles sus. Et dans ce cas-là, si je t'appasse sans à ce niveau-là, ça me donne une température qui ne bout pas. Si je rentre 2000, la l'eau est vacarrément s'évaporer, mais vous voyez bien que l'eau elle boue à cette température-là. Donc, voilà, comment vous pourriez mettre en place un système de conversion. Alors, juste, peut-être, un petit détail, c'est que quand vous tapez n'importe quoi, vous voyez que le système il a un petit peu de mal. Donc, ce qui pourrait être intéressant, c'est d'utiliser une fonction qui va permettre de gérer ça de manière un petit peu plus élégante. Donc, cette fonction va l'appeler, eux, ils l'ont appelé Tri-converte dans l'exemple de la documentation, donc on va l'appeler comme ça aussi. Et on lui passerait un premier paramètre, une température et la fonction de conversion. À ce niveau-là, je peux lui dire du coup, si jamais l'intempérature, donc n'est pas dans la bonne unité et qu'il y a besoin de faire une conversion, je veux que tu fasses un Tri-converte, je te passe la température et je te passe la fonction de conversion, qui sera du coup tout le sel sus. Dans le cas du Fahrenheit, je fais ça, sauf que la fonction de conversion, c'est tout Fahrenheit. Cette fonction n'a pas besoin du coup d'être dans le composant, donc on peut s'imaginer la définir en dehors et je vais la définir tout un haut. Pourquoi c'est intéressant d'avoir cette fonction-là? Tout simplement pour garder ces fonctions les plus génériques possibles, on veut vraiment des fonctions qui vont faire la conversion en brut et cette fonction-là, elle va permettre de rajouter quelques petits conditions. Par exemple, on peut lui dire, j'aimerais bien passer et m'assurer que la température est un flotte. Donc on va lui dire, conste value, égal température, que l'on passe sur ce flotte. Maintenant, cette température ne peut pas donner un nombre. Donc on va lui dire, if number.isnotnumber, donc si notre value n'est pas un nombre, dans ce cas-là, on retourne une simple chaîne de caractère parce que ce n'est pas la peine d'essayer de faire une quelconque conversion. Dans le cas contraire, on va récupérer la valeur convertie, donc on va mettre output et on mettra convert, donc c'est notre fonction de conversion et on lui envoie la valeur. On obtient alors la nouvelle valeur que l'on peut choisir d'arrondir. Donc on fera un mat.rand en multipliera ça par cent pour avoir une précision à deux chiffres et on dividera ça par cent. Et enfin, vu qu'on travaille avec des champs, il faut que ça, ça soit convertie sous forme de chaîne de caractère. Donc ça nous permet simplement d'avoir une petite fonction qui va s'assurer en fonction d'entrée que on n'est pas n'importe quoi en sortie. Donc si j'aurais essayé et que je rentre n'importe quoi dans la partie température, on voit que dans la partie Celsius, il n'est pas capable de trouver une valeur et du coup, il ne renvoyerait. Et là, on a terminé avec cet exemple-là. Donc voilà un petit exemple de système et des éléments dynamiques que l'on peut créer avec réactes. Donc vous le voyez encore, ça permet d'avoir une logique qui est un petit peu plus simple à appréhender avec une séparation en composant pour gérer qui va rentrer les valeurs. On peut séparer vraiment les choses dans différentes fonctions et en fait en changeant l'état, on assure que notre interface se change pour l'utilisateur. Donc j'espère que ce petit travail pratique vous a plu et je vous donne rendez-vous dans le prochain chapitre.