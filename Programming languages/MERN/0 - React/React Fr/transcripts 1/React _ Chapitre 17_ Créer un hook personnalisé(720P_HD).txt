 Dans ce chapitre, je vous propose de décider de comprendre ensemble l'intérêt d'EW grâce au système de composition. C'est-à-dire qu'on va pouvoir créer des fonctions qui vont englober d'EW et qui vont permettre d'avoir de la logique réutilisable. Donc on a rapidement créé une fonction user-incrémante qui permet de faire ce genre de choses et on va découvrir d'autres petites fonctions qu'on peut créer basé justement sur les OUK. Alors ce que l'on va faire, c'est qu'on va tout supprimer, on va simplement garder notre div ici, on va tout effacer, il soit de reprendre un peu les choses de zéro et on va commencer par reproduire l'exemple que l'on a fait au début. Je vous demande de créer un composant sous forme de fonction secosie qui va s'appeler compteur. À l'intérieur de ce composant, on veut simplement retourner un bouton qui aura cette capacité d'incrémenter. Et on affichera la valeur d'incrémentation. Ce que je vous demande de faire, c'est sans forcément recopier le code de la première vidéo, de créer un OUK qui s'appelle UseIncrément, qui va nous renvoyer une valeur qui sera la valeur d'incrémentation et une méthode incremente. On peut appeler comment on veut et notre OUK s'appellerait UseIncrément. On lui passerait à un premier valeur initial, donc 10, et un second de valeur le pas et en mettrai par des fours la valeur 1. Donc je vous laisse essayer de créer cette fonction-là et on correction ensemble juste après. Alors comme on a vu, on peut utiliser le UseState et le UseEffect et tous les autres OUK que l'on va voir, même les OUK que l'on va créer, on peut les utiliser dans notre fonction, tant que ces fonctions sont définies comme des OUK. C'est-à-dire, elle commence par Use et à l'intérieur, elles font appelent directement aux autres OUK. Donc nous dans ce cas-là, on commence par créer la fonction. Donc c'est très simple, on fait un UseIncrément. On réfléchit aux arguments. Donc on avait dit qu'on a deux arguments, la valeur initiale, qu'on va l'appeler initial value, et un second paramètre qui sera le pas et on avait dit que la valeur, ça serait un par des fours. Cette valeur-là, on peut aussi la spécifier à zéro par des fours. Donc on va avoir besoin au fil du temps et au fil des incrementations de mémoriser là où on est au niveau du compteur. Donc on doit utiliser pour cela un état local. Donc on va utiliser la fonction UseState. Donc automatiquement, Visual Studio Code importe les choses, c'est plutôt pratique. Dans ce UseState, on met toujours la valeur initiale. Ce UseState va toujours envoyer un tableau de taille 2 avec un premier la valeur qui correspond à l'état, dont on va l'appeler compte, et un second le seteur qui va permettre de changer la valeur dans l'état. Cette compte. Ce que l'on veut exporter, hop, on peut le faire tout de suite, c'est exporter la valeur qui correspond au compteur, donc la valeur d'état, et ensuite une fonction incremente que l'on va devoir, du coup, créer parce qu'elle n'existe pas. Je vais créer cette fonction là, elle s'appelle Increment, et c'est une fonction qui, pour l'instant, ne fait rien, et à l'intérieur de cette fonction, je vais faire un set compte et je vais à incrementer la valeur. Et là, j'ai maintenant mon ouc personnalisé qui s'appelle Increment. Donc je vais sauvegarder, on va voir si il fonctionne convenablement. Donc au niveau de ma console, je n'ai pas d'erreur, mais effectivement, je ne vois rien, parce que j'ai oublié de mettre le compteur ici. Hop. Donc je sauvegard, j'ai bien mon bouton, et quand je clique, ça ne s'incrémente pas, parce que je n'ai pas encore appelé la fonction incremente. Donc là, je vais lui dire, lorsque tu clique, on clique, je veux que tu lance, incremente. Et maintenant, ça s'incrémente convenablement. Donc là, on s'écrit un petit ouc personnalisé que l'on va pouvoir réutiliser dans d'autres fonctions qui permet d'incrémenter une valeur. Alors maintenant, je vous demande à nouveau que personnalisé encore une fois. Je m'imagine, j'aimerais bien avoir une petite checkbox pour afficher ou non le compteur. Donc là, on va s'imaginer à avoir un nouveau composant que l'on va appeler app, qui va permettre de représenter notre application. Dans ce composant, je retourne une dive qui contiendra notre compteur. Et je vais ensuite utiliser cette application, au niveau de mon render. Donc au dessus, j'aimerais bien avoir un afficher le compteur et je m'imagine avoir un input de type checkbox. Et quand je vais changer la valeur de cette checkbox, ça va appeler une méthode qui s'appelle Toggle, compteur, par exemple. Et pour savoir si le composant invisible, on va avoir une propriété de checkt qui va s'appeler compteur visible. Voilà, donc là, ça serait mon champ qui permettrait d'afficher ou de masquer notre compteur. Et après, peut-être emmettre un petit saut de ligne. Donc pour mettre en place ce système de Toggle, j'aimerais bien utiliser un hook personnalisé. Donc c'est où qu'il aurait le format suivant. Ça serait un hook qui renverait un tableau de type 2. On aurait un premier la valeur, donc nous mettrai compteur visible. Et en second, une fonction qui permettrait de togler, c'est-à-dire de changer la valeur de True and False. Et là, on l'appellerait Toggle compteur. Et notre hook, on l'appellerait, use Toggle. Et on lui passerait la valeur initiale, qui serait, par exemple, True. Ce que je vous demande maintenant, c'est de créer ce hook personnalisé, Use Toggle, qui prendrait un paramètre la valeur initiale. Et on lui dirait que par défaut, ça serait True, encore que peu importe. Donc je vous laisse essayer de créer une code et encore une chance, ensemble, juste après. Donc comme pour notre use increment, ce use Toggle, il va avoir besoin de mémoiser un état, de savoir est-ce que, actuellement, on a mis oui ou non. Donc là, on va faire un conste, on va l'appeler Value, on va utiliser des choses génériques et cette value. Et on lui dira de faire un Use state, donc ça permettra de sauvegarder l'état, et on lui donnera comme valeur initiale, initial value. Maintenant, je vais créer une constante, qui va permettre de togler, d'alterner la valeur. Ça sera une fonction et cette fonction, elle fera un set value, et vu qu'elle change la valeur, je suis dis plutôt un callback. Donc on l'est dit, V sera différente de V. Donc si la valeur était True, ça deviendra False et si la valeur était False, ça deviendra True. Maintenant, je peux retourner les différents changements d'état, donc je vais retourner la valeur Value et la fonction d'autoggle. Automatiquement, ça permettra de mettre dans le compteur visible la valeur, donc False ou True, et dans Toggle compteur, ça permettra la fonction qui permet de changer la valeur. Si maintenant je s'aff garde, on voit qu'on a plu des erreurs, et j'ai maintenant cette bouton-là. Donc lorsque je coche ou je décoche, ça va changer la valeur de compteur visible. Je peux du coup utiliser cette condition-là à ce niveau-là et lui dire, si le compteur est visible, je veux que tu affiche le compteur, sinon je veux rien faire. Et dans ce cas-là, vous voyez que très simplement, j'ai maintenant un petit hook personnalisé, qui s'appelle Toggle, qui me permet d'alperner une valeur. Si j'avais à écrire la même logique ici avec un système de classe, je serai obligé de faire un set state de venir changer la valeur, alors que là, j'ai séparé dans une petite fonction qui me permet d'avoir du code qui est réutilisable. Et si on regarde dans un parti, application, ici composant, hop-là. J'ai bien mon application avec mon hook Toggle, et si je le déplie, je vois qu'il a comme état trop. Donc la valeur de l'Etat, en fait, ça, c'est parce qu'il détecte il y a un use state et il me donne la valeur qui correspond au use state. Alors maintenant, on va continuer notre exploration, et ce que je vous propose de faire, c'est de créer un hook qui fonctionnerait comme le use increment, sauf qu'il s'appellerait « Use auto-incrémente ». Donc ça serait un hook, quand on l'appelle, il incrementerait les choses de manière automatique. Et il aurait la même signature que le use increment. C'est-à-dire qu'il prendra un paramètre la valeur initiale et la valeur de saut, quand même ceci. Et on va le mettre juste là. Donc je vous laisse essayer de le créer et on corrige un encore une fois ensemble juste après. Donc ce use auto-incrémente, finalement, il fonctionne un peu comme le use increment. Et il va avoir un plus besoin de démarrer un timer pour incrementer de manière automatique. Donc ça veut dire qu'on va utiliser le use state pour créer un état, mais on peut aussi utiliser dans notre hook personnalisé le use effect. Alors on commence par le use state. On fait un conste, coute et set coute, et on fera un use state et on lui donnera la valeur initiale. Maintenant je vais créer mon petit timer. Donc ce timer, vu que j'aurais besoin, ensuite, de le supprimer, je vais faire un use effect. Je vais lui passer un premier paramètre une fonction. Voilà et un second paramètre, un tableau de dépendance. Vu qu'ici ce timer aura besoin d'être démarré avec le montage du composant et démonté à la fin du cycle de vie du composant, je n'ai aucune dépendance. À l'intérieur de ce use effect, je vais faire une nouvelle constante qui va contenir le timer. Je vais lui demander de démarrer un timer, en faisant un set interval. À l'intérieur de cette interval, je vais avoir une fonction qui fera un set coute et qui incrementera du par. Ce timer va avoir une durée de une seconde au par défaut et je n'oublie pas de le nettoyer à la fin. Dès que vous utilisez un timer ou que vous abonnez à des événements, pensez tout de suite, tout de suite, à créer la fonction de nettoyage. Là, je fais simplement une clier intervalle et je nettoie mon timer. Maintenant que mon use effect est créé, je peux choisir ce que je vais exporté. Là, je vais retourner quelque chose et je n'ai pas besoin de retourner la partie incremente. Je peux simplement le dire, je veux que tu retourne le compteur. Dans ce cas-là, au niveau de mon compteur ici, je peux lui dire, j'aimerais simplement avoir coute. Et automatiquement, ça va nous renvoyer une valeur qui redéclaunchera un set coute toutes les secondes et qui fera un nouveau rendu de ce composant-là. Si je savais garder maintenant, je regarde au niveau de ma console parce que j'ai pas mal de petites erreurs. On me dit que incrementes est not defined. Effectivement, je n'ai plus besoin ici de mon ennu-click, ça ne sert plus à rien. Et là, j'ai mon bouton qui, tout seul, c'est un increment de un... Et si je le souhaite, je peux changer les paramètres pour le dire, par exemple, incrementes-toi à partir de la valeur 0 et 210. Et vous commencez, je pense, à percevoir l'intérêt que peut avoir ce genre de... Vous pouvez vraiment isoler une partie de la logique dans une fonction que vous pouvez ensuite garder de côté et automatiquement, vous simplifiez le code à l'intérieur de vos composants, pour vous concentrer vraiment sur la partie RM2. D'ailleurs, pour ce use increment, auto-increment, vous pouvez même faire appel à votre autre ouc personnalisé. Vous pouvez lui dire ici, je vais avoir une fonction qui va s'appeler incrementes et je vais utiliser mon use incrementes. Je ne vais pas serrer la valeur initiale et la valeur du saut. À ce niveau-là, niveau de use effect, je n'ai plus besoin d'appeler cette coute, je peux simplement lui demander de faire un appel à incrementes. Donc là, on a un ouc personnalisé qui utilise un autre ouc personnalisé. Et si je regarde au niveau de la partie composant, dans React DevTool, on voit qu'on a notre ouc au niveau de compteur qui s'appelle auto-increment, et quand je déplie en a le ouc increment, qui contient l'état, qui est la valeur qui change. Donc ça aussi, c'est un aspect très intéressant d'éouc. Vous avez la possibilité, comme en fait, des fonctions basiques, de les combiner et de pouvoir composer de nouveaux oucs, à partir d'autres oucs. Alors on va finir avec un dernier petit ouc, c'est un ouc qui permettrait de récupérer des données en ajox. Donc imaginons, on aimerait bien créer une liste de éléments affaires. Donc on va utiliser Gis on playsolder ici. Donc il est une fois sa pays qui vous permet de tester simplement les choses. Alors hop, j'aimerais bien aller sur le site. Donc il y a une apéie qui s'appelle ToutDou ici et qui nous renvoie de 200 éléments. Alors non, on ne veut pas 200 éléments, on va mettre un point d' interrogation à l'ascense corps limite, et gale 10. On veut simplement les 10 derniers itels. Donc on aimerait bien avoir une fonction qui nous permette de récupérer ces éléments-là. Donc au niveau de mon application, je me imagine à voir un nouveau composant quand on va mettre en dessous, qui sera ToutDou liste. Ce composant, je vais aller le créo dessus. Je vais créer une nouvelle fonction qui s'appelle ToutDou liste. À l'intérieur, je vais faire un return et je vais rendre un UL qui contiendra ensuite des LI avec chacun de nos taches à faire. Comme ceci. Donc pour récupérer les taches depuis la pays, il va me falloir un état qui permettra de sauvegarder les différentes taches. Je vais créer une nouvelle constante qui sera leur résultat d'un OUK, donc ça sera un tableau avec ToutDou, la liste des éléments, et cette ToutDou. Et par des fausses, je vais lui dire que c'est un tableau vite. Donc là, je le créais un petit état local au niveau de mon composant. Maintenant, j'ai besoin de lui dire dès que le composant est monté, j'aimerais bien que tu fasses un appel à Jacques pour récupérer les informations. Donc typiquement, là, on est dans le cas d'utilisation du Use Effect. Donc je fais un Use Effect. Hop, je vais lui passer une fonction et à l'intérieur, on fera notre traitement. Et ce Use Effect ne dépend de rien. Alors, le problème c'est que là, on veut faire un appel à Jacques, à cette URL. Donc on pourrait être tenté d'utiliser une fonction à 5G, un écrivant E-Waith ici. Malheureusement, si vous faites ça, vous allez avoir un problème, parce que si vous écrivez un E-Waith, la fonction va maintenant retourner une promesse. Or, use Effect lui, l'attente que vous retourniez une fonction et pas une promesse. Donc si jamais vous voulez trailler avec les promesses, c'est pas idéal, mais ce que vous devez faire, c'est créer une fonction qui va surtout appeler, qui elle sera à 5G, comme ceci. Et là, vous appeler directement cette fonction. C'est un petit détail, mais ça évite d'avoir le problème avec le retour de promesse. Alors pour le reste, il n'y a pas de méthode simple, enregistré pour faire ça. Enfin, il n'y a pas quelque chose qui est dans une standard. Mais ce qu'on pourrait s'imaginer plus tard, quand ça arrivera, si ça arrive, c'est sauf garder la promesse dans une variable. On l'a appelé RIP. Et pour le dire, que au niveau de la fonction de nettoyage, ça serait une fonction qui annulerait en fait la promesse. Comme ça, si jamais le composant est démonté avant d'avoir obtenu le résultat qu'il attendrait, ça éviterait de continuer à faire son execution. Donc ça peut être quelque chose qui est intéressant, mais alors actuellement, on ne peut pas le faire. En tout cas, on ne peut pas le faire sans rajouter des libres réids ou du code en plus. Donc à l'intérieur de cette fonction, à 5G, on va récupérer la réponse depuis la pays. En faisant un white, de fetch, et on va récupérer le résultat. Une fois qu'on a ce résultat, on va récupérer les data. Donc on va faire un réponse data également, de response.gson. Si le résultat est correcte, donc si la réponse nous a envoyé un bon statut, dans ce cas-là, on va pouvoir faire un traitement. Dans le cas contraire, on va simplement faire un alerte de response data que l'on va stringifier à l'émite. Ça veut dire que le serveur nous a pas répondu correctement, mais on sait pas trop pourquoi. On ne se focalise vraiment pas ici sur la gestion des erreurs. Si la réponse est correcte, parce qu'il faudrait faire, c'est changer la valeur des tout doulistes. Donc l'ennuie-dim demande aurait de faire un 7 tout doux et on lui passerait un paramètre le retour de la pays. Et là, on a une petite partie qui va permettre de gérer la synchrome. Maintenant, au niveau de mon LI, je peux lui dire, j'aimerais bien afficher chaque 1 du métodou. Donc je vais faire un petit tout doux, point map, et je vais lancer une fonction. Et cette fonction, elle va recevoir chaque élément et elle affichera simplement le titre de la tâche. Donc nous, on affichera T.title. Et on n'oublie pas de bien fermer la parenthèse et la collade. Si je sauvegarde maintenant et que je réactualise ma page, on voit que ça met un petit temps à charger et ensuite, ça m'affiche les éléments de ma tout douliste. Non, on pourrait se dire, ça serait sympa d'afficher un retour visual à l'utilateur pour lui dire que c'est un train de charger, par exemple. Donc on pourrait faire une constante, que l'on appellerait Lodding, et ensuite, on aurait 7 Lodding. Et par défaut, on ferait un use state et on lui préciserait que la valeur s'est troupe. Par défaut, c'est un train de charger. Lorsqu'on a fini notre tête traitement à synchrome ici, on pourra faire un 7 Lodding et lui dire que la valeur doit passer à false. On a fini le chargement. Au niveau du retour de ma fonction, je peux lui dire if Lodding, c'est-à-dire est-ce qu'il y a un chargement? Et si un chargement, je veux simplement que tu affiche le texte chargement avec rien d'autre. Tu n'affiche or à le UL que lorsque le chargement aura fini et que tu aura fait ce traitement-là. Donc je sauvegarde. Et là, bah il est peut-être un petit peu trop rapide malheureusement, donc on n'a pas forcément vu, mais si je réactualise, on voit le chargement s'affiché très brièvement. Je vais juste changer la valeur de limite pour qu'il met du temps à nous reprendre. Et là, on voit bien qu'on a un chargement et que c'est au bout d'un certain temps qu'on va avoir nos résultats. Donc c'est impeccable. On a géré ça. Maintenant, imaginez-nous, on se dit, j'aimerais bien avoir un tableau qui me permet d'afficher les derniers articles. Où les derniers commentaires? Qu'est-ce que vous voulez? Comment t'es ralé? Et on mettra aussi une petite limite. Donc on mettra un point d'étarvation limite, les gâles et on mettra 10. Et c'est un d'un scone limite. Au niveau de ce tableau-là, on a différentes choses. Nous on va récupérer le nom, l'imail et le body. Donc on veut trois colonnes. Donc je vous demande à essayer de créer une fonction qui va s'appeler post-table. Et cette fonction, elle va, elle-même faire la pelle et récupérer le gisone. En vrai, de manière générale, on aurait plutôt tendance effectivement à passer sa sous forme de props. Mais là, c'est vraiment pour l'exemple. Essayer de créer ce composant-là. Donc par défaut, le réflexe serait de retourner une table et à l'intérieur d'avoir un théâtre avec un théâtre et des théâches. On aurait le titre. Est-ce qu'on aurait l'imail? Alors, c'est plutôt le nom. L'imail. Et le contenu. Alors, on va mettre non. Ensuite, au final, on se dit, c'est presque la même logique que celle-là. Donc, on s'en vaite pas. On recopie les éléments et on change juste la partie ap ici pour le dire, j'aimerais bien récupérer des articles, comme ceci. On changeerait ensuite ce tout douleur. Ce tout douleur, et on l'appellerait Items, par exemple. On changeerait ce cet out-o pour cet Items. La partie loading, on veut la garder, elle est très très très bien, pas de problème à ce niveau-là. Et à la fin, je récupère mes Items et je peux faire une petite boucle pour les afficher dans le tableau. Je pourrais faire un tébaudi et faire une petite boucle en l'unisant Items.map et pour chaque Items, je veux que tu génères intérieurs. Et à l'intérieur du T-R, tu as un TD avec le nom que je pourrais récupérer en faisant Items.name. Je pourrais récupérer l'imail en faisant Items.mail. Et pour le contenu, c'est Items.mbodd. L'histoire de ne pas avoir de problème contrairement à tout à l'heure, je vais définir une clé et la clé, ça sera Items.id. Et pour faire les choses bien, je vais faire la clé aussi au niveau du LIC ici. Je veux dire que la clé, c'est le la tout doule point ID. Et là, j'ai créé mon composant qui permet de créer un tableau. Ce composant, je vais pouvoir ensuite le charger dans mon composant d'application. Donc là, on le mettrai ici en l'appeler post table. Je s'affigarde, je reviens sur ma page. On voit qu'il y a chargerment qui s'affiche et au bout d'un petit moment, on a bien nos différents éléments. Il manque peut-être le nom et l'imail. J'ai dû peut-être me tromper. Ah oui, non, je me suis trompé parce que j'ai charger post et c'était commences. Au autant pour moi. Donc, je réactualise. On voit toujours notre chargerment qui s'affiche. Et ensuite au bout d'un moment, on a un autre de colonne. Le problème, c'est qu'on est très peu efficace là. Parce que finalement, on a recopié la logique de un composant à l'autre. Et on retombe sur la problématique que je vous avais évoqué tout à l'heure. Du coup, ce qui serait très intéressant, c'est carrément de créer un hook personnalisé pour gérer ce genre de situation. Parce que c'est une situation que l'on a deux fois. Donc si c'est une situation que l'on a deux fois, nouveau, c'est pareil dans un hook. On l'appelle Aurée UseFetch. Par exemple, ça prend un paramètre URL à appeler et ça récupérerait les résultats. Au niveau du retour, de quoi j'ai besoin. Dans mes composants, j'ai besoin de savoir si on est en train de charger. Et j'ai besoin de savoir, est-ce qu'on a les résultats ? Donc là, je vais simplement retourner un tableau avec logique et items qui seraient les différents éléments. Je vais me créer un état. Donc là, je vais fusionner pour gagner un clarté et un performance en faisant un conste. State, set, state. Et on va lui dire que la valeur par défaut, c'est un objet qui contient les différents items. Donc on mettra items qui est un tableau vide. Et ensuite, on mettra logique qui est par défaut à trou. Hop là ! Attention, l'autocomplition de VSC, d'un peu violente. Lorsque j'exporte les choses, je pourrais lui dire, c'est au niveau de state que je vais récupérer un loading et au niveau de state que je vais récupérer items. La partie logique, je peux l'extraire depuis l'oppost table. Donc je vais re-récuperer toute cette partie-là, qui m'intéresse. Et allez, la déplacer au niveau de mon UseFetch. Donc là, je vais recevoir un paramètre URL, où je pourrais lui passer ici URL. Ensuite, tout le reste ne change pas, si ce n'est à ce niveau-là, que vu que j'ai choisi de fusionner mon état, il faut que je fasse un set state. Je lui donnerai les items, ce qui sera donc égal à response data. Et j'en profite pour aussi, changer la valeur du loading, en faisant loading, 2.4. Ça me permet comme ça de n'avoir qu'un appel à set state et de ne déclencher qu'un nouveau rendu. Dans le cas où on a un problème, je ferai un set state, je vais lui dire qu'on n'a pas de nouveaux items. Donc là, je l'ai sent à blog vide, et dans le loading, je vais lui dire que c'est false. Où ce que je peux faire, c'est utiliser la destructuration. Et lui dire, je vais recevoir un paramètre l'état, au moment où je l'appelle la S, et je vais lui dire récupère tout, et change juste la valeur de loading pour mettre false. Comme ceci. Et ça, pour que ce soit retourné directement, il faut que ce soit entreparentais. Et là, on a notre petit oeuvre, des faits qui va permettre de déclencher des appels en Ajax. Donc je peux le refermer, et aller l'utiliser dans mon poste table. Donc je peux maintenant avoir un simple loading et items, et lui dire que ça sera un use fetch, et je lui demande de récupérer cet URL là. Et hop hop hop, j'ai maintenant extrait la partie logique de ce composant là, ailleurs. Et le gros avantage, c'est que si cet logique se retrouve ailleurs, et ça a été notre cas effectivement pour notre tout douliste, je peux faire le même code, en ne changeant que la partie URL. Donc c'était... On va mettre tout doux, et comme ça. Et ça simplifera la logique de mon composant. C'est un exemple évidemment, mais on peut en imaginer plein d'autres. Et le gros avantage, c'est que la partie map, pour m'appeler sur les différents items, ou renommer le retour ici en tout doux, comme vous voulez. Et ça nous donne toujours, et encore, le même résultat. Donc j'espère que à travers ces exemples, ça vous permettra de mieux comprendre, en fait, le gros intérêt que peut avoir les hooks. Les hooks vont vous permettre au fil du temps et au fil de votre utilisation de réactes de séparer une partie de la logique dans des fonctions qui vont être réutilisables. Et de pouvoir extraire plus de choses. Et de vous focaliser sur ce qui est essentiel au niveau des composants, c'est-à-dire la partie R2. Après, si vous n'êtes pas forcément à l'aise ou si vous n'appréciez pas cette appellée-là, sachez que vous n'êtes pas obligé de l'utiliser. Vous pouvez continuer à utiliser les composants sous forme de classe, mais sachez que vous perdez peut-être en possibilité de réorganisation si vous n'utilisez pas ce système de hook. Au final, ça reste avant tout une question de choix personnels. Est-ce que vous vous aimez cette structure-là? Est-ce que vous allez l'utiliser correctement pour bénéficier des avantages, à savoir la séparation et la réutilisation? Et est-ce que ça peut être efficace d'un votre code? Donc, ce que je vous propose dans le chapitre suivant, c'est de continuer à découvrir d'autres hooks qui vont permettre de gérer certaines autres situations. Donc, je vous donne rendez-vous dans le chapitre suivant.