 A bienvenue dans ce nouveau chapitre où je vous propose de ne pas forcément prendre de d'où elle est de faire un petit récapitulatif de tout ce que l'on a vu jusqu'à maintenant. Donc on a découvert ensemble la pays des OUK qui est une nouvelle à pays qui permet d'interagir avec l'Etat et le cycle de vie des composants dans le cadre de composants définissent sous forme de fonction. Donc vous avez différents OUK que l'on a vu jusqu'à maintenant. Le premier c'est l'OUK UserState. Donc UserState va permettre de définir un état local, on lui passe en premier paramètre tout simplement la valeur initiale et ça nous rend vers un tableau de taille de l'Etat avec en premier la valeur qui correspond à l'Etat et en second une fonction qui permet de muter cet état-là. A chaque fois que l'on fait une mutation, automatiquement le composant est rendu. On a vu un dérivée de cette fonction qui était la fonction UseReducesseur qui permet de faire un petit peu la même chose avec en plus la possibilité d'avoir une fonction de réduction qui peut permettre de faire des changements d'Etat plus complexes. Donc si vous avez un état plus compliqué à définir, mieux vous de réaliser UseReducesseur. Ensuite on a parlé de UseEffect et UseLayerTefect. Donc UseEffect va permettre de créer des comportements asynchronous lorsqu'un état va changer ou tout simplement lorsqu'on va être monté. Lorsque votre composant va être monté. Donc si jamais vous avez besoin d'interagir avec quelque chose de type tiers, par exemple un timer, vous connectez à des websoquettes ou ce genre de choses, on y sera UseEffect. Si vous voulez affecter des modifications aux dommes avant que ça soit présent à l'utiliateur, on y sera UseLayerTefect. On n'oublira pas que UseEffect va prendre en valeur de retour une fonction qui permettra de défaire ce qui a été fait à l'Etat précédent. Donc si jamais vous connectez à un websocket, pensez à vous déconnecter. Si jamais vous démarrez un timer, passez à les effacer pour éviter tout problème lorsque vos composants sont démontés. Ensuite, on a vu UseMemois et UseColVac qui sont tout simplement des ou qui vous permettent de gérer de la mémosisation et de garder un mémoire certaine donné. Donc on a vu deux utilisations pour ce système-là. UseMemois, on a vu que ça peut vous éparmettre d'améliorer les performances en évitant de refaire un traitement systématiquement. Et UseColVac, ça va être surtout très utile pour tout ce qui est ColVac que l'on passerait au composant en forme. Pour éviter qu'un composant pure comprenne qu'il est de nouvelles propriétés et qui ne seraient actualises systématiquement. Donc, UseColVac permet d'avoir un ColVac qui est mémoisé. Enfin, on a vu UseRef qui permet tout simplement de créer une référence que l'on peut utiliser et qui permet de mémoriser une valeur au fil du temps de la vie de votre composant. Donc c'est très utile notamment avec la propriété Ref que l'on peut passer aux éléments qui ne permettent de récupérer une instance de l'élément dans le dom. Donc c'est cette hook permettent de faire globalement tout ce que l'on pourrait avoir envie de faire avec des composants réactes. Si vous regardez la documentation, vous allez vous dire que finalement je n'ai pas parlé de certains hook. Pour l'instant, j'ai ignoré trois hook. Donc le premier c'est UseContext, tout simplement parce que ça attraient avec un autre système que l'on va voir juste après. Donc c'est le système de contexte. On peut l'utiliser à la fois avec des composants surprendre de classe et à la fois avec des composants surprendre de fonction. Donc c'est un petit peu de particulier, donc on va en parler juste après. UseInperativeUnDull c'est un hook qui n'a pas forcément vocation à être utilisé. On vous déconceille d'ailleurs de l'utiliser dans la documentation qui est surtout là pour certains raisons de compatibilité, je dirais. Mais en vrai, il n'y a pas forcément de cas qui font se présenter, ou ça peut être pertinient. En fait, le UseDbugValue va plutôt être un hook qui va servir pour la partie Dbug. Si jamais vous avez des composants particuliers et que dans l'inspecteur, vous voulez avoir des retours spécifiques. Concretement, en moi, ce que vous développez ni libérer, ça n'a pas forcément trop de sens de l'utiliser. Mais en dehors de ça, voilà, ça peut être intéressant de lire son fonctionnement dans la documentation, mais ça n'a pas forcément d'intérêt lorsque l'on travaille avec réactes. Si vous avez besoin de plus d'informations sur le fonctionnement des hooks, n'hésitez pas à lire la FAQ qui vous explique un petit peu certains points particuliers par rapport aux fonctionnement des hooks. Ce qu'on retiendra particulièrement, c'est que les hooks doivent toujours être appelés de la même manière dans le même ordre. Parce que, en fait, réactes utilisent l'ordre d'appel pour savoir à quoi correspond chaque appel. Vous pouvez séparer vos hooks dans des hooks personnalisés, ce sont simplement des fonctions qui font appel elles-mêmes à des hooks de réactes, mais vous ne pouvez pas, par exemple, utiliser hooks dans des conditions ou dans des boucles au risque de voir l'ordre d'appel complètement changé au fil des appels. Et ça, ça peut provoquer des problèmes pour que réactes puissent faire la correspondance. En tous les cas, il vous affichera des alertes dans ces situations-là, mais retenez ça. Vous ne pouvez utiliser un hook que dans un autre hook personnalisé ou dans un composant directement et en dehors d'un iv et en dehors d'un effort. Donc, si vous avez bien assimilé ça, je vous donnerai un des vous dans le prochain chapitre. On va justement parler ensemble du concept de contexte.