# Algorithms & Data Structures Learning Roadmap

**Chapter 1: Foundations**

- [ ] **1. Language Specifics (C/C++)**
    - [ ] 1a. Introduction to Pointers in C
    - [ ] 1b. Difference Between Memory Address and Pointer
    - [ ] 1c. Referencing and Dereferencing
    - [ ] 1d. Pointers inside Functions
    - [ ] 1e. Dynamic Memory Allocation (malloc)
    - [ ] 1f. Dynamic Array Allocation
    - [ ] 1g. How to Read Pointer Declarations
    - [ ] 1h. Variable Declaration Syntax (int a vs int* a)
    - [ ] 1i. Constant Pointers
    - [ ] 1j. Pointers to Functions
- [ ] **2. Complexity Analysis**
    - [ ] 2a. Big O Notation Concepts
    - [ ] 2b. Time and Space Tradeoffs

**Chapter 2: Linear Data Structures - Arrays & Strings**

- [ ] **3. Arrays**
    - [ ] 3a. 1D Arrays Concepts
    - [ ] 3b. 2D Arrays/Matrices
    - [ ] 3c. Dynamic Arrays/Vectors
    - [ ] 3d. C++ Dynamic Allocation & Functions
    - [ ] 3e. C++ Parameter Passing
    - [ ] 3f. Double Dimension Arrays
    - [ ] 3g. Array Implementations
    - [ ] 3h. Array Problems Practice
- [ ] **4. Strings**
    - [ ] 4a. String Basics and Operations
    - [ ] 4b. Pattern Matching Algorithms
        - [ ] 4b1. KMP Algorithm
        - [ ] 4b2. Rabin-Karp Algorithm
    - [ ] 4c. String Implementations
    - [ ] 4d. String Problems Practice

**Chapter 3: Linear Data Structures - Lists & Abstract Data Types**

- [ ] **5. Linked Lists**
    - [ ] 5a. Singly Linked Lists
    - [ ] 5b. Doubly Linked Lists
    - [ ] 5c. Circular Linked Lists
    - [ ] 5d. Linked List Implementations
    - [ ] 5e. Linked List Problems Practice
- [ ] **6. Stacks**
    - [ ] 6a. Stack Applications
    - [ ] 6b. Array Implementation of Stack
    - [ ] 6c. Linked List Implementation of Stack
    - [ ] 6d. Stack Implementations
    - [ ] 6e. Stack Problems Practice
- [ ] **7. Queues**
    - [ ] 7a. Array Implementation of Queue
    - [ ] 7b. Linked List Implementation of Queue
    - [ ] 7c. Circular Queues
    - [ ] 7d. Deques (Double-ended Queues)
    - [ ] 7e. Queue Implementations
    - [ ] 7f. Queue Problems Practice

**Chapter 4: Hierarchical Data Structures - Trees**

- [ ] **8. Tree Basics**
    - [ ] 8a. Tree Introduction and Terminology
- [ ] **9. Binary Trees**
    - [ ] 9a. Binary Tree Properties
    - [ ] 9b. Binary Tree Traversals (Inorder, Preorder, Postorder, Level-order)
    - [ ] 9c. Binary Tree Implementations
- [ ] **10. Binary Search Trees (BST)**
    - [ ] 10a. BST Operations (Insert, Delete, Search)
    - [ ] 10b. Balanced BST Introduction
    - [ ] 10c. BST Implementations
- [ ] **11. Heaps & Priority Queues**
    - [ ] 11a. Min/Max Heaps Concepts
    - [ ] 11b. Heap Implementations
- [ ] **12. Advanced Trees**
    - [ ] 12a. Tries (Prefix Trees)
    - [ ] 12b. Segment Trees
- [ ] **13. Tree Problems Practice**
    - [ ] 13a. General Tree Problems

**Chapter 5: Network Data Structures - Graphs**

- [ ] **14. Graph Basics**
    - [ ] 14a. Graph Introduction and Terminology
- [ ] **15. Graph Representations**
    - [ ] 15a. Adjacency Matrix
    - [ ] 15b. Adjacency List
- [ ] **16. Graph Traversals**
    - [ ] 16a. Breadth-First Search (BFS)
    - [ ] 16b. Depth-First Search (DFS)
- [ ] **17. Shortest Path Algorithms**
    - [ ] 17a. Dijkstra's Algorithm
    - [ ] 17b. Bellman-Ford Algorithm
- [ ] **18. Minimum Spanning Trees (MST)**
    - [ ] 18a. Kruskal's Algorithm
    - [ ] 18b. Prim's Algorithm
- [ ] **19. Topological Sort**
    - [ ] 19a. Topological Sort Algorithm
- [ ] **20. Other Graph Topics**
    - [ ] 20a. Connected Components
    - [ ] 20b. Cycle Detection
- [ ] **21. Graph Problems Practice**
    - [ ] 21a. General Graph Problems

**Chapter 6: Hash-Based Data Structures**

- [ ] **22. Hashing**
    - [ ] 22a. Hash Tables/Maps Concepts
    - [ ] 22b. Hash Functions
    - [ ] 22c. Collision Resolution Techniques
    - [ ] 22d. Hashing Implementations
    - [ ] 22e. Hashing Problems Practice

**Chapter 7: Sorting Algorithms**

- [ ] **23. Basic Sorting Algorithms**
    - [ ] 23a. Bubble Sort
    - [ ] 23b. Selection Sort
    - [ ] 23c. Insertion Sort
- [ ] **24. Advanced Sorting Algorithms**
    - [ ] 24a. Merge Sort
    - [ ] 24b. Quick Sort
    - [ ] 24c. Heap Sort
- [ ] **25. Sorting Analysis**
    - [ ] 25a. Sorting Algorithms Comparison

**Chapter 8: Searching Algorithms**

- [ ] **26. Search Techniques**
    - [ ] 26a. Linear Search
    - [ ] 26b. Binary Search
    - [ ] 26c. Searching Problems Practice

**Chapter 9: Advanced Problem-Solving Techniques**

- [ ] **27. Recursion & Backtracking**
    - [ ] 27a. Recursion Basics
    - [ ] 27b. Backtracking Framework
    - [ ] 27c. Recursion & Backtracking Problems Practice
- [ ] **28. Dynamic Programming**
    - [ ] 28a. Core Concepts
        - [ ] 28a1. Optimal Substructure
        - [ ] 28a2. Overlapping Subproblems
    - [ ] 28b. DP Techniques
        - [ ] 28b1. Memoization (Top-down)
        - [ ] 28b2. Tabulation (Bottom-up)
    - [ ] 28c. Common DP Patterns
        - [ ] 28c1. 1D DP Problems
        - [ ] 28c2. 2D DP Problems
        - [ ] 28c3. Knapsack Pattern
        - [ ] 28c4. Longest Increasing Subsequence (LIS) & Longest Common Subsequence (LCS)
    - [ ] 28d. Dynamic Programming Problems Practice
- [ ] **29. Greedy Algorithms**
    - [ ] 29a. Greedy Choice Property
    - [ ] 29b. Standard Greedy Problems
    - [ ] 29c. Greedy Problems Practice
- [ ] **30. Bit Manipulation**
    - [ ] 30a. Bitwise Operators
    - [ ] 30b. Common Bit Manipulation Tricks and Techniques
    - [ ] 30c. Bit Manipulation Problems Practice

**Chapter 10: Problem-Solving Patterns & Strategies**

- [ ] **31. General Problem-Solving Patterns**
    - [ ] 31a. Pattern Recognition Techniques
    - [ ] 31b. Common Algorithm Templates
    - [ ] 31c. Debugging Tips
- [ ] **32. Specific Problem-Solving Patterns**
    - [ ] 32a. Two Pointers Technique
    - [ ] 32b. Fast & Slow Pointers
    - [ ] 32c. Sliding Window Pattern
    - [ ] 32d. Divide and Conquer
- [ ] **33. Interview Preparation**
    - [ ] 33a. LeetCode Top 150 Problems

**Chapter 11: Practical Application & Review**

- [ ] **34. Implementation Practice**
    - [ ] 34a. Code all major data structures from scratch
    - [ ] 34b. Implement all major algorithms from scratch
- [ ] **35. Problem-Solving Practice**
    - [ ] 35a. Solve problems from each category
    - [ ] 35b. Time yourself on problem-solving
    - [ ] 35c. Practice explaining solutions
- [ ] **36. Review & Integration**
    - [ ] 36a. Review complexity analysis for all topics
    - [ ] 36b. Understand when to use each data structure/algorithm
    - [ ] 36c. Practice system design with learned concepts