
# Semi-Structured Data - Chapter 3: XPath

---

## Généralités (General Concepts)

### XPath - Définition

#tags: #XPath #definition #navigation #selection #XML_tree #non_XML #W3C

*   **XPath:** A language defined by W3C, specifically designed for **navigating** through the elements and attributes of an XML document. Its syntax is **not** XML-based.
*   **Purpose:** It allows the **selection** of specific parts of an XML document, such as:
    *   Nodes (elements, attributes, text, comments, processing instructions)
    *   Sets of nodes (node-sets)
    *   Sub-trees
    *   Attribute values
    *   Atomic values (strings, numbers, booleans derived from nodes)
*   **Core Functionality:** XPath models the XML document as a **tree** and provides expressions (paths) to traverse this tree and select nodes based on various criteria (name, hierarchy, content, attributes).

### XPath - Role in XML Technologies

#tags: #XPath #XSLT #XQuery #XLink #XPointer #XML_stack

XPath is a fundamental building block used extensively by other core XML technologies:

*   **XSLT (Extensible Stylesheet Language Transformations):** Uses XPath expressions extensively in `select` and `match` attributes to select nodes for processing, copying, or applying templates during XML transformations.
*   **XQuery (XML Query Language):** Uses XPath as its foundation for selecting nodes from XML documents or databases before performing more complex querying, joining, and restructuring operations.
*   **XLink:** While less common now, XLink uses XPath-like concepts for defining traversal and linking behavior between resources.
*   **XPointer:** A syntax for addressing specific parts *within* an XML document, often leveraging XPath expressions to identify the target points or ranges.

---


[[2. XPath Syntax]]
## Les axes (Axes)

#tags: #XPath #axis #navigation #tree_traversal #node_relationship

Axes define the relationship between the context node and the nodes to be selected by a location step.

*   **`self`**: Contains the context node itself.
*   **`child`**: Contains the children of the context node (elements, text, comments, PIs).
*   **`descendant`**: Contains all descendants of the context node (children, grandchildren, etc.). Does *not* include the context node itself.
*   **`descendant-or-self`**: Contains the context node *and* all its descendants. (`//` is shorthand for `/descendant-or-self::node()/`).
*   **`parent`**: Contains the parent of the context node (if it has one). (`..` is shorthand for `parent::node()`).
*   **`ancestor`**: Contains the parent, grandparent, etc., up to the root node.
*   **`ancestor-or-self`**: Contains the context node *and* its ancestors.
*   **`attribute`**: Contains the attributes of the context node. (`@` is shorthand for `attribute::`).
*   **`following-sibling`**: Contains all sibling nodes that appear *after* the context node in document order and share the same parent.
*   **`preceding-sibling`**: Contains all sibling nodes that appear *before* the context node in document order and share the same parent.
*   **`following`**: Contains all nodes in the document that appear *after* the context node in document order, excluding descendants and attributes.
*   **`preceding`**: Contains all nodes in the document that appear *before* the context node in document order, excluding ancestors and attributes.
*   **`namespace`**: Contains the namespace nodes of the context node (less commonly used directly in paths).

**(See Slide 29 for a diagram illustrating `parent`, `self`, `child`, `preceding-sibling`, `following-sibling`).**

---

## Les filtres (Filters / Node Tests)

#tags: #XPath #node_test #filtering #node_type #wildcard #name_test

Node tests are used within a location step to filter nodes based on their type or name after the axis has selected an initial set.

*   **`node()`**: Selects any node (element, attribute, text, comment, PI, namespace). Most general test.
*   **`text()`**: Selects only text nodes.
*   **`*`**: Selects only element nodes (wildcard for any element name).
*   **`nom` (Specific Name):** Selects only element nodes with the exact name `nom`. If prefixes are used, `prefix:nom` selects elements with that specific qualified name.
*   **`comment()`**: Selects only comment nodes (`<!-- ... -->`).
*   **`processing-instruction()`**: Selects any processing instruction node (`<? ... ?>`).
*   **`processing-instruction('target')`**: Selects processing instructions with a specific target name.

**Examples (using XML from Slide 6/31 and tree):**

*   `/A/B/child::*` (Equivalent to `/A/B/*`): Selects all element children of `/A/B`.
    *   *Result: `<C>C1</C>`, `<C>C2</C>`, `<C>C5</C>`* (Assuming context `/A`). If context is `/`, selects C1, C2, C5.
*   `/child::A/child::B/child::*` (Equivalent to `/A/B/*`): Same as above.
*   `/A/child::B/*` (Equivalent to `/A/B/*`): Same as above.
*   `/A/B/child::node()`: Selects *all* nodes (element, text if any) that are children of `/A/B`.
    *   *Result: `<C>C1</C>`, `<C>C2</C>`, `<C>C5</C>`* (since only element children exist).
*   `/child::A/child::B/child::node()` (Equivalent to `/A/B/node()`): Same as above.
*   `/A/child::B/node()` (Equivalent to `/A/B/node()`): Same as above.
*   `/descendant::*` (Equivalent to `//*` starting from root): Selects all element descendants of the root node.
    *   *Result: `<A>`, `<B>`, `<C>`, `<B>`, `<C>`, `<D>`, `<C>`, `<E>`, `<B>`, `<C>`, `<B>`, `<C>`*
*   `/A/B/descendant::*` (Equivalent to `/A/B//*`): Selects all element descendants of all `<B>` elements that are children of `<A>`.
    *   *Result: `<C>C1</C>`, `<C>C2</C>`, `<C>C5</C>`*
*   `//A/descendant::B` (Equivalent to `//A//B`): Selects all `<B>` elements that are descendants of `<A>`.
    *   *Result: The first `<B>`, the second `<B>`, the `<B>` inside `<E>`, the last `<B>`.*
*   `//B/parent::*`: Selects the parent element of every `<B>` element in the document.
    *   *Result: `<A>` (parent of first two B's), `<E>` (parent of third B), `<A>` (parent of last B). Resulting node set: `<A>`, `<E>` (duplicates removed).*
*   `//B/following-sibling::*`: Selects all element siblings that follow any `<B>` element in the document.
    *   For first `<B>`: second `<B>`, `<D>`, `<E>`, last `<B>`.
    *   For second `<B>`: `<D>`, `<E>`, last `<B>`.
    *   For `<B>` inside `<E>`: None.
    *   For last `<B>`: None.
    *   *Result: `<B>`, `<D>`, `<E>` (duplicates removed).*
*   `//E/following-sibling::*`: Selects element siblings following the `<E>` element.
    *   *Result: The last `<B>` element.*
*   `//E/following::*`: Selects all elements that start after the `<E>` element in document order (excluding descendants).
    *   *Result: The last `<B>`, its child `<C>C5</C>`.*

### Union

#tags: #XPath #union #pipe_operator #combining_results

*   **Operator:** `|` (Pipe symbol)
*   **Purpose:** Combines the node sets resulting from two or more separate XPath expressions into a single node set.
*   **Behavior:** The resulting node set contains all nodes selected by *any* of the expressions, with duplicates automatically removed. The order is typically document order.

**Example:**

Path: `//E/following::* | /A/D`

1.  `//E/following::*`: Selects elements following `<E>` -> last `<B>` and its child `<C>C5</C>`.
2.  `/A/D`: Selects the `<D>` child of `<A>`.
3.  **Union:** Combines these results.
    *   *Result: `<D>`, last `<B>`, `<C>C5</C>` (in document order).*

---

## Les prédicats (Predicates)

#tags: #XPath #predicate #filtering #boolean_expression #square_brackets #node_set

*   **Definition:** A predicate is a boolean expression enclosed in square brackets `[...]` that filters a set of nodes selected by an axis and node test.
*   **Evaluation:** The predicate is evaluated for each node in the node set selected by the preceding location step part (axis::node-test). Only nodes for which the predicate evaluates to **true** are kept in the result set.
*   **Content:** Predicates can contain:
    *   Comparisons (numeric, string, boolean)
    *   Logical connectors (`and`, `or`)
    *   Calls to XPath functions (`position()`, `last()`, `count()`, `contains()`, `starts-with()`, `not()`, etc.)
    *   Checks for existence of sub-elements or attributes
    *   Other path expressions evaluated relative to the node being tested.

**Common Predicate Examples:**

*   `x[1]`, `x[2]`: Selects the first/second element `x` selected by the preceding step (positional predicate). Position is relative to the set selected by the axis.
*   `x[last()]`: Selects the last element `x`.
*   `x[@a='valeur']`: Selects elements `x` that have an attribute `a` with the value `"valeur"`.
*   `x[not(@*)]`: Selects elements `x` that have no attributes.
*   `x[y=1]`: Selects elements `x` that have a child element `y` whose value equals `1`.
*   `x[@a='v1' and @b='v2']`: Selects elements `x` that have attribute `a` equal to `v1` AND attribute `b` equal to `v2`.
*   `x[y or z]`: Selects elements `x` that have at least one child element `y` OR at least one child element `z`.

**Applied Examples (using XML from Slide 6/31):**

*   `//B[1]`: Selects the *first* `<B>` element encountered when searching from the root using the `descendant-or-self` axis. This usually means the first `<B>` child of `<A>`. Also selects the first `<B>` child of `<E>`.
    *   *Result: `<B><C>C1</C></B>`, `<B><C>C4</C></B>`* (Note: `[1]` applies within the context of the parent. `/A/B[1]` selects only the first B under A. `//B[1]` selects any B that is the first B child *of its parent*).
*   `/A/B[1]`: Selects the first `<B>` element that is a child of `<A>`.
    *   *Result: `<B><C>C1</C></B>`*
*   `/A/B[last()]`: Selects the last `<B>` element that is a child of `<A>`.
    *   *Result: `<B id="2"><C>C5</C></B>`*

### Les fonctions (Functions)

#tags: #XPath #functions #predicate #string_functions #numeric_functions #boolean_functions #node_functions

XPath includes a core library of functions that can be used within expressions, particularly within predicates, to perform calculations or tests.

**Functions can appear inside predicates `[...]`.**

**String Functions:**

*   `name()`: Returns the qualified name (including prefix) of the context node.
    *   Example: `//*[name()='BB']` selects all elements whose name is exactly "BB".
*   `starts-with(string1, string2)`: Returns true if `string1` starts with `string2`.
    *   Example: `//*[starts-with(name(), 'BB')]` selects elements whose name starts with "BB".
*   `contains(string1, string2)`: Returns true if `string1` contains `string2`.
    *   Example: `//*[contains(name(), 'BB')]` selects elements whose name contains "BB".
*   `string-length(string?)`: Returns the number of characters in the string value (of the context node if argument omitted).
    *   Example: `//*[string-length(name()) < 3]` selects elements whose name has less than 3 characters.
*   **Example Application:** `//livre/titre[contains(text(), "pauvres")]` or `//livre/titre[contains(., "pauvres")]` selects `<titre>` elements (children of `<livre>`) whose text content includes the substring "pauvres". *(Using `text()` or `.` for content).*

**Numeric Functions/Operators:**

XPath supports standard numeric operators (`+`, `-`, `*`, `div`, `mod`) and functions within predicates.

*   `count(node-set)`: Returns the number of nodes in the given node-set.
    *   Example: `//B[count(C)=2]` selects `<B>` elements having exactly two `<C>` children.
    *   Example: `//*[count(*)=2]` selects elements having exactly two element children (any name).
*   `position()`: Returns the position (index, starting from 1) of the context node within the set of nodes currently being processed (often sibling position).
*   `last()`: Returns the size of the context node set (often used to find the last sibling).
    *   Example: `//B[position() mod 2 = 0]` selects the 2nd, 4th, etc. `<B>` element among its siblings.
*   `floor(number)`: Returns the largest integer less than or equal to the number.
*   `ceiling(number)`: Returns the smallest integer greater than or equal to the number.
*   `round(number)`: Returns the integer closest to the number.
*   `number(object?)`: Converts the argument (e.g., boolean, string) to a number.
*   `sum(node-set)`: Calculates the sum of the numeric values of the nodes in the set.
*   **Example Application:** `//B[ position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5) ]` selects the middle element(s) `B` among siblings. *(This complex example demonstrates finding the middle node(s) in a list).*
*   **`floor()` vs `ceiling()` Examples:**
    *   `ceiling(1)` -> 1
    *   `ceiling(2.5)` -> 3
    *   `ceiling(2.3)` -> 3
    *   `ceiling(-2.5)` -> -2
    *   `floor(1)` -> 1
    *   `floor(2.5)` -> 2
    *   `floor(2.7)` -> 2
    *   `floor(-2.5)` -> -3

**Boolean Functions:** `true()`, `false()`, `not(boolean)`, `boolean(object)`.

**Node Functions:** `name()`, `local-name()`, `namespace-uri()`.

---

## Syntaxe abrégée (Abbreviated Syntax)

#tags: #XPath #abbreviated_syntax #shorthand #location_path #axis #node_test

While the full `axis::node-test[predicate]` syntax is explicit, XPath provides several widely used abbreviations for common steps, making expressions much more concise.

**Key Abbreviations:**

| Abbreviated Syntax | Full (Unabbreviated) Syntax             | Description                                      |
| :----------------- | :-------------------------------------- | :----------------------------------------------- |
| (omitted axis)     | `child::`                               | Default axis is `child`                          |
| `@`                | `attribute::`                           | Selects attributes                               |
| `//`               | `/descendant-or-self::node()/`          | Selects descendants anywhere from root/context |
| `.`                | `self::node()`                          | Selects the context node itself                |
| `..`               | `parent::node()`                        | Selects the parent of the context node         |
| `elementName[N]`   | `elementName[position() = N]`           | Selects the Nth element by position            |

**Example Mapping (Slide 74):**

| Syntaxe abrégée (Abbreviated) | Syntaxe étendue (Full / Expanded)          |
| :---------------------------- | :----------------------------------------- |
| `.`                           | `self::node()`                             |
| `A`                           | `child::A`                                 |
| `../A`                        | `parent::node() / child::A`                |
| `@ref`                        | `attribute::ref`                           |
| `//A`                         | `/descendant-or-self::node() / child::A`   |
| `.//A`                        | `descendant-or-self::node() / child::A`    |
| `A[2]`                        | `child::A [ position() = 2 ]`              |

**Important Distinction: `//E[2]` vs `/descendant-or-self::node()/child::E[position()=2]` (Slide 75-78)**

*   `/descendant-or-self::node()/child::E[position()=2]`: This finds *all* E elements that are children of *any* node in the document (`descendant-or-self::node()`) and then selects the second one (`[position()=2]`) **from the entire resulting set of E nodes found across the whole document**. This usually results in selecting only the *single, second E element encountered overall*.
*   `//E[2]`: This is generally interpreted by most processors as selecting **any E element anywhere in the document (`//E`) that is the *second E child of its respective parent***. This can potentially select multiple E elements if different parents each have at least two E children.
    *   **Autrement dit (In other words):** `//E[2]` selects all E nodes that are the second E child of their parent. `/descendant-or-self::node()/child::E[position()=2]` designates a unique node, the second E node encountered in document order among all E children of any node.
    *   **Example Result:** For the sample XML, `/descendant-or-self::node()/child::E[position()=2]` likely finds no node (there's only one E). `//E[2]` also finds no node, as the single E element is the first (and only) E child of its parent A. If there were `<parent><E/><E/></parent>`, `//E[2]` would select the second E.

---

## Utilisation XPATH : XSLT (Using XPath in XSLT)

#tags: #XPath #XSLT #integration #select_attribute #match_attribute #transformation

XPath is crucial for XSLT. It's used primarily in:

*   **`match` attribute (on `<xsl:template>`):** An XPath pattern to identify the nodes in the source document to which the template rule should be applied.
*   **`select` attribute (on `<xsl:value-of>`, `<xsl:apply-templates>`, `<xsl:for-each>`, `<xsl:copy-of>`, `<xsl:variable>` etc.):** An XPath expression to select nodes or compute values from the source document to be processed, output, or stored.

**Example (Slide 79):**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  
  <xsl:template match="/"> <!-- Matches the root node -->
    <html><body>
      <h1>Edition</h1>
      <!-- Selects the text value of the 'edition' element -->
      <xsl:value-of select="//edition"/> 
      <h2>Livres</h2>
      <!-- Applies templates to all 'livre' elements anywhere -->
      <xsl:apply-templates select="//livre"/> 
    </body></html>
  </xsl:template>

  <xsl:template match="livre"> <!-- Matches 'livre' elements -->
    <p><xsl:value-of select="titre"/> by <xsl:value-of select="auteur"/></p>
  </xsl:template>

</xsl:stylesheet>
```
*   The `select="//edition"` and `select="//livre"` are XPath expressions used by XSLT.

---