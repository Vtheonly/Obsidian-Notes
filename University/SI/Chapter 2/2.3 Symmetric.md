
# Modern Symmetric Cryptography

## 1. Introduction to Symmetric Cryptography

Symmetric cryptography uses the **same key** for both encryption and decryption. It's generally faster than asymmetric cryptography.

### Key Concepts (from Claude Shannon, 1949)

*   **Confusion**:
    *   **Goal**: To make the relationship between the ciphertext and the key as complex and involved as possible.
    *   **How it works**: Achieved primarily through **substitution** (e.g., replacing a character or a block of bits with another). S-Boxes in algorithms like DES and AES are a prime example.
        *   *Example*: `ABA` -> `XYZ`
*   **Diffusion**:
    *   **Goal**: To spread the influence of a single plaintext bit over many ciphertext bits. This hides statistical properties of the plaintext.
    *   **How it works**: Achieved primarily through **transposition** or **permutation** (e.g., shuffling the order of bits).
        *   *Example*: `ABC` -> `CAB`
    *   **Avalanche Effect**: A direct result of good diffusion. A small change in the plaintext (e.g., flipping one bit) or the key should result in a significant change (ideally, about half the bits) in the ciphertext.

*   **Product Ciphers**: Modern symmetric ciphers (like DES and AES) are product ciphers.
    *   **How it works**: They achieve strong encryption by applying multiple rounds of simple confusion and diffusion operations.

### Key Size
*   The security of a symmetric cipher heavily relies on the key size (`k`).
*   A good algorithm's best attack should be a brute-force (exhaustive key search), costing `2^k` operations.
*   Recommended key sizes are typically `k > 128` bits.
    *   DES: 56 bits (now considered insecure due to short key length).
    *   AES: 128, 192, or 256 bits.

## 2. Types of Symmetric Ciphers

Symmetric ciphers are broadly categorized into:

*   **Stream Ciphers**:
    *   **How it works**: Encrypt data one bit or one byte at a time. They generate a keystream, which is then XORed with the plaintext.
    *   *Examples*: RC4 (though now has known weaknesses), ChaCha20. Block ciphers in OFB, CFB, or CTR mode also behave like stream ciphers.
*   **Block Ciphers**:
    *   **How it works**: Encrypt data in fixed-size blocks (e.g., 64 bits for DES, 128 bits for AES). The same key is used for each block. If plaintext is larger than a block, it's divided, and a mode of operation is used.

## 3. Key Block Cipher Algorithms (Examples)

### DES (Data Encryption Standard)
*   Older standard.
*   Block size: 64 bits.
*   Key size: 56 bits (effectively, though input is 64 bits with parity).
*   Structure: Feistel network, 16 rounds.
*   Now considered insecure for most applications due to its small key size, making it vulnerable to brute-force attacks.

### AES (Advanced Encryption Standard)
*   Current standard.
*   Block size: 128 bits.
*   Key size: 128, 192, or 256 bits.
*   Structure: Substitution-Permutation Network (SPN). Number of rounds depends on key size (e.g., 10 rounds for 128-bit keys).
*   Operations per round: Byte Substitution (S-Box), ShiftRows, MixColumns, AddRoundKey. (Final round omits MixColumns).

### Simplified DES (S-DES) - For Educational Purposes
*   A simplified version of DES to illustrate the principles.
*   Input/Output Block: 8 bits.
*   Key: 10 bits.
*   Rounds: 2.
*   **Key Generation**:
    1.  Initial 10-bit key undergoes a permutation (P10).
    2.  Split into two 5-bit halves.
    3.  Left shifts (LS-1 for round 1 key, LS-2 for round 2 key) are applied to each half.
    4.  The shifted halves are combined and permuted (P8) to produce an 8-bit subkey for each round (K1, K2).
*   **Encryption Process**:
    1.  **Initial Permutation (IP)** on the 8-bit plaintext.
    2.  **Round 1 Function (Fk1)**:
        *   Right half of IP output is expanded/permuted (EP) from 4 bits to 8 bits.
        *   XORed with subkey K1.
        *   Result is split into two 4-bit parts, each fed into an S-Box (S0, S1).
        *   S-Box output (2 bits each) are combined (4 bits) and permuted (P4).
        *   This result is XORed with the Left half of IP output.
    3.  **Switch Halves (SW)**: The left and right halves from the previous step are swapped (except after the last round).
    4.  **Round 2 Function (Fk2)**: Same as Round 1, but uses subkey K2.
    5.  **Final Permutation (IP-1)**: Inverse of the initial permutation.
*   **Decryption**: Uses the same algorithm but with subkeys K2 then K1.
*   **S-Boxes (Substitution Boxes)**:
    *   **How it works**: Non-linear substitution tables. In S-DES, a 4-bit input determines a row (outer 2 bits) and column (inner 2 bits) in a matrix, yielding a 2-bit output. This is the main source of confusion.

## 4. Block Cipher Modes of Operation

When encrypting multiple blocks of data, a mode of operation is needed.
**Objectives of modes**:
*   Mask identical plaintext blocks (i.e., two identical plaintext blocks should not produce identical ciphertext blocks).
*   Ensure two identical messages encrypted with the same key produce different ciphertexts (often using an IV).

### Common Modes:

*   **ECB (Electronic Code Book)**
    *   **How it works**: Each block of plaintext is encrypted independently with the key.
    *   **Pros**: Simple, parallelizable.
    *   **Cons**: **Highly insecure**. Identical plaintext blocks produce identical ciphertext blocks, revealing patterns in the data (e.g., the penguin image example where the outline is still visible).
    *   **IV**: Not used.

*   **CBC (Cipher Block Chaining)**
    *   **How it works**: Before encryption, each plaintext block is XORed with the *previous ciphertext block*. The first block is XORed with an Initialization Vector (IV).
    *   `ci = Ek(mi ⊕ ci-1)`, `c0 = IV`
    *   **Pros**: Hides patterns well. Most widely used mode.
    *   **Cons**: Encryption is sequential (not parallelizable). Decryption can be parallelized. Errors in one ciphertext block affect decryption of that block and the next.
    *   **IV**: Required. Must be unpredictable. Transmitted with ciphertext.

*   **CFB (Cipher Feedback)**
    *   **How it works**: Turns a block cipher into a self-synchronizing stream cipher. Encrypts the *previous ciphertext block* (or IV for the first block), then XORs a segment of this encrypted output with the current plaintext segment to produce the current ciphertext segment.
    *   `ci = Ek(ci-1) ⊕ mi` (for full block CFB), `c0 = IV`
    *   **Pros**: Can encrypt data units smaller than the block size. Self-synchronizing if bits are lost.
    *   **Cons**: Encryption is sequential. Slower than OFB or CTR.
    *   **IV**: Required. Must be unpredictable.

*   **OFB (Output Feedback)**
    *   **How it works**: Turns a block cipher into a synchronous stream cipher. It generates a keystream by repeatedly encrypting an IV (or the previous output of the encryption function). This keystream is then XORed with the plaintext.
    *   `Keystream_i = Ek(Keystream_i-1)`, `Keystream_0 = Ek(IV)`
    *   `ci = Keystream_i ⊕ mi`
    *   **Pros**: Keystream can be precomputed. Errors in ciphertext only affect the corresponding plaintext bits.
    *   **Cons**: Not self-synchronizing. If synchronization is lost, all subsequent data is garbled. IV reuse with the same key is catastrophic.
    *   **IV**: Required. Must be unique for each message encrypted with the same key.

*   **CTR (Counter Mode)**
    *   **How it works**: Turns a block cipher into a stream cipher. Encrypts a unique "counter" value for each block (typically a combination of a nonce and a sequential counter). The encrypted counter is then XORed with the plaintext block.
    *   `ci = Ek(Nonce || Counter_i) ⊕ mi`
    *   **Pros**: Highly parallelizable for both encryption and decryption. Allows random access to ciphertext blocks.
    *   **Cons**: IV (Nonce+Counter) reuse with the same key is catastrophic.
    *   **IV**: A "nonce" (number used once) is required, combined with a counter. The nonce must be unique for each message encrypted with the same key.

## 5. Initialization Vector (IV) / Nonce

*   **Purpose**: To introduce randomness and ensure that encrypting the same plaintext multiple times (with the same key) produces different ciphertexts. This is crucial for modes like CBC, CFB, OFB, and CTR.
*   **Common Errors**:
    *   **IV Reuse**: Reusing the same IV with the same key for different messages is a critical vulnerability, especially for stream-cipher-like modes (OFB, CFB, CTR) and CBC.
        *   **Impact (e.g., OFB/CTR)**: If `C1 = P1 ⊕ Keystream` and `C2 = P2 ⊕ Keystream` (same keystream due to IV/key reuse), then `C1 ⊕ C2 = P1 ⊕ P2`. If one plaintext (P1) is known (Known Plaintext Attack), the other (P2) can be recovered.
        *   **Impact (CBC)**: If the first blocks `P1` and `P1'` are the same, and the same IV is used, then `C1` and `C1'` will be the same, leaking information that the messages start identically.

### Attack Models (Context for IV importance)
*   **Ciphertext-only**: Attacker only has ciphertext(s).
*   **Known-plaintext**: Attacker has pairs of plaintext and corresponding ciphertext.
*   **Chosen-plaintext**: Attacker can choose plaintexts and obtain their ciphertexts.

## 6. Advantages and Disadvantages of Symmetric Cryptography

### Advantages
*   **Speed**: Generally much faster than asymmetric cryptography due to simpler operations (substitutions, permutations, XORs).
*   **Strong Security**: Well-designed algorithms (like AES) with sufficient key lengths are very secure.

### Disadvantages
*   **Key Distribution**: Securely sharing the secret key between parties is a major challenge. How do you get the key to the other person without an attacker intercepting it? (This is where asymmetric cryptography often helps).
*   **Key Management**: For `N` users needing to communicate securely with each other, `N(N-1)/2` unique keys are required. This becomes unmanageable for large groups.
*   **No Non-Repudiation**: Because the key is shared, you can't prove who created a message (either party with the key could have).
*   **Requires parties to be present/trust a TTP for initial key exchange.**

The challenges of key distribution and management in symmetric cryptography led to the development of **asymmetric (public-key) cryptography**.

## 7. Summary Table of Block Cipher Modes

| Mode | How it Works (Simplified)                                      | Pros                                                    | Cons                                                                         | IV/Nonce Usage                                     |
| :--- | :------------------------------------------------------------- | :------------------------------------------------------ | :--------------------------------------------------------------------------- | :------------------------------------------------- |
| ECB  | `Ci = Ek(Pi)`                                                  | Simple, parallelizable.                                 | Insecure: identical plaintext blocks -> identical ciphertext blocks.         | Not used.                                          |
| CBC  | `Ci = Ek(Pi ⊕ Ci-1)`, `C0 = IV`                                | Good pattern hiding, widely used.                       | Encryption sequential. Error propagation.                                    | IV required; must be unpredictable.                |
| CFB  | `Ci = Ek(Ci-1) ⊕ Pi` (segment-wise), `C0 = IV`                 | Stream cipher-like, can encrypt smaller units.          | Encryption sequential, slower than OFB/CTR. Error propagation within segment. | IV required; must be unpredictable.                |
| OFB  | `Keystream_i = Ek(Keystream_i-1)`, `Ci = Keystream_i ⊕ Pi`      | Stream cipher-like, keystream precomputation. No error propagation. | Not self-synchronizing. **Critical IV reuse vulnerability.**                   | IV required; must be unique per key.               |
| CTR  | `Ci = Ek(Nonce || Counter_i) ⊕ Pi`                             | Stream cipher-like, parallelizable, random access.      | **Critical Nonce reuse vulnerability.**                                         | Nonce + Counter required; Nonce unique per key.    |

