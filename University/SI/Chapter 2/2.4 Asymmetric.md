
# Asymmetric Cryptography (Public-Key Cryptography)

## 1. Introduction

*   **Concept Introduced**: By Diffie and Hellman in 1976.
*   **Core Idea**: Uses **two mathematically related keys** instead of one: a **public key** and a **private key**.
*   **Purpose**: Primarily solves the **key exchange problem** inherent in symmetric cryptography (how to securely share a secret key).

### Key Pair:
*   **Public Key (K_pub)**:
    *   **How it works**: Made available to everyone. Used to **encrypt** messages intended for the owner of the key pair, or to **verify** a digital signature created by the owner.
*   **Private Key (K_priv)**:
    *   **How it works**: Kept secret by the owner. Used to **decrypt** messages encrypted with the corresponding public key, or to **create** (sign) a digital signature.
*   **Fundamental Property**: A message encrypted with one key of the pair (e.g., public key) can *only* be decrypted by the *other* key in that pair (e.g., private key).

## 2. Main Objectives & Applications

Asymmetric cryptography helps achieve:

### a. Confidentiality
*   **Goal**: Ensure only the intended recipient can read the message.
*   **How it works (Alice sending to Bob):**
    1.  Bob generates a public/private key pair.
    2.  Bob shares his **public key** with Alice (and anyone else).
    3.  Alice wants to send a secret message (M) to Bob.
    4.  Alice encrypts M using **Bob's public key** to get ciphertext (C).
    5.  Alice sends C to Bob.
    6.  Bob uses his **private key** to decrypt C back to M.
    *   *Only Bob can decrypt it because only he has the corresponding private key.*

### b. Authentication, Integrity, and Non-Repudiation (via Digital Signatures)
*   **Goal**: Verify the sender's identity, ensure the message hasn't been tampered with, and prevent the sender from denying they sent it.
*   **How it works (Alice signing a message for Bob):**
    1.  Alice has a message (M) and her own public/private key pair.
    2.  Alice "encrypts" (or more commonly, encrypts a hash of) M using her **own private key**. This output is the digital signature (S).
    3.  Alice sends both M and S to Bob.
    4.  Bob receives M' (the message, possibly tampered) and S.
    5.  Bob "decrypts" S using **Alice's public key** to get a recovered hash (or message).
    6.  Bob independently calculates the hash of M'.
    7.  If the recovered hash matches the calculated hash of M', the signature is valid.
    *   *This proves the message came from Alice (only she has her private key) and hasn't been altered since she signed it.*

### Properties of Digital Signatures:
*   **Authentic**: Verifies the signer's identity.
*   **Unforgeable**: Very difficult for someone else to create a valid signature.
*   **Non-reusable**: A signature for one document cannot be used for another.
*   **Non-repudiable**: The signer cannot later deny having signed the document.
*   **Integrity (Unalterable)**: Ensures the signed document has not been modified after signing.

## 3. RSA Algorithm (Rivest, Shamir, Adleman)

*   The most well-known and widely used asymmetric algorithm.
*   **Underlying Principle**: Based on a **trapdoor one-way function**.
    *   **How it works**: It's computationally easy to perform an operation in one direction but extremely difficult to reverse it *unless* you have a secret piece of information (the "trapdoor"). For RSA, this is the difficulty of factoring large prime numbers.
        *   Multiplying two large prime numbers (`p * q = n`) is easy.
        *   Factoring `n` back into `p` and `q` is very hard if `n` is large. Knowing `p` and `q` is the trapdoor, allowing the private key to be derived.

### RSA Key Generation:
*   **How it works (Simplified Steps):**
    1.  **Choose Primes**: Select two very large, distinct prime numbers, `p` and `q` (kept secret).
    2.  **Compute Modulus `n`**: Calculate `n = p * q`. This `n` is part of both the public and private keys.
    3.  **Compute Euler's Totient `ø(n)`**: Calculate `ø(n) = (p-1) * (q-1)`. This value is kept secret.
    4.  **Choose Public Exponent `e`**: Select an integer `e` such that `1 < e < ø(n)` and `e` is coprime to `ø(n)` (i.e., their greatest common divisor is 1). A common choice for `e` is 65537.
    5.  **Compute Private Exponent `d`**: Calculate `d` such that `(d * e) mod ø(n) = 1`. `d` is the modular multiplicative inverse of `e` modulo `ø(n)`. (This is done using the Extended Euclidean Algorithm).
    *   **Public Key**: `{e, n}`
    *   **Private Key**: `{d, n}` (or sometimes `{d, p, q}` for faster operations)

### RSA Encryption (for Confidentiality):
*   **How it works**: To encrypt a message `M` (represented as a number smaller than `n`):
    *   `Ciphertext (C) = M^e mod n`

### RSA Decryption (for Confidentiality):
*   **How it works**: To decrypt ciphertext `C`:
    *   `Message (M) = C^d mod n`

### RSA for Digital Signatures:
*   **Signing**: `Signature (S) = (Hash_of_M)^d mod n` (using sender's private key `d`)
*   **Verifying**: `Recovered_Hash = S^e mod n` (using sender's public key `e`). Compare with a new hash of the received message.

### Mathematical Tools Used in RSA:
*   **Euclidean Algorithm**:
    *   **How it works**: Efficiently finds the greatest common divisor (GCD) of two integers. Used to ensure `e` is coprime to `ø(n)`.
*   **Extended Euclidean Algorithm (derived from Bézout's Identity)**:
    *   **How it works**: Finds integers `x` and `y` such that `ax + by = gcd(a,b)`. Used to find `d` (the private exponent) by solving `e*d + k*ø(n) = 1` for `d`.

## 4. Other Asymmetric Principles/Algorithms
*   **Discrete Logarithm Problem (DLP)**: Forms the basis for algorithms like:
    *   **ElGamal**: Used for encryption and digital signatures.
    *   **Diffie-Hellman Key Exchange**: Not an encryption algorithm itself, but a method for two parties to securely establish a shared secret key over an insecure channel.
    *   **Elliptic Curve Cryptography (ECC)**: Offers similar security to RSA but with much smaller key sizes, making it efficient for resource-constrained devices.
*   **Knapsack Problem**:
    *   **Merkle-Hellman**: An early public-key system, largely broken now.

## 5. Key Lengths
*   Asymmetric keys are much longer than symmetric keys for comparable security.
*   RSA: Typically 1024 bits (older, less secure), 2048 bits (common), 3072 bits, or 4096 bits.
    *   A 512-bit RSA key is considered insecure.
*   ECC: Can provide similar security with smaller keys (e.g., ECC 256-bit ~ RSA 3072-bit).

## 6. Advantages of Asymmetric Cryptography
*   **Key Distribution**: Solves the main problem of symmetric crypto; no need to securely pre-share a secret key. Public keys can be distributed openly.
*   **Digital Signatures**: Provides authentication, integrity, and non-repudiation, which symmetric crypto alone cannot.
*   **Key Management**: For `N` users, only `N` key pairs are needed, versus `N(N-1)/2` keys for symmetric pairwise communication.

## 7. Disadvantages of Asymmetric Cryptography
*   **Speed**: Significantly slower than symmetric algorithms (e.g., RSA can be 100-1000 times slower than AES).
*   **Key Size**: Requires much longer keys for equivalent security compared to symmetric ciphers.
*   **Not Suited for Bulk Encryption**: Due to speed, it's generally not used to encrypt large volumes of data directly.

## 8. Hybrid Cryptography (e.g., PGP/GPG, TLS/SSL)

Combines the strengths of both symmetric and asymmetric cryptography.
*   **How it works (General Idea):**
    1.  **Generate Session Key**: A random, one-time symmetric key (e.g., an AES key) is generated. This is called a "session key."
    2.  **Symmetric Encryption**: The actual data/message is encrypted using the fast symmetric algorithm with this session key.
    3.  **Asymmetric Encryption of Session Key**: The (small) session key is then encrypted using the recipient's **public key** (asymmetric).
    4.  **Transmission**: The (symmetrically) encrypted data and the (asymmetrically) encrypted session key are sent to the recipient.
    5.  **Decryption by Recipient**:
        *   Recipient uses their **private key** to decrypt the session key.
        *   Recipient uses the now-decrypted session key to symmetrically decrypt the actual data.
*   **Benefit**: Achieves the speed of symmetric encryption for bulk data and the key management convenience of asymmetric encryption for the session key.

## 9. Summary Table: Symmetric vs. Asymmetric Cryptography

| Feature             | Symmetric Cryptography                                  | Asymmetric Cryptography                                    |
| :------------------ | :------------------------------------------------------ | :--------------------------------------------------------- |
| **Key Used**        | Single shared secret key for encryption & decryption.   | Two keys: public key (encryption/verify) & private key (decryption/sign). |
| **Key Length**      | Shorter (e.g., AES 128, 256 bits).                      | Much longer (e.g., RSA 2048, 4096 bits).                 |
| **Speed**           | Fast, suitable for bulk data encryption.                | Slow, not ideal for bulk data directly.                    |
| **Key Distribution**| Major challenge: secure exchange of the secret key.     | Simpler: public key can be shared openly.                  |
| **Key Management**  | `N(N-1)/2` keys for `N` users for pairwise communication. | `N` key pairs for `N` users.                               |
| **Primary Uses**    | Confidentiality of data.                                | Key exchange, digital signatures, confidentiality (often of smaller data like session keys). |
| **Digital Signature**| Does not directly provide. (MACs for integrity/auth).   | Directly provides (authentication, non-repudiation).       |
| **Example Algo.**   | AES, DES, ChaCha20.                                     | RSA, ElGamal, ECC.                                         |
]