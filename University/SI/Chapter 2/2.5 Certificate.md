
# Digital Signatures and Public Key Infrastructure (PKI)

## 1. Digital Signatures

### 1.1. Purpose (Compared to Handwritten Signatures)

Handwritten signatures aim to:
*   Prove the identity of the author/signer.
*   Indicate the signer's agreement with the document's content.

**Questions regarding handwritten signatures that digital signatures address:**
*   Can the document content be changed after signing? (Integrity)
*   Can the signature be imitated/forged? (Authenticity, Unforgeability)
*   Can the signature be reused on another document? (Non-reusability)
*   Is the signature specific to the document? (Specificity)

An **electronic signature** depends on both the **signatory** and the **document**.

### 1.2. Objectives of a Digital Signature

A digital signature aims to provide:
1.  **Authenticity**: The identity of the signatory can be reliably verified.
2.  **Unforgeability (Integrity of Signer)**: The signature cannot be easily falsified or imitated. Someone cannot impersonate another signer.
3.  **Non-reusability**: The signature is an integral part of the signed document and cannot be moved or reused on another document.
4.  **Non-repudiation**: The person who signed the document cannot later deny having signed it.
5.  **Integrity (of Document)**: A document, once signed, is unalterable. Any modification after signing will invalidate the signature.

### 1.3. Practical Implementation: Asymmetric Cryptography

Digital signatures are practically realized using **public-key cryptosystems**.

#### 1.3.1. Basic Digital Signature Process (Without Hashing)

1.  **Signing (Alice)**:
    *   Alice has a message `M`.
    *   Alice uses her **private key** (`Kpriv_A`) to encrypt/sign the message `M`.
        *   `S = E_Kpriv_A(M)` (where `S` is the signature, `E` is the signing/encryption algorithm)
    *   Alice sends both the original message `M` and the signature `S` to Bob.

2.  **Verification (Bob)**:
    *   Bob receives `M'` (potentially `M`) and `S'`.
    *   Bob uses Alice's **public key** (`Kpub_A`) to decrypt/verify the signature `S'`.
        *   `M'' = D_Kpub_A(S')` (where `D` is the verification/decryption algorithm)
    *   Bob compares the received message `M'` with the result of the verification `M''`.
    *   If `M' == M''`, the signature is valid, confirming Alice signed `M` and `M` has not been altered.

#### 1.3.2. Digital Signature with Hashing (Preferred Method)

It's generally preferred to sign the **hash** of a document rather than the entire document.

**Motivations for signing the hash:**
*   **Efficiency with long messages**:
    *   Saves computation time (hashing is faster than asymmetric encryption for large data).
    *   Saves transmission time (the hash is small and fixed-size).
*   **Fixed-size input**: Hash functions produce a fixed-size output, which is more efficient for public-key cryptography algorithms.

**Process with Hashing:**
1.  **Signing (Alice)**:
    *   Alice has a message `M`.
    *   Alice calculates the hash of the message: `H = Hash(M)`.
    *   Alice uses her **private key** (`Kpriv_A`) to encrypt/sign the hash `H`.
        *   `S = E_Kpriv_A(H)`
    *   Alice sends the original message `M` and the signature `S` to Bob.

2.  **Verification (Bob)**:
    *   Bob receives `M'` and `S'`.
    *   Bob calculates the hash of the received message: `H' = Hash(M')`.
    *   Bob uses Alice's **public key** (`Kpub_A`) to decrypt/verify the signature `S'`.
        *   `H'' = D_Kpub_A(S')`
    *   Bob compares the hash he computed (`H'`) with the hash from the signature (`H''`).
    *   If `H' == H''`, the signature is valid. This proves:
        *   **Authenticity**: Only Alice (owner of `Kpriv_A`) could have created `S`.
        *   **Integrity**: If `M'` was altered, `H'` would not match `H''`.

**Summary of Signing/Verification (with hashing):**
*   **Alice signs M:**
    *   `h_M = Hash(M)`
    *   Uses her secret key `K_d` (private key)
    *   Uses signing function `E`
    *   Result: `s(M) = E_Kd(h_M)`
    *   Signed document: `[M, s(M)]`
*   **Verification of [M, s(M)]:**
    *   Uses Alice's public key `K_e`
    *   Uses verification function `D`
    *   `D_Ke(s(M)) =? Hash(M)` (recompute hash of M and compare)
    *   Confirms only Alice could generate `s(M)`.

## 2. The Public Key Management Problem

If Alice and Bob do not know each other, how can they securely exchange their public keys to start communication?
*   Simply publishing a public key on a website is vulnerable.
*   **Man-in-the-Middle (MITM) Attack**:
    1.  Alice wants to send her public key to Bob.
    2.  Eve (attacker) intercepts Alice's public key.
    3.  Eve sends her own public key to Bob, pretending it's Alice's.
    4.  Bob encrypts messages for Alice using Eve's public key. Eve can decrypt them.
    5.  Eve can also impersonate Bob to Alice.

## 3. Electronic Certificates: Public Key Certificates

A **digital certificate** (or electronic certificate) is an electronic document that:
*   Serves to prove that a public key belongs to its rightful owner (an individual, organization, device, etc.).
*   Is like an "ID card" for a public key.
*   Is issued by a trusted entity called a **Certification Authority (CA)**.

**A typical certificate contains:**
*   The public key itself.
*   Information about the owner (Subject: name, email, IP address, etc.).
*   Information about the issuer (CA).
*   Validity period.
*   A **digital signature from the CA**, created using the CA's private key. This signature vouches for the authenticity of the certificate's content.

### 3.1. X.509 Certificates

X.509 is a standard format for public key certificates.
*   Issued by a trusted entity: **Certification Authority (CA)** (e.g., Digicert, Verisign, Let's Encrypt).
*   The CA signs the hash of the certificate's data fields with its own private key.

**Key Fields in an X.509 Certificate (v3):**
*   **Version**: X.509 version number (e.g., v3).
*   **Serial Number**: A unique number for the certificate, assigned by the CA.
*   **Signature Algorithm ID**: Identifier for the algorithm used by the CA to sign the certificate.
*   **Issuer Name**: Distinguished Name (DN) of the CA that issued the certificate.
*   **Validity Period**: Start and end dates for which the certificate is valid.
*   **Subject Name**: Distinguished Name (DN) of the entity whose public key is in the certificate.
*   **Subject Public Key Info**: The public key of the subject, along with the algorithm identifier.
*   **Issuer Unique ID** (Optional, v2/v3): Unique identifier for the issuer.
*   **Subject Unique ID** (Optional, v2/v3): Unique identifier for the subject.
*   **Extensions** (Optional, v3): Additional information (e.g., key usage, alternative subject names).
*   **Certificate Signature Algorithm**: Algorithm used to sign the certificate.
*   **Certificate Signature Value**: The CA's digital signature on the above fields.

## 4. Public Key Infrastructure (PKI)

**PKI** is the set of hardware, software, people, policies, and procedures needed to create, manage, distribute, use, store, and revoke digital certificates and manage public-key encryption.

### 4.1. PKI Models

1.  **Hierarchical PKI (e.g., PKIX based on X.509):**
    *   Relies on a hierarchy of CAs.
    *   A Root CA is at the top, often self-signed or cross-certified.
    *   Intermediate CAs are certified by the Root CA or other Intermediates.
    *   Issuing CAs (at the bottom or an intermediate level) issue certificates to end-entities (users, servers).
    *   Trust flows downwards from the Root CA.

2.  **Web of Trust (e.g., PGP):**
    *   Non-hierarchical.
    *   Each user can act as a CA, signing other users' keys they trust.
    *   Trust is established based on mutual endorsements.
    *   Primarily used for email (PGP) and secure P2P.

### 4.2. PKI Components (PKIX)

*   **Certification Authority (CA)**:
    *   An entity that issues digital certificates and Certificate Revocation Lists (CRLs).
    *   Signs Certificate Signing Requests (CSRs) to create certificates.
    *   Signs CRLs.
    *   **Types of CAs:**
        *   **Root CA**: Top-level CA in a hierarchy. Its certificate is self-signed.
        *   **Intermediate CA**: Issues certificates to other CAs or end-entities. Its certificate is signed by a superior CA.
        *   **Issuing CA (or Signature Authority)**: Issues certificates to end-users/entities.
*   **Registration Authority (RA)**:
    *   An entity responsible for identifying and authenticating subscribers of certificates.
    *   Verifies certificate requests before they are passed to the CA. May be part of the CA.
*   **Certificate**: The X.509 digital certificate.
*   **Certificate Signing Request (CSR)**: A message sent from an applicant to a CA to apply for a digital certificate. It contains the applicant's public key and identifying information.
*   **Certificate Revocation List (CRL)**: A list of certificates (by serial number) that have been revoked before their scheduled expiration date and should no longer be trusted. Published by the CA.
*   **Certificate Repository/Directory**: A system for storing and distributing certificates and CRLs (e.g., LDAP, HTTP).

### 4.3. PKI Workflow (Certificate Issuance)

1.  **Key Pair Generation (Alice/End-entity)**: Alice generates a public/private key pair.
2.  **CSR Creation (Alice)**: Alice creates a CSR containing her public key and identity information.
3.  **Send CSR to RA**: Alice sends the CSR to a Registration Authority.
4.  **Identity Verification (RA)**: The RA verifies Alice's identity and the information in the CSR.
5.  **Forward Request to CA (RA)**: The RA forwards the validated request to the CA.
6.  **Certificate Generation & Signing (CA)**: The CA creates a certificate containing Alice's public key and info, then signs it with its (the CA's) private key.
7.  **Certificate Publication (CA)**: The CA publishes the signed certificate in a repository/directory, and/or sends it to Alice.

### 4.4. How Web Certificates Work (HTTPS Example - Simplified)

1.  **CA Root Certificate Distribution**: CAs (e.g., Sectigo, DigiCert) distribute their Root CA certificates to browser vendors (Google, Mozilla, Apple, Microsoft). These Root CA certificates are included in the browser's (or OS's) "trust store."
2.  **Website Obtains Certificate**: A company (e.g., `gmail.com`) wants to secure its website. It requests a certificate from a CA for its domain.
3.  **CA Issues Certificate**: The CA verifies the company's identity/domain control and issues a certificate for `gmail.com`, signed by the CA's private key.
4.  **User Accesses Website**:
    *   A user's browser attempts to connect to `https://gmail.com`.
    *   The `gmail.com` server sends its certificate to the browser.
5.  **Browser Verifies Certificate**:
    *   The browser checks the signature on `gmail.com`'s certificate. It uses the public key of the issuing CA (found in the CA's certificate, which might be an intermediate CA).
    *   It traces back the chain of certificates (see "Chain of Trust" below) until it reaches a Root CA certificate present in its trust store.
    *   If the signature is valid and the certificate chain leads to a trusted Root CA, the certificate is accepted.
6.  **Secure Connection**: The browser establishes an encrypted (HTTPS) connection with `gmail.com`.

### 4.5. Certificate Verification Process (Detailed)

When a browser receives a certificate (e.g., for `gmail.com`, signed by `Intermediate CA X`):
1.  The browser takes the content of `gmail.com`'s certificate (excluding the signature part).
2.  It computes a hash of this content: `H_calculated`.
3.  It takes the digital signature part of `gmail.com`'s certificate.
4.  It uses the public key of `Intermediate CA X` (obtained from `Intermediate CA X`'s own certificate) to decrypt/verify this signature. This yields a hash: `H_from_signature`.
5.  If `H_calculated == H_from_signature`, the signature on `gmail.com`'s certificate is valid.
6.  The browser then repeats this process for `Intermediate CA X`'s certificate, verifying its signature using the public key of its issuer (e.g., a Root CA).
7.  This continues until a self-signed Root CA certificate is found in the browser's trusted store.

### 4.6. Chain of Trust (Hierarchical Model)

Certificates are often issued in a hierarchy, forming a "chain of trust":
*   **Root CA Certificate**:
    *   At the top of the hierarchy.
    *   Its certificate is **self-signed** (signed by its own private key).
    *   These are pre-installed in browsers/OS trust stores. This is the anchor of trust.
    *   Often kept offline for security.
*   **Intermediate CA Certificate(s)**:
    *   Signed by the Root CA (or another Intermediate CA above it).
    *   Can sign other Intermediate CA certificates or end-entity certificates.
*   **End-Entity Certificate** (e.g., for a website, user, or device):
    *   Signed by an Issuing CA (which could be an Intermediate CA).

**Verification**: To trust an end-entity certificate, a verifier (e.g., browser) checks the signature on it using the public key from the issuer's certificate. It then checks the signature on the issuer's certificate using the public key from *its* issuer's certificate, and so on, until it reaches a trusted Root CA certificate. If any signature in the chain is invalid, or if the chain doesn't lead to a trusted root, the end-entity certificate is not trusted.

**Example from slide (univ-boumerdes.dz):**
*   **Root CA**: Sectigo (self-signed, trusted by browser)
    *   Signs -> **Intermediate CA**: Sectigo RSA Domain Validation Secure Server CA
        *   Signs -> **End-Entity**: `*.univ-boumerdes.dz`

## 5. Services of PKI Entities

### 5.1. CA Services

*   **Create certificates**: Issue new certificates based on validated requests.
*   **Publish certificates**: Make certificates available (e.g., in a directory).
*   **Extend certificate validity (renewal)**: Issue new certificates to replace expiring ones.
*   **Revoke certificates**:
    *   Mark a certificate as no longer valid before its expiration date.
    *   Publish revoked certificate serial numbers in a **Certificate Revocation List (CRL)** or via **Online Certificate Status Protocol (OCSP)**.
    *   **Reasons for revocation**:
        *   Compromise of the subject's private key.
        *   Change in the subject's status or information (e.g., employee leaves company).
        *   Compromise of the CA's own private key.
        *   Certificate no longer needed.

### 5.2. RA Services

*   **Subject Authentication**: Personal (physical or logical) authentication of the entity requesting a certificate.
*   **Information Verification**: Verify the validity of information provided by the applicant.
*   **Authorization Validation**: Validate that the subject has the right to request a certificate for the given identity/resource.
*   **Proof of Possession (POP) Verification**: Verify that the subject actually possesses the private key corresponding to the public key in the CSR.
*   **Reporting Key Compromise**: Inform the CA if a key compromise is detected, necessitating revocation.
*   **Name Assignment**: Assign unique names or identifiers for identification purposes.
*   **Process Initiation**: Trigger the registration process with the CA for the end-entity.
*   **(Potentially) Private Key Archival/Recovery**: In some systems, manage key backup and recovery (though this is often handled carefully due to security implications).
*   **(Potentially) Private Key Distribution**: Distribute private keys via secure means (e.g., smart cards, USB tokens), though more commonly the subject generates their own keys.
